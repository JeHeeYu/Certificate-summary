# 프로그래밍 언어 과목 기출문제 모음

### C언어에서 문자열 처리 함수의 서식과 그 기능의 연결로 틀린 것은?
> 2022년 4월 24일 기출문제 (정답률 : 62%)
1. strlen(s) - s의 길이를 구한다.
2. strcpy(s1, s2) - s2를 s1으로 복사한다.
3. strcmp(s1, s2) - s1과 s2를 연결한다.
4. strrev(s) - s를 거꾸로 변환한다.

<details>
<summary><h3>정답</h3></summary>

### 3번

<문제 해설>
<br>
<br>
* strcmp는 문자열 비교 함수로, 연결 함수는 strcat 함수 사용
</details>

---

### 다음 C언어 프로그램이 실행되었을 때, 실행 결과는?
> 2022년 4월 24일 기출문제
```
#include <stdio.h>

int main(int argc, char *argv[]) {
    int a = 5, b = 3, c = 12;
    int t1, t2, t3;
    t1 = a && b;
    t2 = a || b;
    t3 = !c;
    printf("%d", t1 + t2 + t3);
    return 0;
}
```
1. 0
2. 5
3. 5
4. 14

<details>
<summary><h3>정답</h3></summary>

### 2번

<문제 해설>
<br>
<br>
* a && b는 둘 다 true 이므로 1
* a || b는 둘 다 true 이므로 1
* !c는 false 이므로 0
</details>

---

### 다음 C언어 프로그램이 실행되었을 때, 실행 결과는?
> 2022년 4월 24일 기출문제 (정답률 : 50%)
```
#include <stdio.h>
struct st {
    int a;
    int c[10];
}

int main(int argc, char *argv[]) {
    int i = 0;
    struct st ob1;
    struct st ob2;
    ob1.a = 0;
    ob2.a = 0;
    
    for(i = 0; i < 10; i++) {
        ob1.c[i] = i;
        ob2.c[i] = ob1.c[i] + i;
    }
    
    for(i = 0; i < 10; i = i+2) {
        ob1.a = ob1.a + ob1.c[i];
        ob2.a = ob2.a + ob2.c[i];
    }
    
    printf("%d", ob1.a + ob2.a);
    return 0;
}
```
1. 30
2. 60
3. 80
4. 120

<details>
<summary><h3>정답</h3></summary>

### 2번

<문제 해설>
<br>
<br>
* ob1.c[i] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
* ob2.c[i] = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18}
* (2 + 4 + 6 + 8) + (4, 8, 12, 16) = 60
</details>

---

### IP 프로토콜에서 사용하는 필드와 해당 필드에 대한 설명으로 틀린 것은?
> 2022년 4월 24일 기출문제 (정답률 : 47%)
1. Header Length는 IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다.
2. Packet Length는 IP 헤더를 제외한 패킷 전체의 길이를 나타내며 최대 크기는 2^32 - 1비트이다.
3. Time to Live는 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것이다.
4. Version Number는 IP 프로토콜의 버전번호를 나타낸다.

<details>
<summary><h3>정답</h3></summary>

### 2번

<문제 해설>
<br>
<br>
* Packet Length는 16비트로, IP 헤더 및 데이터를 포함한 IP Packet 전체 길이를 바이트 단위로 표시
* 최대 값은 16비트이므로 65535 = 2^16 - 1)
</details>

---

### 다음 Python 프로그램의 실행 결과가 [실행결과]와 같을 때, 빈칸에 적합한 것은?
> 2022년 4월 24일 기출문제 (정답률 : 60%)
```
x = 20

if x == 10:
    print('10')
(  ) x == 20:
    print('20')
else:
    print('other')
```

<details>
<summary><h3>정답</h3></summary>

### 2번

<문제 해설>
<br>
<br>
* Python의 조건문은 if - elif - else 문으로 구성되어 있음
</details>

---

### RIP 라우팅 프로토콜에 대한 설명으로 틀린 것은?
> 2022년 4월 24일 기출문제 (정답률 : 51%)
1. 경로 선택 메트릭은 홉 카운트(hop count)이다.
2. 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 EGP에 해당한다.
3. 최단 경로 탐색에 Bellman-Ford 알고리즘을 사용한다.
4. 각 라우터는 이웃 라우터들로부터 수신한 정보를 이용하여 라우팅 표를 갱신한다.

<details>
<summary><h3>정답</h3></summary>

### 2번

<문제 해설>
<br>
<br>
* RIP(Routing Information Protocol)
  * 최단 경로 탐색에는 Bellman-Ford 알고리즘을 사용하는 거리 벡터 라우팅 프로토콜
  * 라우팅 프로토콜을 IGP와 EGP로 분류 시 IGP에 해당함
  * 최적의 경로를 산출하기 위한 정버로서 홉(거리 값)만을 고려
  * 소규모 네트워크 환경에 적합
  * 최대 홉 카운트를 15홉 이하로 한정
</details>

---

### 다음에서 설명하는 프로세스 스케줄링은?
> 2022년 4월 24일 기출문제 (정답률 : 63%)
```
최소 작업 우선(SJF) 기법의 약점을 보완한 비선점 스케줄링 기법으로 다음과 같은 식을 이용해 우선순위를 판별한다.

우선순위 = (대기한 시간 + 서비스를 받을 시간) / 서비스를 받을 시간
```
1. FIFO 스케줄링
2. RR 스케줄링
3. HRN 스케줄링
4. MQ 스케줄링

<details>
<summary><h3>정답</h3></summary>

### 3번

<문제 해설>
<br>
<br>
* HRN 스케줄링 방식
  * 비선점 스케줄링 방식임
  * 실행시간이 긴 프로세스에 불리한 SJF를 보완하기 위해 대시간 및 서비스 시간을 이용
  * 긴 작업과 짧은 작업 간의 지나친 불평등 해소 가능
  우선순위를 계산 숫자가 높은 것부터 낮은 순으로 순위 부여
  * (대기시간 + 서비스시간) / 서비스 시간 값으로, 클수록 우선순위가 높음
</details>

---

### UNIX 운영체제에 관한 특징으로 틀린 것은?
> 2022년 4월 24일 기출문제 (정답률 : 65%)
1. 하나 이상의 작업에 대하여 백그라운드에서 수행이 가능하다.
2. Multi-User는 지원하지만 Multi-Tasking은 지원하지 않는다.
3. 트리 구조의 파일 시스템을 갖는다.
4. 이식성이 높으며 장치 간의 호환성이 높다.

<details>
<summary><h3>정답</h3></summary>

### 2번

<문제 해설>
<br>
<br>
* UNIX 운영체제의 특징
  * 주로 서버용 컴퓨터에섯 ㅏ용됨
  * Time Sharing System을 위해 설계된 대화식 운영체제
  * C언어로 작성되어 이식성이 높고 장치간 호환성이 높음
  * Multi User, Multi Tasking 모두 지원
  * 트리 구조의 파일 시스템
</details>

---

## UDP 프로토콜의 특징이 아닌 것은?
> 2022년 4월 24일 기출문제 (정답률 : 45%)
1. 비연결형 서비스를 제공한다.
2. 단순한 헤더 구조로 오버헤드가 적다.
3. 주로 주소를 지정하고, 경로를 설정하는 기능을 한다.
4. TCP와 같이 트랜스포트 계층에 존재한다.

<details>
<summary><h3>정답</h3></summary>

### 3번

<문제 해설>
<br>
<br>
* UDP(User Datagram Protocol)
  * 비연결형 및 비신뢰성 전송 서비스 제공
  * 흐름 제어나 순서 제어가 없어 전송 속도가 빠름
  * 수신된 데이터의 순서 재조정 기능을 지원하지 않음
  * 복구 기능을 제공하지 않음
* 오답인 3번의 경우 IP Protocol에 관한 내용
</details>

---

### Python 데이터 타입 중 시퀀스(Sequence) 데이터 타입에 해당하며 다양한 데이터 타입들을 주어진 순서에 따라 저장할 수 있으나 저장된 내용을 변경할 수 없는 것은?
> 2022년 4월 24일 기출문제 (정답률 : 43%)
1. 복소수(complex) 타입
2. 리스트(list) 타입
3. 사전(dict) 타입
4. 튜플(tuple) 타입

<details>
<summary><h3>정답</h3></summary>

### 4번

<문제 해설>
<br>
<br>
* 튜플 타입은 불변형으로, 내용을 변경할 수 없음
</details>

---

### 다음 JAVA 프로그램이 실행되었을 때, 실행결과는?
> 2022년 4월 24일 기출문제 (정답률 : 69%)
```
public class Rarr {
  static int[] marr() {
    int temp[] = new int[4];
    for(int i = 0; i < temp.length; i++) 
      temp[i] = i;
    return temp;
  }

public static void main(String[] args) {
  int iarr[];
  iarr = marr();
  for(int i = 0; i < iarr.length; i++)
    System.out.print(iarr[i] + " ");
  }
}
```
1. 1 2 3 4
2. 0 1 2 3
3. 1 2 3
4. 0 1 2

<details>
<summary><h3>정답</h3></summary>

### 2번

<문제 해설>
<br>
<br>
* return 되는 temp = {0 1, 2, 3}
* 0 + 1 + 2 + 3
</details>

---

### 다음 JAVA 프로그램이 실행되었을 때의 결과는?
> 2022년 4월 24일 기출문제 (정답률 : 54%)
```
public class ovr {
  public static void main(String[] args) {
    int a = 1, b = 2, c = 3, d = 4;
    int mx, mn;
    mx = a < b ? b : a;
    if(mx==1) {
        mn = a > mx ? b : a;
    }
    else {
        mn = b < mx ? d : c;
    }
    System.out.print(mn);
  }
}
```
1. 1
2. 2
3. 3
4. 4

<details>
<summary><h3>정답</h3></summary>

### 3번

<문제 해설>
<br>
<br>
* mx a < b ? d : a; = a는 b보다 작으므로 true. mx = 2;
* if 조건에 해당하지 않으므로 else 조건 실행
* b는2, mx도2 이므로 b < mx는 거짓, 따라서 c값인 3 할당
</details>

---

### Myers가 구분한 응집도(Cohesion)의 정도에서 가장 낮은 응집도를 갖는 단계는?
> 2022년 4월 24일 기출문제 (정답률 : 69%)
1. 순차적 응집도(Sequential Cohension)
2. 기능적 응집도(Functional Cohesion)
3. 시간적 응집도(Temporal Cohesion)
4. 우연적 응집도(Coincidential Cohesion)

<details>
<summary><h3>정답</h3></summary>

### 3번

<문제 해설>
<br>
<br>
* 응집도의 강함 순서
  * 기능적 -> 순차적 -> 교환적 -> 절차적 -> 시간적 -> 논리적 -> 우연적
</details>

---

### 다음 C언어 프로그램이 실행되었을 때, 실행 결과는?
> 2022년 4월 24일 기출문제 (정답률 : 54%)
```
#include <stdio.h>
int main(int arge, char *argv[]) {
    int n = 1, n = 2, n = 3;
    int r1, r2, r3;
    
    r1 = (n2 <= 2) || (n3 > 3);
    r2 = !n3;
    r3 = (n1 > 1) && (n2 < 3);
    
    printf("%d", r3 - r2 + r1);
    return 0;
}
```
1. 0
2. 1
3. 2
4. 3

<details>
<summary><h3>정답</h3></summary>

### 2번

<문제 해설>
<br>
<br>
* r1 값의 경우 OR 조건으로 1가지만 해당하면 1 반환, 이 경우 n2 <= 2가 true임
* r2 값의 경우 3을 not으로 변환하면 false이므로 0
* r3 값의 경우 AND 조건으로 2가지 모두 해당하면 1 반환, 이 경우 n1 > 1이 false이므로 0 반환
</details>

---

### IP 프로토콜의 주요 특징에 해당하지 않는 것은?
> 2022년 4월 24일 기출문제 (정답률 : 47%)
1. 체크섬(Checksum) 기능으로 데이터 체크섬(Data Checksum)만 제공한다.
2. 패킷을 분할, 병합하는 기능을 수행하기도 한다.
3. 비연결형 서비스를 제공한다.
4. Base Effort 원칙에 따른 전송 기능을 제공한다.

<details>
<summary><h3>정답</h3></summary>

### 1번

<문제 해설>
<br>
<br>
* 데이터 체크섬은 제공하지 않고, 헤더 체크섬만 제공함
</details>

---

### 4개의 페이지를 수용할 수 있는 주기억장치가 있으며, 초기에는 모두 비어 있다고 가정한다. 다음의 순서로 페이지 참조가 발생할 때, LRU 페이지 교체 알고리즘을 사용할 경우 몇 번의 페이지 결함이 발생하는가?
> 2022년 4월 24일 기출문제 (정답률 : 50%)
```
페이지 참조 순서 1, 2, 3, 1, 2, 4, 1, 2, 5
```
1. 5회
2. 6회
3. 7회
4. 8회

<details>
<summary><h3>정답</h3></summary>

### 1번

<문제 해설>
<br>
<br>
* LRU 알고리즘은 가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘
</details>

---

### 사용자 수준에서 지원되는 스레드(thread)가 커널에서 지원되는 스레드에 비해 가지는 장점으로 옳은 것은?
> 2022년 4월 24일 기출문제 (정답률 : 39%)
1. 한 프로세스가 운영체제를 호출할 때 전체 프로세스가 대기할 필요가 없으므로 시스템 성능을 높일 수 있다.
2. 동시에 여러 스레드가 커널에 접근할 수 있으므로 여러 스레드가 시스템 호출을 동시에 사용할 수 있다.
3. 각 스레드를 개별적으로 관리할 수 있으므로 스레드의 독립적인 스케줄링이 가능하다.
4. 커널 모드로의 전환 없이 스레드 교환이 가능하므로 오버헤드가 줄어든다.

<details>
<summary><h3>정답</h3></summary>

### 4번

<문제 해설>
<br>
<br>
* 1, 2, 3번은 커널 수준 스레드의 장점이나, 4번의 경우 사용자 스레드의 장점임
</details>

---

### 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우의 결합도는?
> 2022년 4월 24일 기출문제 (정답률 : 63%)
1. 내용 결합도(Content Coupling)
2. 제어 결합도(Control Coupling)
3. 공통 결합도(Common Coupling)
4. 스탬프 결합도(Stamp Coupling)

<details>
<summary><h3>정답</h3></summary>

### 1번

<문제 해설>
<br>
<br>
* 내용 결합도 : 하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때 두 모듈은 내용적으로 결합되어 있는 경우의 결합도
* 공통 결합도 : 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도
* 스탬프 결합도 : 두 모듈이 매개변수로 자료를 전달할 때, 자료구조 형태로 전달되어 이용될 때 데이터가 결합되어 있는 경우의 결합도
</details>

---

### a[0]의 주소값이 10일 경우 다음 C언어 프로그램이 실행되었을 때의 결과는? (단, int형의 크기는 4Byte로 가정한다.)
> 2022년 4월 24일 기출문제 (정답률 : 47%)
```
#include <stdio.h>
int main(int argc, char *argv[]) {
    int a[] = {14, 22, 30, 38};
    printf("%u, ", &a[2]);
    printf("%u", a);
    return 0;
}
```
1. 14, 10
2. 14, 14
3. 18, 10
4. 18, 14

<details>
<summary><h3>정답</h3></summary>

### 3번

<문제 해설>
<br>
<br>
* a[2] 자리의 첫번째 주소값은 18, a[0] 자리의 첫번째 주소값은 10
</details>

---

### 모듈화(Modularity)와 관련한 설명으로 틀린 것은?
> 2022년 4월 24일 기출문제 (정답률 : 53%)
1. 시스템을 모듈로 분할하면 각각의 모듈을 별개로 만들고 수정할 수 있기 때문에 좋은 구조가 된다.
2. 응집도는 모듈과 모듈 사이의 상호의존 또는 연관 정도를 의미한다.
3. 모듈 간의 결합도가 약해야 독립적인 모듈이 될 수 있다.
4. 모듈 내 구성 요소들 간의 응집도가 강해야 좋은 모듈 설계이다.

<details>
<summary><h3>정답</h3></summary>

### 2번

<문제 해설>
<br>
<br>
* 응집도 : 모듈이 독립적인 기능으로 정의되어 있는 정도
* 결합도 : 모듈과 모듈 사이의 상호의존 또는 연관 정도
* 2번의 경우 결합도의 내용
</details>

---

