# 소프트웨어 개발 과목 정리 내용


## 자료 구조

### 자료 구조의 분류
* 선형 구조(Linear Structure)
  * 배열(Array)
  * 스택(Stack)
  * 큐(Queue)
  * 디큐(덱)
  * 선형 리스트(Linear List)
    * 연속 리스트(Contiguous List)
    * 연결 리스트(Linked List)
    

* 비 선형구조(Non-Linear Structure)
  * 트리(Tree)
  * 그래프(Graph)
  
### 선형 리스트(Linear List)

#### 연속 리스트(Contiguous List)
* <b>연속 리스트는 배열과 같이 연속되는 기억장소에 저장</b>되는 자료구조
* 기억장소를 <b>연속적으로 배정받기 때문에 이용 효율은 밀도가 1로서 가장 좋음</b>
* 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 하며 <b>삽입 및 삭제 시 자료의 이동이 필요</b>

#### 연결 리스트(Linked List)
* <b>자료들을 연속적으로 배열시키지 않고</b> 임의의 기억공간에 기억, 자료 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조
* 노드의 <b>삽입 및 삭제 작업</b>이 용이
* 자료가 연속적으로 놓여 있지 않아도 저장 가능
* 연결 리스트 연결을 위한 링크(포인터) 부분이 필요
* 연결을 위한 포인터를 찾는 시간이 필요하므로 접근 속도가 느림
* 중간 노드 연결이 끊어지면 그 다음 노드를 찾기가 힘듦

### 스택(Stack)
스택은 리스트의 한쪽 끝으로만 자료의 삽입 및 삭제 작업이 이루어지는 자료 구조
<br>
스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO, Last In First Out) 방식으로 자료를 처리
* 스택의 모든 공간이 가득 찬 상태에서 삽입 시 오버플로(Overflow) 발생
* 더이상 삭제할 데이터가 없는 경우에서 데이터 삭제 시 언더플로(Underflow) 발생

#### 스택의 응용 분야
* 함수 호출의 순서 제어
* 인터럽트의 처리
* 수식 계산 및 수식 표기법
* 컴파일러를 이용한 언어 번역
* 부 프로그램 호출 시 복귀주소 저장
* 서브루틴 호출 및 복귀 주소 저장

#### A, B, C, D로 정해진 입력 자료를 스택에 입력 후 B, C, D, A 순서로 출력하는 과정

![image](https://user-images.githubusercontent.com/87363461/212522358-0c211166-8de2-470c-a714-aec89ca74e78.png)
<br>

### 큐(Queue)
큐는 리스트의 한쪽에서 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지는 자료 구조
* 큐는 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출(FIFO, First In Last Out) 방식으로 처리
* 큐는 시작과 끝을 표시하는 두 개의 포인터가 있음

### 그래프(Graph)
* 방향 그래프
  * 정점을 연결하는 선에 <b>방향이 있는 그래프</b>
  * n개의 정점으로 구성된 <b>방향 그래프의 최대 간선 수 = n(n - 1) </b>
* 무방향 그래프
  * 정점을 연결하는 선에 <b>방향이 없는 그래프</b>
  * n개의 정점을 구성하는 <b>무방향 그래프의 최대 간선 수 = n(n - 1) / 2 </b>
  
### 트리(Tree)
트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태
<br>
 
![image](https://user-images.githubusercontent.com/87363461/212522469-ac385ed2-a6eb-4d34-9e5f-b54c0492b23e.png)
 
<br>
 
* 노드(Node) : 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지를 합친 것
  * Ex) A, B, C, D, E, F, G, H, I, J, K, L, M
* 근 노드(Root Node) : 트리의 맨 위에 있는 노드
  * Ex) A
* 디그리(Degree, 차수) : 각 노드에서 뻗어 나온 가지의 수
  * Ex) A = 3, B = 2, C = 1, D = 3
* 단말 노드(Terminal Node) = 잎 노드(Leaf Node) : 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
  * Ex) K, L, F, G, M, I, J
* 자식 노드(Son Node) : 어떤 노드에 연결된 다음 레벨의 노드들
  * Ex) D늬 자식 노드 : H, I, J
* 부모 노드(Parent Node) : 어떤 노드에 연결된 이전 레벨의 노드들
  * Ex) E, F의 부모 노드 : B
* 형제 노드(Brother Node, Sibling) : 동일한 부모를 갖는 노드들
  * H의 형제 노드 : I, J
* 트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수
  * Ex) 노드 A나 D가 3개의 디그리를 가지므로 잎 트리의 디그리는 3


### 트리의 운행법
* 전위(Preorder) 운행 : Root -> Left -> Right 순서와 같이 뿌리를 먼저 방문
  * A -> B -> C
* 중위(Inorder) 운행 : Left -> Root -> Right 순서와 같이 왼쪽 하위 트리를 먼저 방문
  * B -> A -> C
* 후위(Postorder) 운행 : Left -> Right -> Root 순서와 같이 하위 트리를 모두 방문 후 뿌리 방문
  * B -> C -> A
<br>

![image](https://user-images.githubusercontent.com/87363461/212522612-5460a944-ce3b-40ba-a755-b74494197a23.png)


<br>

### 트리 수식의 표기법
* 전위 표기법(PreFix) : 연산자 -> Left -> Right = +AB
* 중위 표기법(InFix) : Left -> 연산자 -> Right = A+B
* 후위 표기법(PostFix) : Left -> Right -> 연산자 = AB+
<br>

![image](https://user-images.githubusercontent.com/87363461/212522612-5460a944-ce3b-40ba-a755-b74494197a23.png)


<br>

---

## 정렬(Sort)

### 삽입 정렬(Insertion Sort) 
* 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 삽입하는 작업을 반복하는 정렬 알고리즘
* 정렬되지 않은 데이터가 있을 때 정렬되지 않은 첫 번째 요소를 정렬된 부분의 알맞은 위치에 삽입
* 정렬이 많이 이루어진 경우 효율적으로 사용 가능
* 정렬에 안정적이고 단순해서 구현이 쉬우나 시간 복잡도가 비효율적임

#### 삽입 정렬 예제
> 8, 5, 6, 2, 4를 삽입 정렬을 이용해 정렬

1. 초기 상태
<br>

![image](https://user-images.githubusercontent.com/87363461/212522709-ca7b1b84-e5c2-4936-b60a-fa02865d5af1.png)

<br>

2. 두 번째 값과 첫 번째 값을 비교
* 5를 첫 번째 자리에 삽입하고 8을 한 칸 뒤로 이동
<br>

![image](https://user-images.githubusercontent.com/87363461/212522725-48013a5d-ef48-422c-8e7a-df3d33e598a7.png)

<br>

3. 세 번째 값을 첫 번째, 두 번째 값과 비교
* 6을 8자리에 삽입 후 8을 한 칸 뒤로 이동
<br>

![image](https://user-images.githubusercontent.com/87363461/212522739-77b67527-544b-4c92-8278-99e45a5f1097.png)
<br>

4. 네 번째 값을 첫 번째부터 세 번째 까지의 값과 비교
* 2를 처음부터 비교, 가장 작으므로 맨 처음에 삽입하고 나머지를 한 칸씩 뒤로 이동

<br>

![image](https://user-images.githubusercontent.com/87363461/212522762-4964a452-6bac-42fd-975a-bf9cc88fc3dd.png)

<br>

5. 다섯 번째 값을 처음 부터 비교
* 4를 처음 자리부터 비교, 두 번째인 5자리에 삽입하고 나머지를 한 칸씩 뒤로 이동

<br>

![image](https://user-images.githubusercontent.com/87363461/212522775-741edda7-3722-48f9-83d9-9d0359052a68.png)

<br>


### 선택 정렬
* 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 정렬 알고리즘
* 배열의 가장 작은 값을 찾아 맨 처음 요소와 위치를 변경하는 작업을 반복하여 정렬을 수행
* 같은 값이 있을 경우 상대적인 위치가 변경될 수 있어 안전하지 않음
* 배열의 크기를 알고 있기 때문에 이동 횟수를 미리 알 수 있다는 장점이 있음

1. 초기 상태
<br>

![image](https://user-images.githubusercontent.com/87363461/212522840-551ea73a-3c0f-4ed5-a8db-b128a9bc0031.png)

<br>

2. 가장 작은 값을 찾아 첫 번째와 변경
* 가장 작은 값인 2를 찾아 첫 번째 값 5와 변경

<br>

![image](https://user-images.githubusercontent.com/87363461/212522859-2dafc4b8-0b5e-4dd9-a4d8-244fb3d1f5d0.png)

<br>

3. 두 번째로 작은 값을 찾아 두 번째와 변경
* 두 번째로 작은 값은 4이므로 4를 찾아 두 번째 값인 6과 변경

<br>

![image](https://user-images.githubusercontent.com/87363461/212522923-0811ce49-7303-4627-9351-5fac1b2208e6.png)

<br>

4. 세 번째로 작은 값을 찾아 세 번째 값과 변경
* 세 번째로 작은 값은 5이므로 5를 찾아 세번째 값인 6과 변경

<br>

![image](https://user-images.githubusercontent.com/87363461/212522942-7440e7ca-923b-40d0-a636-0f475821beb2.png)

<br>

5. 마지막 값과 4번 째 값을 비교
* 마지막 값인 6이 8보다 작으므로 서로 변경

<br>

![image](https://user-images.githubusercontent.com/87363461/212522952-e7676e3e-8615-4720-bcdc-e5a7a860d055.png)

<br>

### 버블 정렬(Bubble Sort)
* 인접한 두 요소의 대소 관계를 비교하여 반복 교환
* 시간 복잡도가 느리지만, 코드가 단순하여 구현이 쉬워 자주 사용
* 요소의 개수가 n개인 배열에서 n - 1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음 또는 끝으로 이동

1. 초기 상태

<br>

![image](https://user-images.githubusercontent.com/87363461/212523010-5ee89c07-4321-4b15-ba90-2b80e98d8174.png)

<br>

2. 첫 번째 부터 끝까지 값을 비교하여 서로 변경
* 5와 8 비교시 5가 더 작으므로 유지
* 8과 6 비교 시 6이 더 작으므로 변경
* 8과 2 비교 시 2가 더 작으므로 변경
* 8과 4 비교 시 4가 더 작으므로 변경

<br>

![image](https://user-images.githubusercontent.com/87363461/212523200-eda23091-1efe-4f6e-864b-ed317836c35b.png)

<br>

3. 첫 번째 부터 마지막 - 1 값 까지 비교하여 서로 변경
* 5와 6 비교 시 5가 더 작으므로 유지
* 6과 2 비교 시 2가 더 작으므로 변경
* 6과 4 비교 시 4가 더 작으므로 변경

<br>

![image](https://user-images.githubusercontent.com/87363461/212523250-49b21989-9de8-47f6-a905-63da5e9424f2.png)

<br>

4. 첫 번째 부터 마지막 - 2 값 까지 비교하여 서로 변경
* 5와 2 비교 시 2가 더 작으므로 변경
* 5와 4 비교 시 4가 더 작으므로 변경

<br>

![image](https://user-images.githubusercontent.com/87363461/212523282-8725d066-83f2-4bc2-b93e-becf9b9a83e9.png)

<br>

5. 첫 번째 값과 마지막 - 3 값 서로 비교
* 2가 더 작으므로 유지

<br>

![image](https://user-images.githubusercontent.com/87363461/212523302-5b2426c6-2f5c-48ba-a1c6-55c37a05e11f.png)

<br>

### 퀵 정렬(Quick Sort)
퀵 정렬은 특정한 키(기준)을 기준으로 부분적 나누어 가면서 정렬하는 방법
<br>
<b>키를 기준으로 작은 값을 왼쪽에, 큰 값을 오른쪽에 분해시키는 방식</b>으로 정렬
* 분할(Divide)과 정복(Conquery)을 통해 자료를 정렬함
* 평균 수행 시간 복잡도는 O(nLog ^ 2)이고, 최악의 수행 시간 복잡도는 O(n ^ 2)
 
### 힙 정렬(Heap Sort)
힙 정렬은 전이진 트리(Complete Binary Tree)를 이용한 정렬 방식
* 구성된 전이진 트리를 Heap Tree로 변환하여 정렬
* 평균과 최악 모두 시간 복잡도는 O(nlog ^ 2)
 
### 2-Way 합병 정렬(Merge Sort)
2-Way 합병 정렬은 이미 정렬되어 있는 두 개의 리스트를 한 개의 리스트로 합병 정렬하는 방식
* 평균과 최악 모두 시간 복잡도 O(n log ^ 2)
 
---
 
## 탐색(Search)
 
### 이분 탐색(Binary Search)
전체 리스트를 두 개의 리스트로 분리해 가면서 Key를 검색하는 방식
* 이분 탐색은 반드시 정렬된 리스트에서만 검색 가능
* 찾을 키 값을 리스트의 중간 키값과 비교해가면서 탐색
* 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어듦
* 탐색 효율이 좋고 탐색 시간이 적게 소요됨
 
---
 
## 데이터베이스/DBMS(DataBase, DataBase Managerment System) : 데이터베이스 관리 시스템
DBMS란 <b>사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성 및 관리해주는 소프트웨어</b>
<br>
DBMS의 필수 기능으로 정의, 조작, 제어 기능이 있다.
* 정의 기능 : 데이터베이스에 저장될 데이터의 형(Type)과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
* 조작 기능 : 데이터 검색, 갱신, 삽입, 삭제 등 인터페이스 수단을 제공하는 기능
* 제어 기능 : 데이터 검색, 갱신, 삽입, 삭제 등 정확하게 수행되어 데이터의 무결성이 유지되도록 제어
 
### DBMS의 장단점


#### 장점
* 데이터의 논리적, 물리적 독립성이 보장됨
* 데이터의 중복을 피할 수 있어 기억 공간 절약
* 저장된 자료를 공동으로 이용 가능
 * 데이터의 일관성, 무결성, 표준화, 보안 유지, 실시간 처리, 통합 관리 가능
 * 항상 최신의 데이터 유지 가능

#### 단점
* 데이터베이스의 전문가 부족
* 전산화 비용 증가
* 대용량 디스크로 집중적인 Access로 과부화(Overhead)가 발생
* 파일의 예비(Backup)와 회복(Recovery)이 어려움
* 시스템이 복잡함

### 스키마(Schema)
스키마란 <b>데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합</b>이다.
<br>
스키마는 사용자의 관점에 따라 외부 스키마, 내부 스키마, 개념 스키마로 나뉜다.
* 외부 스키마 : 사용자나 프로그래머 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
* 내부 스키마 : 물리적 저장장치에서 본 데이터베이스 구조
  * 실제로 데이터베이스에 저장될 레코드의 형식 정의
  * 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄
* 개념 스키마 : 데이터베이스의 전체적인 논리적 구조로서, 필요로 하는 데이터의 종합
  * 전체 데이터베이스에서 하나만 존재함

### 절차형 SQL의 테스트와 디버깅
절차형 SQL은 디버깅을 통해 적합성 여부를 검증, 실행을 통해 결과를 확인하는 테스트 과정 수행
* 테스트를 통해 오류를 발견 한 후 디버깅을 통해 오류가 발생한 소스 코드를 추적하며 수정

---

## 단위 모듈(Unit Module)
단위 모듈은 <b>소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현</b>한 것
* 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 부름
* 단위 모듈은 사용자나 다른 모듈로부터 값을 전달받아 시작되는 작은 프로그램을 의미
* 두 개의 단위 모듈이 합쳐질 경우 두 개의 기능을 구현할 수 있음
* 단위 모듈의 구성 요소에는 처리문, 명령문, 데이터 구조 등이 있음
* 단위 모듈은 독립적인 컴파일이 가능하며, 다른 모듈에 호출 및 삽입되기도 함
* 단위 모듈을 구현하기 위해서 단위 기능 명세서를 작성한 후 입출력 기능과 알고리즘 구현해야 함

### 단위 모듈 테스트
단위 모듈 <b>테스트는 프로그램의 단위 기능을 구현하는 모듈이 정해진 기능을 정학히 수행</b>하는지 검증하는 것
* 단위 모듈 테스트는 단위 테스트(Unit Test)라고도 함
* 화이트박스 테스트와 블랙박스 테스트 기법을 사용
* 단위 모듈 테스트를 수행하기 위해 모듈을 단독적으로 실행 가능한 환경 및 테스트에 필요한 데이터 준비 필요
* 모듈의 통합 이후 오랜 시간 추적해야 발견할 수 있는 에러들도 단위 모듈로 테스트 시 쉽게 발견 및 수정 가능
* 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 <b>시스템 수준의 오류는 검출 불가</b>

---

## IPC(Inter-Process-Communication)
IPC란 <b>모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스</b> 집합
<br>
복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능

### 대표적인 IPC 메소드 5가지
* Shared Memory : 다수의 프로세스가 공유 가능한 메모리를 구성하여 프로세스 간 통신을 수행
* Socket : 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스들 간 통신을 수행
* Semaphores : 공유 자원에 대한 접근 제어를 통해 프로세스 간 통신을 수행
* Pipes&named Pipes
  * 'Pipe'라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신 수행
  * 하나의 프로세스가 Pipe를 이용 중이라면 다른 프로세스는 접근 불가
* Message Queue : 메시지가 발생하면 이를 전달하는 형태로 프로세스 간 통신 수행


---


## 개발 지원 도구

### 통합 개발환경(IDE, Intergrated Development Environment)
IDE란 <b>코딩, 디버그, 컴파일, 배포 등 프로그램 개발과 관련된 모든 작업을 하나의 소프트웨어에서 처리할 수 있도록 제공하는 소프트웨어적인 개발 환경</b>을 말한다.
* 통합 개발 환경을 제공하는 소프트웨어를 의미
* 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger) 등 다양한 툴을 하나의 인터페이스로 통합하여 제공
* IDE를 지원하는 도구는 플랫폼, 운영체데, 언어별 다양하게 존재

#### 통합 개발 환경 도구의 대표적인 기능
* 코딩(Coding) : C, JAVA 등 프로그래밍 언어로 프로그램 작성 가능
* 컴파일(Compile) : 고급 언어로 된 프로그램을 컴퓨터가 이해하도록 목적 프로그램으로 번역, 컴퓨터에서 실행 가능 형태로 변환하는 기능
* 디버깅(Debugging) : 소프트웨어나 하드웨어의 오류나 잘못된 동작, 즉 버그를 찾아 수정하는 기능
* 배포(Deployment) : 소프트웨어를 사용자에게 전달하는 기능


### 빌드 도구
빌드는 소스 코드 파일들을 <b>컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물</b>을 말한다.

* 빌드 도구는 소스 코드를 소프트웨어로 변환하는 과정에 필요한 작업들을 수행하는 소프트웨어를 말함
* 대표적인 변환 작업으로 전처리(Preprocessing), 컴파일(Compile) 등이 있음

#### 대표적인 빌드 도구
* Ant : 아파치 소프트웨어 재단에서 개발한 소프트웨어로, 자바 프로젝트의 공식 빌드 도구로 사용 중
* Maven : Ant와 동일한 재단에서 개발한 소프트웨어로, Ant의 대안으로 개발되었음
* Gradle : 기존 Ant, Maven을 보완하여 개발된 빌드 도구로, 한스 도커 외 6인의 개발자가 모여 공동 개발

---

## 소프트웨어 패키징(Software Packaging)
소프트웨어 패키징이란 <b>모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것</b>을 말한다.
* 개발자가 아니라 사용자 중심으로 진행
* 소스 코드는 향후 관리를 고려, 모듈화하여 패키징 함
* 사용자가 소프트웨어를 사용하게 될 환경을 이해하여 다양한 환경에서 사용할 수 있도록 일반적인 배포 형태로 패키징

### 소프트웨어 패키징 시 고려사항
* 사용자의 운영체제(OS), CPU, 메모리 등에 필요한 최소 환경 정의 필요
* UI는 사용자가 직접 확인할 수 있도록 시각적인 자료와 함께 제공, 매뉴얼과 일치시켜 패키징
* 단순히 패키징 및 배포가 끝이 아닌, 하드웨어와 함께 관리될 수 있도록 Managed Service 형태로 제공
* 사용자에게 배포되는 소프트웨어이므로 내부 콘텐츠에 대한 암호화 및 보안 고려
* 다른 여러 콘텐츠 및 단말기 간 DRM(디지털 저작권 관리) 연동 고려
* 사용자의 편의성을 위한 복잡성 및 비효율성 문제를 고려
* 제품 소프트웨어 종류에 적합한 암호화 알고리즘 적용


---


## 릴리즈 노트(Release Note)
릴리즈 노트는 <b>개발 과정에서 정리된 릴리즈 정보를 소프트웨어 최종 사용자인 고객과 공유하기 위한 문서</b>를 말한다.
* 릴리즈 노트를 통해 테스트 진행 방법에 대한 결과와 소프트웨어 사양에 대한 개발팀의 정확한 준수 여부 확인 가능
* 소프트웨어에 포함된 전체 기능, 서비스의 내용, 개선 사항 등을 사용자와 공유
* 릴리즈 노트를 이용해 소프트웨어의 버전 관리나 릴리즈 정보를 체계적으로 관리 가능
* 릴리즈 노트는 소프트웨어의 초기 배포 시 또는 출시 후 개선 사항을 적용한 추가 배포 시 제공

### 릴리즈 노트 초기 버전 작성 시 고려 사항
* 릴리즈 노트는 정확하고 완전한 정보를 기반으로 개발 팀에서 직접 현재 시제로 작성해야 함
* 신규 소스, 빌드 등의 이력이 정확하게 관리되어 변경 또는 개선된 항목에 대한 이력 정보들로 작성

#### 릴리즈 노트 표준 형식
릴리즈 노트의 표준 형식은 없지만, 일반적으로 다음과 같은 항목이 포함됨
* Header(머릿말)
* 개요
* 목적
* 문제 요약
* 재현 항목
* 수정/개선 내용
* 사용자 영향도
* SW 지원 영향도
* 노트
* 면책 조항
* 연락처

---

## 디지털 저작권 관리(DRM, Digital Right Management)
디지털 저작권 관리란 <b>저작권자가 배포한 디지털 콘텐츠가 저작권자의 의도한 용도로만 사용되도록 하는 것으로</b>, 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술이다.
* 원본 콘텐츠가 아날로그일 경우 디지털로 변환 후 패키저에 의해 DRM 패키징 수행
* 콘텐츠의 크기에 따라 음원이나 문서와 같이 크기가 작은 경우 사용자 콘텐츠 요청하는 시점에서 실시간으로 패키징 수행
* 크기가 큰 경우 미리 패키징을 수정한 후 배포
* 패키징을 수행하면 콘텐츠에는 암호화된 저작권자의 전자서명이 포함됨
* 저작권자가 설정한 라이선스 정보가 클리어링 하우스(Clearing House)에 등록됨
* 사용자가 콘텐츠를 사용하기 위해 라이선스, 사용 권한 소유 여부 확인 필요
* 종량제 방식을 적용한 소프트웨어의 경우 클리어링 하우스를 통해 서비스의 실제 사용량을 측정하여 이용한 만큼의 요금 부과

### 디지털 저작권 관리(DRM)의 구성 요소
* 클리어링 하우스(Clearing House) : 저작권에 대한 사용 권한, 라이선스 발급, 암호화된 키 관리, 사용량에 따른 결제 관리 등을 수행하는 곳
* 콘텐츠 제공자(Contents Provider) : 콘텐츠를 제공하는 저작권자
* 콘텐츠 분배자(Contents Distributor) : 암호화된 콘텐츠를 유통하는 곳이나 사람
* 패키저(Packager) : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
* 콘텐츠 소비자(Customer) : 콘텐츠를 구매해서 사용하는 주체
* DRM 컨트롤러(Controller) : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램
* 보안 컨테이너(Seuirty Container) : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치

### 디지털 저작권 관리(DRM)의 기술 요소
* 암호화(Encryption) : 콘텐츠 및 라이선스를 암호화하고 전자 서명할 수 있는 기술
* 키 관리(Key Management) : 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술
* 암호화 파일 생성(Packager) : 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
* 식별 기술(Identification) : 콘텐츠에 대한 식별 체계 표현 기술
* 저작권 표현(Right Expression) : 라이선스의 내용 표현 기술
* 정책 관리(Policy Management) : 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
* 크랙 방지(Tamper Resistance) : 크랙에 의한 콘텐츠 사용 방지 기술
* 인증(Authentication) : 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술

---

## 소프트웨어 매뉴얼(Software Manual)
개발 초기에서부터 <b>적용된 기준, 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서 또는 안내서</b>를 말한다.
* 설치 매뉴얼은 사용자 기준으로 작성
* 설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명
* 설치 과정에서 표시될 수 있느 농류 메시지 및 예외 상황에 관한 내용을 별도 분류하여 설명
* 설치 매뉴얼에는 목차 및 개요, 서문, 기본 사항 등이 기본적으로 포함되어야 함
* 기능 식별 -> UI 분류 -> 설치 파일/백업 파일 확인 -> Uninstall 절차 확인 -> 이상 Case 확인 -> 최종 매뉴얼 적용

### 소프트웨어 설치 매뉴얼의 기본 사항
* 소프트웨어 개요
  * 소프트웨어 주요 기능 및 UI 설명
  * UI 및 화면 상의 버튼, 프레임 등을 그림으로 설명
* 설치 관련 파일
  * 소프트웨어 설치에 필요한 파일 설명
  * exe, ini, log 등의 파일 설명
* 설치 관련 아이콘(Installation)
  * 설치 아이콘 설명
* 프로그램 삭제
  * 설치된 소프트웨어의 삭제 방법 설명
* 관련 추가 정보
  * 소프트웨어 이외의 관련 설치 프로그램 정보
  * 소프트웨어 자젝사 등의 추가 정보 기술


### 소프트웨어 사용자 매뉴얼의 개요
소프트웨어 사용자 매뉴얼은 사용자가 소프트웨어를 사용하는 과정에 필요한 내용을 문서로 기록한 설명서 또는 안내서이다.
* 사용자 매뉴얼은 사용자가 소프트웨어 사용에 필요한 절차, 환경 등의 제반 사항이 모두 포함되도록 작성
* 소프트웨어 배포 후 발생될 수 있는 오류에 대한 패치나 기능에 대한 업그레이드를 위해 매뉴얼의 버전 관리
* 개별적으로 동작이 가능한 컴포넌트 단위로 매뉴얼 작성
* 사용자 매뉴얼은 컴포넌트 명세서와 컴퓨넌트 구현 설계서를 토대로 작성
* 사용자 매뉴얼에는 목차 및 개요, 서문, 본문, 기본 사항 등이 기본적으로 포함되어야 함
* 작성 지침 정의 -> 사용자 매뉴얼 구성 요소 정의 -> 구성 요소별 내용 작성 -> 사용자 매뉴얼 검토

---

## 형상 관리(SCM, Software Configuration Management)
형상 관리는 <b>소프트웨어 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동</b>을 말한다.
* 소프트웨어 변경의 원인을 알아내고 제어하며 적절히 변경되고 있는지 확인, 해당 담당자에게 통보
* 형상 관리는 소프트웨어 개발의 전 단계에 적용되는 활동이며 유지보수 단계에서도 수행
* 소프트웨어 개발의 전체 비용을 줄임
* 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것이 목적임
* 관리 항목에는 소스 코드, 각종 정의서, 지침서, 분석서 등이 포함됨
* 형상 관리를 통해 가시성과 추적성을 보장함으로써 소프트웨어의 생산성과 품질을 향상
* 대표적인 형상 관리 도구로 Git, CVS, Subversion이 있음

### 형상 관리의 중요성
* 지속적인 소프트웨어의 변경 사항을 체계적으로 추적, 통제 가능
* 제품 소프트웨어에 대한 무절제한 변경 방지 가능
* 제품 소프트웨어에서 발견된 버그나 수정 사항 추적 가능
* 소프트웨어는 형태가 없이 가시성이 결핍되므로 진행 정도를 확인하기 위한 기준으로도 사용 가능
* 소프트웨어의 배포본을 효율적으로 관리할 수 있음
* 소프트웨어를 여러 명의 개발자가 동시에 개발할 수 있음

### 형상 관리 기능
* 형상 식별 : 형상 관리 대상에 이름 및 관리 번호 부여, 계층 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업
* 버전 제어 : 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목 관리
  * 특정 절차와 도구(Tool)를 결합시키는 작업
* 형상 통제(변경 관리) : 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선이 잘 반영될 수 있도록 조정하는 작업
* 형상 감사 : 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업
* 형상 기록(상태 보고) : 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업

---

## 소프트웨어 버전 관리

### 소프트웨어의 버전 등록 관련 주요 기능
* 저장소(Repository) : 최신 버전의 파일 및 변경 내역에 대한 정보들이 저장되어 있는 곳
* 가져오기(Import) : 빈 저장소(Repository)에 처음으로 파일을 복사(가져오기)함
* 체크아웃(Checkout) : 프로그램을 수정하기 위해 저장소에서 파일을 받아며 파일과 함께 버전 관리를위한 파일들도 받아옴
* 체크인(Checkin) : 체크아웃 한 파일의 수정을 완료 후 저장소의 파일을 새로운 버전으로 갱신
* 커밋(Commit) : 체크인 수행 시 이전 갱싱된 내용이 있는 경우 충돌을 알리고 diff 도구를 이용해 수정한 후 갱신 완료함
* 동기화(Update) : 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화

### 공유 폴더 방식
공유 폴더 방식은 <b>버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장되어 관리</b>되는 방식
* 개발자들은 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사
* 담당자는 공유 폴더의 파일을 자기 PC로 복사 후 컴파일 하여 이상 유무 확인
* SCCS, RCS, PVCS, QVCS 등이 있음

### 클라이언트/서버(Client/Server) 방식
클라이언트/서버 방식은 <b>버전 관리 자료가 중앙 시스템(서버)에 저장되어 관리</b>되는 방식
* 서버의 자료를 개발자별로 자신의 PC(클라이언트)로 복사하여 작헙한 후 변경된 내용을 서버에 반영
* 모든 버전 관리는 서버에서 수행
* CVS, SVN(Subversion), CVSNT, Clear Case, CMVC, Perfoce 등이 있음

### 분산 저장소 방식
분산 저장소 방식은 버전 관리 자료가 <b>하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장</b>되어 관리되는 방식
* 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사하여 작업
* 변경된 내용을 로컬 저장소에서 우선 반영(버전 관리)한 다음 이를 원격 저장소에 반영
* 로컬 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업 가능
* GIT, GNU arch, DCVS, Bazaar, Mercurial, TeamWare, Bitkeeper, Plastic SCM 등이 있음

### Subversion(SVN)
SVN은 CVS를 개선한 것으로, 아파치 소프트웨어 재단에서 2000년에 발표함
* 클라이언트/서버 구조로, 서버(저장소, Repository)는 최신 버전의 파일들과 변경 내역이 관리됨
* 서버의 자료를 클라이언트로 복사해와 작업한 후 변경 내용을 서버에 반영(Commit)
* 모든 개발 작업은 trunk 디렉터리에서 수행되며, 추가 작업은 branches 디렉터리 안에 별도의 디렉터리를 만들어 작업 후 trunk 디렉터리와 병합(Merge)
* 커밋(Commit)할 때마다 리비전(Revision)이 1씩 증가
* 클라이언트는 대부분의 운영체제에서 사용되지만 <b>서버는 주로 유닉스 사용</b>
* 소스가 포은되어 있어 무료로 사용 가능
* CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능함

### 깃(Git)
깃은 리누스 토발즈가 2005년에 리눅스 커널 개발에 사용할 관리 도구로 개발되었음
<br>
개발 후 주니오 하마노에 의해 유지보수 되고 있음
* Git은 <b>분산 버전 관리 시스템으로 2개의 저장소(로컬 저장소, 원격 저장소)가 존재</b>
* 지역 저장소는 개발자들이 실제 개발을 진행하는 장소로, 버전 관리가 수행됨
* 원격 저장소는 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳
* 자신의 버전 관리 내역을 반영 또는 다른 개발자의 변경 내용을 가져올 때 사용
* 버전 관리가 로컬 저장소에서 되므로 버전 관리가 신속하게 처리됨
* 로컬 저장소에서 버전 관리가 되므로 <b>원격 저장소나 네트워크에 문제가 있어도 작업이 가능</b>
* 브랜치를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 테스팅 가능
* 파일의 변화를 스냅샷(Snapshot)으로 저장함
* 스냅샷은 이전 스냅샷의 포인터를 가지므로 버전의 흐름을 파악할 수 있음

---

## 빌드 자동화 도구
빌드란 소스 코드 파일들을 컴파일한 후 여러 개의 모듈을 묶어 실행 파일로 만드는 과정을 말한다.
<br>
이러한 <b>빌드를 포함하여 테스트 및 배포를 자동화하는 도구를 빌드 자동화도구</b>라고 한다.
* 애자일 환경에서는 하나의 작업이 마무리 될 때마다 모듈 단위로 나눠서 개발된 코드들이 지속적으로 통합되는데, 이러한 지속적인 통합(Continuous Intergration) 개발 환경에서 빌드 자동화 도구는 유용하게 활용됨
* Ant, Make, Maven, Gradle, Jenkins 등이 있으며 Jenkins와 Gradle이 가장 대표적임

### Jenkins
Jenkins는 JAVA 기반의 오픈 소스 형태로, 가장 많이 사용되는 빌드 자동화 도구임
* 서블린 컨테이너에서 실행되는 서버 기반 도구임
* SVN, Git 등 대부분의 형상 관리 도구와 연동 가능
* 친숙한 Web GUI 제공으로 사용이 쉬움
* 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트 가능

### Gradle
Gradle은 Groovy를 기반으로 한 오픈 소스 형태의 자동화 도구로, 안드로이드 앱 개발 환경에서 사용됨
* 플러그인 설정 시 안드로이드 뿐만 아니라 C/C++, JAVA, Python 등의 언어도 빌드 가능
* Groovy를 사용해서 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용
* Gradle은 실행할 처리 명령들을 모아 태스크(Task)로 만든 후 태스크 단위로 실행
* 이전에 사용했던 태스크를 재사용하거나 다른 시스템의 태스크를 공유할 수 있는 빌드 캐시 기능을 지원하므로 빌드의 속도를 향상 시킬 수 있음

---

## 애플리케이션 테스트(Application Test)
애플리케이션 테스트는 <b>애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차</b>
<br>
개발된 소프트웨어가 고객의 요구사항을 만족시키는지 확인, 기능을 정확히 수행하는지 검증한다.
* 확인(Validation) : 사용자의 입장에서 개발한 소프트웨어가 고객의 요구사항에 맞게 구현되었는지 확인
* 검증(Verification) : 개발자의 입장에서 개발한 소프트웨어가 명세서에 맞게 만들어졌는지 점검

### 애플리케이션 테스트 관련 용어
* 결함 집중(Defect Clustering) : 대부분의 결함이 소수의 특정 모듈에 집중해서 발생하는 것
* 파레토 법칙(Pareto Principle) : 오류가 발생할 확률이 있는 모듈을 집중적으로 테스트하여 효율적으로 오류를 찾는 것
* 살충제 패러독스(Pesticide Paradox) : 살충제를 지속적으로 뿌리면 벌레가 내성이 생겨서 죽지 않는 현상
* 오류-부재의 궤변(Absence Of Error Fallacy) : 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 품질이 높다고 할 수 없는 것

### 프로그램 실행 여부에 따른 테스트

#### 정적 테스트
* 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트
* 소프트웨어 개발 초기에 결함도를 발견할 수 있어 소프트웨어 개발 비용을 낮추는데 도움이 됨
* 종류 : 워크스루, 인스펙션, 코드 검사 등

#### 동적 테스트
* 프로그램을 실행하여 오류를 찾는 테스트
* 소프트웨어 개발의 모든 단계에서 테스트를 수행할 수 있음
* 종류 : 블랙박스 테스트, 화이트박스 

---

## 애플리케이션 테스트 분류

### 테스트 기반(Test Bases) 테스트
* 명세 기반 테스트
  * 사용자의 요구사항에 대한 명세를 전부 케이스로 만들어 구현하고 있는지 확인하는 테스트
  * 동등 분할, 경계 값 분석 등
* 구조 기반 테스트
  * 소프트웨어 내부 논리 흐름에 따라 테스트 케이스를 작성하고 있는지 확인하는 테스트
  * 구문 기반, 결정 기반, 조건 기반 등
* 경험 기반 테스트
  * 유사 소프트웨어 또는 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트
  * 사용자의 <b>요구사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 수행하면 효과</b>적
  * 에러 추정, 체크 리스트, 탐색적 테스팅
  
### 시각에 따른 테스트
* 검증(Verification) 테스트
  * <b>개발자의 시각에서</b> 제품의 생산 과정을 테스트하는 것
  * 제품이 명세서대로 완성됐는지 테스트
* 확인(Validation) 테스트
  * <b>사용자의 시각에서</b> 생상된 제품의 결과를 테스트하는 것
  * 사용자가 요구한대로 제품이 완성 됐는지 테스트
  * 제품이 정상적으로 동작하는지 테스트
  
### 목적에 따른 테스트
* 회복(Recovery) 테스트
  * <b>시스템에 여러 가지 결함을 주어</b> 실패하도록 한 후 올바르게 복구되는지 확인하는 테스트
* 안전(Security) 테스트
  * 시스템에 설치된 <b>시스템 보호 도구</b>가 정상적으로 시스템을 보호하는지 확인하는 테스트
* 강도(Stress) 테스트
  * 시스템에 <b>과도한 정보량, 빈도 등을 부과</b>하여 과부하 시 소프트웨어가 정상 실행하는지 테스트
* 성능(Performance) 테스트
  * 소프트웨어의 <b>실시간 성능 또는 전체적인 효율성 진단</b> 테스트
  * 소프트웨어의 응답 시간, 처리량 테스트
* 구조(Structure) 테스트
  * 소프트웨어 <b>내부 논리적인 경로, 소스 코드의 복잡도</b> 등을 평가하는 테스트
* 회귀(Regression) 테스트
  * 소프트웨어의 <b>변경 또는 수정된 코드에 새로운 결함이 없음</b>을 확인하는 테스트
* 병행(Parallel) 테스트
  * 변경된 소프트웨어와 기존 소프트웨어의 <b>동일한 데이터를 입력하교 결과를 비교</b>하는 테스트
  
---

## 화이트 박스(White Box)와 블랙 박스(Black Box) 테스트

### 화이트 박스
<b>모듈의 원시 코드를 오픈시킨 상태에서 코드의 논리적인 모든 경로를 테스트</b>하여 테스트 케이스르 설계하는 방법을 말한다.
* 모듈 안의 작동을 직접 관찰
* 원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로써 수행
* 프로그램의 제어 구조에 따라 선택, 반복 등의 분기점 부분들을 수행, 논리적 경로를 제어

### 화이트 박스 테스트 종류
* 기초 경로 검사(Base Path Testing)
  * <b>대표적인 화이트 박스 테스트 기법</b>
  * 테스트 케이스 설계자가 <b>절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법</b>
  * 테스트 측정 결과는 실행 경로의 기초를 정의하는 데 지침으로 사용
* 제어 구조 검사(Control Structure Testing)
  * 조건(Condition) 검사 : 프로그램 모듈 내에 있는 논리적 조건을 테스트하는 테스트 케이스 설계 기법
  * 루프(Loop) 검사 : 프로그램의 반복 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법
  * 데이터 흐름(Data Flow) 검사 : 프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법

### 화이트 박스 테스트 검증 기준
* 문장 검증 기준(Statement Coverage)
  * 소스 코드의 <b>모든 구문이 한 번 이상 수행</b>되도록 테스트 케이스 설계
* 분기(Branch) 검증 기준
  * 결정(Decision) 검증 기준이라고도 불림
  * 소스 코드의 모든 조건문에 대해 조건이 <b>true, false인 경우가 한 번 이상 수행</b>되도록 테스트 케이스 설계
* 조건(Condition) 검증 기준
  * 소스 코드의 조건문에 <b>포함된 개별 조건식의 결과가 true, false인 경우가 한 번 이상 수행</b>되도록 테스트 케이스 설계
* 분기/조건(Branch/Condition) 기준
  * <b>분기 검증 기준과 조건 검증 기준을 모두 만족</b>하는 설계
  * 조건문이 <b>true, faslse 각각 경우에 따라 조건 검증 기준의 입력 데이터를 구분</b>하는 테스트 케이스 설계

### 블랙 박스
소프트웨어가 <b>수행할 특정 기능을 알기 위해 각 기능이 완전히 동작되는 것을 입증</b>하는 테스트
* 기능 테스트라고도 함
* 프로그램의 구조를 고려하지 않기 때문에 테스트 케이스는 <b>프로그램 또는 모듈의 요구나 명세를 기초</b>로 결정
* 소프트웨어 인터페이스에서 실시되는 테스트
* 부정확, 누락된 기능, 인터페이스 오류, 자료 구조 또는 외부 데이터베이스 접근 오류 등을 발견하기 위해 사용
* <b>테스트 과정의 후반부에 적용</b>

### 블랙 박스 테스트의 종류
* 동치 분할(Equivalance Partitioning)
  * 동등 분할 기법이라고도 함
  * 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 방법
  * 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정함
  * <b>입력 자료에 맞는 결과가 출력되는지 확인하는 기법</b>

* 경계값 분석(Boundary Value Analysis)
  * <b>입력 자료에만 치중한 동치 분할 기법을 보완</b>하기 위한 기법
  * <b>입력 조건의 중간값 보다 경계값에서 오류가 발생될 확률이 높다는 점</b>을 이용
  * <b>입력 조건의 경계값을 테스트 케이스로 선정하여 검사</b>하는 기법

* 원인-효과 그래프 검사(Cause-Effect Graphing Testing)
  * 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석
  * <b>효용성이 높은 테스트 케이스를 선정하여 검사</b>하는 기법

* 오류 예측(Error Guessing) 검사
  * 데이터 확인 검사라고도 함
  * <b>과거의 경험이나 확인자의 감각으로 테스트</b>하는 기법
  * <b>다른 블랙 박스 테스트 기법으로는 찾아낼 수 없는</b> 오류를 찾아내는 일련의 <b>보충적 검사 기법</b>

* 비교 검사(Comparison Testing)
 * 여러 버전의 프로그램에 동일한 테스트 자료 제공 후 동일한 결과 출력 여부 확인하는 테스트 기법

---

## 개발 단계예 따른 애플리케이션 테스트 방법
* 애플리케이션 테스트는 소프트웨어 개발 단계에 따라 분류되는데, 이렇게 분류된 것을 <b>테스트 레벨</b>이라고 한다.
* 애플리케이션 테스트와 소프트웨어 개발 단계를 연결하여 표현한 것을 V-모델 이라고 함
<br>

![image](https://user-images.githubusercontent.com/87363461/213422413-07d5ab94-050d-48cc-9a13-bd171ac9cf2a.png)

<br>

### 소프트웨어 개발 단계
* 단위 테스트(Unit Test)
* 통합 테스트(Intergration Test)
* 시스템 테스트(System Test)
* 인수 테스트(Acceptance Test)
  * 하향식 통합 테스트(Top Down Intergration Test)
  * 상향식 통합 테스트(Bottom Up Intergration Test)

### 단위 테스트(Unit Test)
단위 테스트는 <b>코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트</b>하는 것
* 인터페이스, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사
* <b>사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선</b>으로 수행
* 구조 기반 테스트와 명세 기반 테스트로 나뉘지만, <b>구조 기반 테스트를 시행</b>
* 발견 가능한 오류 : 알고리즘 오류에 따른 결과, 무한루프 사용, 틀린 계산 수식에 의해 잘못된 결과


### 통합 테스트(Intergration Test)
통합 테스트는 <b>단위 테스트가 완료된 모듈을 결합하여 하나의 시스템으로 완성</b>시키는 과정에서의 테스트
* 비점진적 통합방식
  * 빅뱅 통합 테스트방식 이라고도 함
  * 단계적으로 통합하는 절차 없이 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트하는 방법
  * <b>규모가 작은 소프트웨어에 유리함</b>(단시간 내에 테스트 가능)
  * 전체 프로그램이 대상이기 때문에 <b>오류 발견 및 장애 위치 파악, 수정이 어려움</b>

* 점진적 통합 방식
 * 하향식, 상향식, 혼합식 통합 방식이 있음
  * 모듈 단위로 단계적으로 통합하면서 테스트 하는 방법
  * <b.오류 수정이 용이</b>하며 <b>인터페이스와 연관된 오류를 완전히 테스트할 가능성이 높음</b>

### 시스템 테스트(System Test)
시스템 테스트는 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트
* 환경적인 장애 리스크를 최소화하기 위해 실제 사용 환경과 유사한 환경에서 테스트 필요
* 기능적 요구사항과 비기능적 요구사항으로 구분하여 각각 만족하는지 테스트

### 인수 테스트
인수 테스트는 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 방법
* 개발한 소프트웨어를 <b>사용자가 직접 테스트</b>
* 인수 테스트에 문제가 없으면 사용자는 소프트웨어를 인수, 프로젝트 종료

#### 인수 테스트 종류
* 알파 테스트
  * 개발자의 장소에서 <b>사용자가 개발자 앞에서 행하는 테스트</b> 기법
  * 테스트는 통제된 환경에서 행해짐
  * 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록
* 베타 테스트
  * 필드 테스팅(Field Testing)이라고도 함
  * 선정된 <b>최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트</b> 기법
  * 실업무를 가지고 사용자가 직접 테스트하는 것
  * 개발자에 의해 제어되지 않은 상태에서 테스트가 행해짐
  * 발견된 오류와 사용상의 문제점을 기록하고 개발자에게 주기적으로 보고
  
### 하향식 통합 테스트(Top Down Intergration Test)
하향식 통합 테스트는 <b>프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하면서</b> 테스트하는 기법
* 주요 제어 모듈을 기준으로 하여 아래 단계로 이동하면서 통합
* 깊이 우선 통합법 또는 넓이 우선 통합법 사용
* 테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음
* 상위 모듈에서 테스트 케이스를 사용하기 어려움

### 상향식 통합 테스트(Bottom Up Intergration Test)
상향식 통합 테스트는 <b>프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서</b> 테스트하는 기법
* 하나의 주요 제어 모듈과 관련된 종속 모듈 그룹인 클러스터(Cluster)가 필요함
* 스텁(Stub)이 필요하지는 않음

### 회귀 테스팅(Regression Testing)
회귀 테스트는 이미 테스트된 프로그램의 테스팅을 반복하는 것
* <b>통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류</b>가 있는지 확인하는 테스트
* 수정한 모듈이나 컴포넌트가 다른 부분에 영향을 미치는지 확인
* 오류가 생기지 않았는지 테스트하여 <b>새로운 오류가 발생하지 않음을 보증하기 위해 반복</b> 테스트
* 기존 테스트 케이스 중 변경된 부분을 테스트할 수 있는 테스트 케이스만을 선정하여 수행

---

## 애플리케이션 테스트 프로세스(Application Test Process)
애플리케이션 테스트 프로세스는 <b>개발된 소프트웨어가 사용자의 요구대로 만들어 졌는지, 결함은 없는지 등을 확인</b>하는 테스트 절차

### 애플리케이션 테스트 프로세스 순서
* 테스트 계획
  * 프로젝트 계획서, 요구 명세서 등을 기반으로 테스트
  * 목표를 정의하고 테스트 대상 및 범위 결정
* 테스트 분석 및 디자인
  * 테스트의 목적과 원칙을 검토하고 사용자의 요구 사항 분석
* 테스트 케이스 및 시나리오 작성
  * 테스트 케이스의 설계 기법에 따라 테스트 케이스 작성, 검토 및 확인 후 테스트 시나리오 작성
* 테스트 수행
  * 테스트 환경을 구축한 후 테스트 수행
  * 테스트의 실행 결과를 측정 및 기록
* 테스트 결과 평가 및 리포팅
  * 테스트 결과를 비교 분석하여 테스트 결과서 작성
결함 추적 및 관리
  * 테스트 수행 후 결함이 어디서 발생했는지, 어떤 종류의 결함인지 등 결함을 추적 관리
  
### 테스트 케이스(Test Case)
테스트 케이스는 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지 확인하기 위해 설계된 케이스
* 테스트 케이스를 미리 설계하면 테스트 오류를 방지할 수 있고 테스트 수행에 필요한 인력, 시간 낭비 등을 줄일 수 있음
* 테스트 목표와 방벙블 설정한 후 작성
* 시스템 설계 단게에서 작성하는 것이 가장 이상적

### 테스트 시나리오(Test Scenario)
테스트 시나리오는 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스를 묶은 집합
* 테스트 케이스들을 적용하는 구체적인 절차를 명세한 문서
* 테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정되어 있음

### 테스트 오라클(Test Oracle)
테스트 오라클은 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법 및 활동
* 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인

#### 테스트 오라클의 종류
* 참(True) 오라클
* 샘플링(Sampling) 오라클
* 추정(Heuristic) 오라클
* 일관성 검사(Consistent) 

### 테스트 자동화 도구
테스트 자동화란 사람이 반복적으로 수행하던 테스트 절차를 스크립트 형태로 구현, 자동화 도구를 적용하여 테스트 하는 것

#### 테스트 자동화 도구 유형
* 정적 분석 도구(Static Analysis Tools)
* 테스트 케이스 생성 도구(Test Case Generation Tools)
* 테스트 실행 도구(Test Execution Tools)
* 성능 테스트 도구(Performance Test Tools)
* 테스트 통제 도구(Test Control Tools)
* 테스트 하네스 도구(Test Harness Tools)

### 테스트 하네스의 구성 요소
* 테스트 드라이버(Test Driver)
  * 테스트 대상의 하위 모듈을 호출, 매개변수를 전달, 모듈 테스트 수행 후 결과를 도출하는 도구
* 테슽 스텁(Test Stub)
  * 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구
  * 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈
* 테스트 슈트(Test Suites)
  * 테스트 대상 컴포넌트 모듈, 시스템에 사용되는 테스트 케이스의 집합
* 테스트 케이스(Test Case)
  * 사용자의 요구사항을 정확하게 준수했는지 학인하기 위한 입력 값, 실행 조건, 기대 결과 등으로 만들어진 테스트 항목 명세서
* 테스트 스크립트(Test Script)
  * 자동화된 테스트 실행 절차에 대한 명세서
* 목 오브젝트(Mock Object)
  * 사전에 사용자의 행위를 조건부로 입력 시 그 상황에 맞는 예정된 행위를 수행하는 객체


### 애플리케이션 성능 분석
애플리케이션 성능이란 <b>사용자가 요구한 기능을 최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리</b>하는 정도

#### 애플리케이션 성능 측정 지표
* 처리량(Throughput) : 일정 시간 내에 애플리케이션이 처리하는 일과 양
* 응답 시간(Response Time) : 애플리케이션 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간
* 경과 시간(Turn Around Time) : 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
* 자원 사용률(Resource Usage) : 애플리케이션이 의뢰한 작업을 처리하는 동안의 자원 사용률


---

## 빅오 표기법(Big-O Notation)
빅오 표기법은 <b>알고리즘의 실행시간이 최악일 때를 표기하는 방법</b>

### 일반적인 알고리즘에 대한 최악의 시간 복잡도를 표현하는 빅오 표기법
* O(1) : 입력값(n)에 관계 없이 일정하게 문제 해결에 <b>하나의 단계</b>만을 거침
  * Ex) 스택의 삽입(Push), 삭제(Pop)
* O(log ^ 2n) : 문제 해결에 필요한 단계가 <b>입력값(n) 또는 조건</b>에 의해 감소
  * Ex) 이진 트리(Binary Tree), 이진 검색(Binary Search)
* O(n) : 문제 해결에 필요한 단계가 <b>입력값(n)과 1:1의 관계</b>를 가짐
  * for문
* O(nlog ^ 2n) : 문제 해결에 <b>필요한 단계가 n(log ^ 2n)번만큼 수행</b>
  * Ex) 힙 정렬(Heap Sort), 2-Way 합병 정렬(Merge Sort)
* O(n ^ 2) : 문제 해결에 필요한 단계가 <b>입력값(n)의 제곱만큼 수행</b>
  * Ex) 삽입 정렬(Insertion Sort), 쉘 정렬(Shell Sort), 선택 정렬(Selection Sort), 버블 정렬(Bubble Sort), 퀵 정렬(Quick Sort) 등
* O(2 ^ n) : 문제 해결에 필요한 단게가 2의 입력값(n) 제곱만큼 수행
  * Ex) 피보나치 수열(Fibonacci Sequence)
  
---

## 소스 코드(Source Code)

### 소스 코드 최적화
소스 코드 최적화는 <b>나쁜 코드(Base Code)를 배제하고, 클린 코드(Clean Code)로 작성하는 것</b>
* 클린 코드
  * 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순, 명료한 코드 (잘 작성된 코드)
* 나쁜 코드
  * 프로그램의 로직이 복잡하고 이해하기 어려운 코드 (잘못 작성된 코드)
  * 스파게티 코드 : 코드의 로직이 서로 복잡하게 얽혀 있는 코드
  * 외계인 코드 : 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 코드
  
#### 클린 코드 작성 원칙
* 가독성
  * 누구든지 코드를 쉽게 읽을 수 있도록 작성
  * 코드 작성 시 이해하기 쉬운 용어를 사용하거나 들여쓰기 기능 등을 사용
* 단순성
  * 코드를 간단하게 작성
  * 한 번에 한 가지를 처리하도록 코드 작성
  * 클래스/메소드/함수 등을 최소 단위로 분리
* 의존성 배제
  * 코드가 다른 모듈에 미치는 영향 최소화
  * 코드 변경 시 다른 부분에 영향이 없도록 작성
* 중복성 최소화
  * 코드의 중복 최소화
  * 중복된 코드는 삭제 후 공통된 코드 사용
* 추상화
  * 상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특징을 나타냄
  * 상세 내용은 하위 클래스/메소드/함수에서 구현
  
### 소스 코드 품질 분석 도구
소스 코드의 코딩 스타일, 코드에 설정된 코딩 표준, 코드의 복잡도, 코드에 존재하는 메모리 누수 현상, 스레드 <b>결함 등을 발견하기 위해 사용</b>
* 크게 정적 분석 도구와 동적 분석 도구로 나뉨

#### 정적 분석 도구
* <b>작성한 소스 코드를 실행하지 않고</b> 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구
* 비교적 개발 초기의 결함을 찾는데 사용
* 완료 시점에서 개발된 소스 코드의 품질을 검증하는 차원에서 사용
* 자료 흐름이나 논리 흐름을 분석하여 비정상적인 패턴을 찾을 수 있음
* 동적 분석 도구로는 발견하기 어려운 결함을 찾아냄
* <b>코딩의 복잡도, 모델 의존성, 불일치성</b> 등을 분석할 수 있음
* 종류 : pmd, cppcheck, SonarQube, checkstyle, ccm, cobertuna 등

#### 동적 분석 도구
* <b>작성한 소스 코드를 실행하여</b> 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석하는 도구
* 종류 : Avalanche, Valgrind

--- 

## 인터페이스 종류

### EAI(Enterprise Application Intergration)
EAI는 <b>기업 내 각종 애플리케이션 및 플랫폼 간 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션</b>
* 비즈니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확정성(Determinacy)을 높여줌

#### EAI 구축 유형
* Point-to-Point
  * 가장 기본적은 애플리케이션 통합 방식
  * 애플리케이션을 1:1로 연결
  * 변경 및 재사용이 어려움
* Hub & Spoke
  * 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식
  * 확장 및 유지 보수 용이
  * 허브 장애 발생 시 시스템 전체에 영향을 미침
* Message Bus(ESB 방식)
  * 애플리케이션 사이에 미들웨어를 두어 처리하는 방식
  * 확장성이 뛰어나며 대용량 처리 가능
* Hybrid
  * Hub & Spoke와 Message Bus의 혼합 방식
  * 그룹 내에서는 Hub & Spoke 방식, 그룹 간에는 Message Bus 방식 사용
  * 필요한 경우 한 가지 방식으로 EAI 구현이 가능
  * 데이터 병목 현상 최소화 가능
  
<br>

![image](https://user-images.githubusercontent.com/87363461/213849048-a68fab58-cd7a-4895-9545-cc8ddfd68ca3.png)

<br>

### ESB(Enterprise Service Bus)
ESB는 <b>애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션</b>
* 애플리케이션 통합 측면에서 EAI와 유사하지만 애플리케이션 보다는 서비스 중심으로 통합을 지향
* 특정 서비스에 국한되지 않고 벙묭적으로 사용하기 위해 애플리케이션과의 결합도(Coupling)를 약하게(Loosely) 유지
* 관리 및 보안 유지가 쉽고, 높은 수준의 품질 지원이 가능

<br>

![image](https://user-images.githubusercontent.com/87363461/213849124-5f2f9560-f733-436a-bcd3-22e6536e61be.png)

<br>

### JSON(JavaScript Object Notation)
JSON은 속성-값 쌍(Attribute-Value Pairs)으로 이루어진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷
* 비동기 처리에 사용되는 AJAX에서 XML을 대체하여 사용 중

### XML(eXtensible Markup Language)
XML은 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어
* 웹 페이지의 기본 형식인 HTML의 문법이 각 웹 브라우저에서 상호 호환적이지 않아 개발됨

### AJAX(Asynchronous Javascript And XML)
AJAX는 자바스크립트 등을 이용하여 클라이언트와 서버 간 XML 데이터를 교환 및 제어를 위해 사용
* 이용자가 웹 페이지와 자유롭게 상호 작용힐 수 있도록 하는 비동기 통신 기술

---

## 인터페이스 보안
인터페이스 보안 기능은 일반적으로 네트워크, 애플리케이션, 데이터베이스 영역에 적용
* 네트워크 영역
  * 인터페이스 송수신간 스니핑 등을 이용한 데이터 탈취 및 변조 위협을 바잊하기 위해 네트워크 트래픽에 암호화 설정
  * 암호화는 인터페이스 아키텍처에 따ㅏㄹ IPSec, SSL, S-HTTP 등 다양한 방식 적용
* 애플리케이션 영역
  * 소프트웨어 개발 보안 가이드를 참조하여 코드 상 보안 취약점을 보완하는 방향으로 보안 기능 적용
* 데이터베이스 영역
  * 데이터베이스, 스키마, 엔티티의 접근 권한과 프로시저, 트리거 등 데이터베이스의 동작 객체 보안 취약점에 보안 기능 적용
  
### 데이터 무결성 검사 도구
데이터 무결성 검사 도구는 시스템 파일의 변경 유무 확인하여 변경 시 관리자에게 알려주는 도구
* 인터페이스 보얀 취약점을 분석하는데 사용
* 크래커나 허가받지 않은 내부 사용자들이 시스템에 칩입 시 감지 가능
* 해시 함수를 이용하여 DB를 감시 하다가 DB 상태가 달라지면 관리자에게 변경 사실을 알려줌
* Ex) Tripwire, AIDE, Samhain, Claymore, Slipwire, Fcheck 등

### 인터페이스 구현 검증 도구
인터페이스 구현을 검증하기 위해 인터페이스 단위 기능과 시나리오 등을 기반으로 하는 통합테스트 필요
* 통합 테스트는 자동화 도구를 이용하여 효율적 수행 가능

#### 테스트 자동화 도구
* xUnit
  * 같은 테스트 코드를 여러 번 작성하지 않게 도와줌
  * 예상 결과를 기억할 필요가 없게 하는 자동화된 해법을 제공하는 단위 테스트 프레임워크
* STAF
  * 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
  * 크로스 플랫폼, 분산 소프트웨어 테스트 환경을 조성할 수 있도록 지원
  * 분산 소프트웨어의 경우 각 분산 환경에 설치된 데몬이 프로그램 테스트에 대한 응답을 대신함
  * 테스트가 완료되면 이를 통합하고 자동화하여 프로그램 완성
* FitNesse
  * 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크
* NTAF
  * FitNesses의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN(Naver)의 테스트 자동화 프레임워크
* Selenium
  * 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크
* watir
  * Ruby를 사용하는 애플리케이션 테스트 프레임워크
  
### APM(Application Performance Management/Monitoring)
APM은 애플리케이션의 성능 관리를 위해 접속자, 지원자 현항, 트랜잭션 수행 내용 등 다양한 모니터링 기능을 제공하는 도구
* APM은 리소스 방식과 엔드투엔드 두가지 유형이 있음
* 리소스 방식 : Nagios, Zabbix, Cacti 등
* 엔드투엔드 방식 : VisualVM, 제니퍼, 스카우트 
