# 소프트웨어 설계 과목 정리 내용

## 소프트웨어 생명 주기(Software Life Cycle)
소프트웨어 생명 주기란 <b>소프트웨어 개발 방법론의 바탕</b>이 되는 것이다.
<br>
소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계 별로 나눈 것
<ul>
<li>소프트웨어 개발 단계와 각 단계별 주요 활동, 활동 결과에 대한 산출물로 표현</li>
<li>소프트웨어 생명 주기를 표현하는 형태를 소프트웨어 생명 주기 모형이라고 하며 소프트웨어 프로세스 모형 or 소프트웨어 공학 패러다임이라고 함</li>
<li>소프트웨어 생명 주기라고도 함</li>
</ul>

------------

### 소프트웨어 공학(SE, Software Enginerring)
소프트웨어 공학이란 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문을 말한다.
<br>
여러 가지의 방법론, 도구, 관리 기법들을 통하여 소프트웨어의 품질과 생산성 향상의 목적을 둔다.

#### 소프트웨어 공학의 기본 원칙
<ul>
<li>현대적인 프로그래밍 기술을 지속적으로 적용 필요</li>
<li>개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증 필요</li>
<li>소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록 유지 필요</li>
</ul>

------------

### 폭포수 모형(Waterfall Model)
폭포수 모형이란 이미 떨어진 폭포수 처럼 소프트웨어 개발도 이전 단계로 돌아갈 수 없다는 말에서 유래
<br>
돌아갈 수 없으니 <b>각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후 다음 단계로 진행</b>하는 개발 방법론
<ul>
<li>소프트웨어 공학에서 가장 오래되고 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형 (고전적 생명 주기 모형)</li>
<li>소프트웨어 개발 과정의 한 단계가 끝나야 다음 단계로 진행 가능한 <b>선형 순차적 모형</b></li>
<li>개발 중 <b>요구사항의 변경이 어려움</b></li>
</ul>

#### 타당성 검토 -> 계획 -> 요구분석 -> 설계 -> 구현(코딩) -> 시험(검사) -> 유지보수

------------

### 나선형 모형(Spiral Model, 점진적 모형)
나선형 모형은 나선을 따라 돌듯 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 환벽한 최종 소프트웨어를 개발하는 것으로, 점진적 모형이라고도 함
<ul>
<li><b>폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가</b>한 모형</li>
<li>소프트웨어 개발 시 발생할 수 있는 <b>위험을 관리, 최소화 하는 것을 목적</b>으로 함</li>
<li>점진적으로 개발이 진행되므로 누락 및 추가 요구사항 첨가 가능</li>
<li>유지보수 과정 불필요</li>
</ul>

#### 계획 수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가

------------

### 애자일 모형(Agile Model)
애자일 모형이란 '민첩함' 또는 '기민함' 이라는 뜻으로, 고객의 요구 사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하여 개발하는 것을 말한다.

<ul>
<li><b>좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점</b>을 맞춘 방법론을 통칭</li>
<li>기업 활동 전반에 걸쳐 사용됨</li>
</ul>

#### 애자일 모형을 기반으로 하는 소프트웨어 개발 모형
<ul>
<li>스크럼(Scrum)</li>
<li>XP(eXtreme Programming)</li>
<li>칸반(Kanban)</li>
<li>Lean</li>
<li>크리스탈(Crystal)</li>
<li>ASD(Adaptive Software Development)</li>
<li>기능 중심 개발(FDD, Feature Driven Decelopment)</li>
<li>DSDM(Dynamic System Development Mehod)</li>
<li>DAD(Disciplined Agile Delivery)</li>
</ul>

#### 애자일 개발 4가지 핵심 가치
<ol>
<li>프로세스와 도구보다는 <b>개인과 상호작용</b>에 더 가치를 둠</li>
<li>방대한 문석보다는 <b>실행되는 소프트웨어</b>에 더 가치를 둠</li>
<li>계약 협상보다는 <b>고객과 협업</b>에 더 가치를 둠</li>
<li>계획을 따르기 보다 <b>변화에 반응</b>하는 것에 더 가치를 둠</li>
</ol>

------------

## 스크럼(Scrum)
스크럼이란 럭비에서 반칙으로 경기가 중단된 경우 양 팀의 선수들이 럭비공을 가운데 두고 상대팀을 밀치기 위해 서로 대치해 있는 대형을 말한다.
<br>
스크럼은 이처럼 <b>팀이 중심이 되어 개발의 효율성을 높인다는 의미가 내포된 용어</b>이다.

<ul>
<li>팀원 스스로가 스크럼 팀을 구성(Self-Organizing)해야 함</li>
<li>개발 작업에 관한 모든 것을 스스로 해결(Cross-Functionnal)할 수 있어야 함</li>
<li>제품 책임자(PO), 스크럼 마스터(SM), 개발팀(DT)으로 구성</li>
</ul>

#### 제품 책임자(PO, Product Owner)
<ul>
<li>이해관계자들 중 개발된 제품에 대한 이해도가 높고, 요구 사항을 책임지고 의사 결정할 사람으로 선정</li>
  <li>개발 의뢰자나 사용자가 담당</li>
  <li>이해관계자들의 의견을 종합하여 제품에 대한 요구사항을 작성하는 주체</li>
  <li>제품에 대한 테스트를 수행하면서 주기적으로 요구사항의 우선순위 갱신</li>
</ul>

<br>

#### 스크럼 마스터(SM, Scrum Master)
<ul>
  <li>스크럼 팀이 스크럼을 잘 수행할 수 있도록 객관적인 시각에서 조언을 해주는 가이드 역할 수행</li>
  <li>일일 스크림 회의를 주관하여 진행 사항 점검</li>
  <li>개발 과정에서 발생된 장애 요소를 공론화하여 처리</li>
  </ul>

<br>
  
  #### 개발팀(DT, Development Team)
<ul>
  <li>제품 책임자(PO)와 스크럼 마스터(SM)틀 제외한 모든 팀원</li>
  <li>개발자 이외에도 디자이너, 테스터 등 제품 개발을 위해 참여하는 모든 사람이 대상</li>
  <li>보통 최대 인원은 7 ~ 8명이 적당</li>
  </ul>

### 스크럼 개발 프로세스
제품 백로그 -> 스프린트 계획 회의 -> 스프린트 -> 일일 스크럼 회의 -> 스프린트 검토 회의 -> 스프린트 회고

------------

## XP(eXtreme Programming)
XP란 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법을 말한다.

<ul>
<li>짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 빠른 개발을 목적으로 함</li>
<li>릴리즈의 기간을 짧게 반복하면서 요구사항 반영에 대한 가시성을 높임</li>
</ul>

### XP의 5가지 핵심 가치
<ol>
<li>의사소통(Communication)</li>
<li>단순성(Simplicity)</li>
<li>용기(Courage)</li>
<li>존중(Respect)</li>
<li>피드백(Feedback)</li>
</ol>

### XP의 주요 실천 방법
<ul>
<li>짝 프로그래밍(Pair Programming)</li>
<li>공동 코드 소유(Collective Ownership)</li>
<li>테스트 주도 개발(Test-Driven Development)</li>
<li>전체 팀(Whole Team)</li>
<li>계속적인 통합(Continuous Intergration)</li>
<li>디자인 개선(Design Improvement) 또는 리팩토링(Refactoring)</li>
<li>소규모 릴리즈(Small Releases)</li>
</ul>

------------

## 개발 기술 환경

### 운영체제(OS, Operating System)
운영체제란 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어를 말한다.

<ul>
<li>사용자 <-> 하드웨어 간 인터페이스로, 동작하는 시스템 소프트웨어의 일종</li>
<li>다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공</li>
<li>컴퓨터 운영체제로 Windows, UNIX, Linux, Mac OS 등이 존재, 모바일에는 Android, IOS가 있음</li>
</ul>

#### 운영체제 관련 요구사항 식별 시 고려 사항
<ul>
<li>가용성</li>
<li>성능</li>
<li>기술 지원</li>
<li>주변 기기</li>
<li>구축 비용</li>
</ul>

### 데이터베이스 관리 시스템(DBMS, DataBase Managment System)
DBMS란 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성, 관리해주는 소프트웨어를 말한다.

* 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성 문제를 해결하기 위해 제안된 시스템
* 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리
* 데이터베이스의 구성, 접근 방법, 유지관리에 모든 책임을 짐

#### DBMS 관련 요구사항 식별 시 고려 사항
* 가용성
* 성능
* 기술 지원
* 상호 호환성
* 구축 비용

#### 주요 데이터베이스의 종류
* Orcale
* IBM DB2
* Microsoft SQL Server
* MySQL
* SQLite
* MongoDB
* Redis

### 웹 어플리케이션 서버(WAS, pplication Server)
웹 어플리케이션이란 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어
* 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리 제공
* 주로 데이터베이스 서버와 연동해서 사용

#### 주요 웹 어플리케이션 서버 종류
* Tomcat
* GlassFish
* JBoss
* Jetty
* JEUS
* Resin
* WebLogic
* WebSphere

------------

## 요구사항 정리
요구사항은 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상 운영에 필요한 제약조건 등을 나타낸다.

### 기능 요구사항(Functional Requirements)
* 동작 사항 : 시스템이 무엇을, 어떤 기능을 하는지에 대한 사항
* 입출력 사항 : 시스템의 입력 출력이 무엇을 포함해야 하는지에 대한 사항
  * 어떤 데이터를 저장 및 연산해야 하는지 기술
* 필수 수행 기능 사항 : 시스템이 반드시 수행해야 하는 기능에 대한 사항
* 요구 기능 사항 : 사용자가 시스템을 통해 제공받기를 원하는 기능

### 비기능 요구사항(Non-Functional Requirements)
* 인터페이스 요구사항 : 시스템 인터페이스와 사용자 인터페이스에 대한 요구사항
  * 소프트웨어, 하드웨어, 통신 인터페이스, 모든 포로토콜과의 연계도 포함하여 기술
* 데이터 요구사항 : 초기자료 구축 및 데이터 변환을 위한 대상 방법
  * 보안이 필요한 데이터 등 데이터를 구축하기 위해 필요한 요구 사항
* 테스트 요구사항 : 도입되는 장비의 성능 테스트(BMT)나 구축된 시스템 등의 테스트 요구 사항
* 보안 요구사항 : 시스템의 데이터 및 기능, 운영 접근을 통제하기 위한 요구 사항
* 품질 요구사항 : 관리가 필요한 품질 항목, 품질 평가 대상에 대한 요구 사항
  * 가용성, 정합성, 상호 호환성, 대응성, 신뢰성, 사용성, 유지 관리성, 이식성, 확장성, 보안성 등으로 구분하여 기술
* 제약사항 : 시스템 설계, 구축, 운영과 관련된 기술, 표준, 업무, 법 제도 등 제약 조건
* 프로젝트 관리 요구사항 : 프로젝트의 원활한 수행을 위한 관리방법에 대한 요구사항
* 프로젝트 지원 요구사항 : 프로젝트의 원활한 수행을 위한 지원사항이나 방안에 대한 요구사항

### 요구사항 개발 프로세스
도출/추출licitation) -> 분석(Analysis) -> 명세(Specification) -> 확인/검증Validation)

### 요구사항 명세 기법
* 정형 명세 기법
* 비정형 명세 기법

### 요구사항 분석 기법
* 요구사항의 타당성 조사와 비용 및 일정 설정
* 목표 수립 및 해결 방안 결정
* 요구사항을 정확하고 일관성 있게 분석하여 문서화
* UML, 자료 흐름도(DFD), 자료 사전(DD), 소단위 명세서(Mini-Spec), 개체 관계도(ERD), 상태 전이도(STD), 제어 명세서 등 도구 이용

------------

## 요구사항 분석 도구

### 자료 흐름도(DFD, Data Flow Diagram)
요구사항 분석에서 자료의 흐름 및  변환 과정과 기능을 도행 중심으로 기술하는 방법
* 버블 차트(Bubble Chart) 라고도 함
* 프로세스(Process) : 자료를 변환시키는 부분, 원, 둥근 사각형으로 표시
* 자료 흐름(Data Flow) : 자료의 이동을 나타내며, 화살표로 표시
* 자료 저장소(Data Store) : 자료 저장소를 나타내며, 도형으로 표시
* 단말(Terminator) : 시스템과 교신하는 외부 개채를 말하며, 도형으로 표시

### 자료 사전(DD, Data Dictionary)
자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것으로 기호로 표시
* 메타 데이터(Meta Data) 라고도 함
* = : 자료의 정의, ~로 구성되어 있음
* + : 자료의 연결, 그리고(and)
* [] : 자료의 선택, 또는(or)
* () : 자료의 생략, 생략 가능한 자료(option)
* {} : 자료의 반복
* ** ** : 자료의 설명

### HIPO(Hierarchy Input Process Output)
시스템의 분석 및 설계, 문서화 시 사용되는 기법
* 기본 시스템 모델은 입력, 처리, 출력으로 구성
* 하향식 소프트웨어 개발을 위한 문서화 도구
* 체게적인 문서 관리 가능
* 기호, 도표 등을 사용하여 직관성이 좋음
* 기능과 자료의 의존 관계를 동시 표현 가능
* 변경 및 유지보수 용이

#### HIPO Chart
HIPO Chart란 시스템의 기능을 여러 개의 고유 모듈로 분할하여 이들 간 인터페이스 계층 구조 표현한 것을 말한다.
* 가시적 도표(도식 목차) : 시스템의 전체적인 기능과 흐름을 보여주는 계층(Tree) 구조도
* 총체적 도표(총괄 도표, 개요 도표) : 프로그램을 구성하는 기능을 기술한 것으로 입력, 출력, 처리에 대한 정보를 제공하는 도표
* 세부적 도표(상세 도표) : 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

------------

## UML(Unified Modeling Language)
개발자와 고객 상호간 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
* 국제표준화기구 OMG(Object Management Group) 에서 표준으로 지정
* 시스템 구조를 표현하는 6개의 구조 다이어그램과 동작 표현 7개의 행위 다이어그램 작성 가능

### UML 구성 요소
* 사물(Things)
  *  구조
  *  행동
  *  그룹(Group)
* 관계(Relation-Ships)
  *  연관(Association) 관계
  *  집합(Aggregation) 관계
  *  포함(Composition) 관계
  *  일반화(Generalization) 관계
  *  의존(Dependency) 관계
  *  실체화(Realization) 관계
* 다이어그램(Diagram)
  * 구조적(Structural) 다이어그램
    * 클래스(Class) 다이어그램
    * 객체(Object) 다이어그램
    * 컴포넌트(Component) 다이어그램
    * 배치(Deployment) 다이어그램
    * 복합체 구조(Composite Structure) 다이어그램
    * 패키지(Package) 다이어그램
  * 행위(Behavioral) 다이어그램
    * 유스케이스(Use Case) 다이어그램
    * 순차(Sequence) 다이어그램
    * 커뮤니케이션(Communication) 다이어그램
    * 상태(State) 다이어그램
    * 활동(Activity) 다이어그램
    * 상호작용(Interaction Overview) 다이어그램
    * 타이밍(Timing) 다이어그램
    
    
------------

## 사용자 인터페이스(UI, User Interface)

### UI의 대표적인 특징
* 사용자 만족도에 가장 큰 영향을 미치는 중요한 요소
* 변경이 가장 많이 발생
* 편리성과 가독성을 높여 작업 시간을 단축 및 업무 이해도 향상
* 최소한의 노력으로 원하는 결과 성취 가능
* 사용자 중심 설계로 상호 작용이 가능하도록 함
* 수행 결과의 오류를 줄임
* 작업 기능에 대해 구체적인 방법 제시
* 정보 제공자 <-> 공급자 간 매개 역할 수행
* UI 설계를 위해 S/W 아키텍처 숙지 필수

### UI 구분
* CLI(Command Line Interface) : 명령과 출력이 텍스트 형태로 이루어진 인터페이스
* GUI(Graphical User Interface) : 아이콘 및 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스
* NUI(Natural User Interface) : 말이나 행동으로 기기를 조작하는 인터페이스
* OUI(Organic User Interface) : 모든 사물과 사용자 간의 인터페이스로 소프트웨어가 아닌 하드웨어 분야에서 대두는 중
  *  사물 인터넷(IoT)
  *  가상현실(VR)
  *  증강현실(AR)
  *  혼합현실(MR)
  
### UI의 기본 원칙
* 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함
* 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함
* 학습성 : 누구나 쉽게 배울 수 있어야 함
* 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함

### UI 설계 지침
* 사용자 중심 : 실사용자에 대한 이해를 바탕으로 쉽게 이해 및 편리 사용 환경 제공
* 사용성 : 사용자가 소프트웨어를 빠르고 쉽게, 효율적으로 이용할 수 있도록 하는 것으로 <b>가장 우선적으로 고려</b>
* 심미성 : 가독성을 높여 디자인을 효율적으로 설계
* 오류 발생 해결 : 오류 발생 시 사용자 인지 

### UI 개발 시스템의 기능
* 사용자의 입력 검증 필요
* 에러 처리와 그와 관련된 여러 메시지 표시 필요
* 도움과 프롬프트(Promprt) 제공 필요

### UI 설계 도구
* 와이어프레임(Wireframe)
  *  손그림
  *  파워포인트
  *  일러스트
  *  포토샵
  *  키노트
  *  스케치
* 목업(Mockup)
  *  파워 목업
  *  발사믹 목업
* 스토리 보드(Story Board)
  *  파워포인트
  *  키노트
  *  스케치
  *  Axure
* 프로토 타입(Proto Type)
* 유스케이스(Use Case)

### UI 요소
* 체크 박스(Check Box) : 여러 개의 선택 상황 중 여러 개 선택 가능 타입
* 라디오 버튼(Radio Button) 여러 개의 선택 상황 중 1개만 선택 가능 타입
* 텍스트 박스(Text Box) : 사용자가 데이터 입력 및 수정 가능 상자
* 콤보 상자(Combo Box) : 내용 표시 및 새로 입력 가능한 여러 내용을 표시하는 상자
* 목록 상자(List Box) : 콤보 상자와 같지만 새로운 내용 입력 불가능한 상자



------------


## 품질 요구사항
품질 요구사항이란 소프트웨어의 기능, 성능, 만족조 등 소프트웨어 요구사항 총족도에 대한 특성을 말한다.

### 국제 제품 품질 표준
* ISO/IEC 9126
* ISO/IEC 25010
* ISO/IEC 12119
* ISO/IEC 14598

### ISO/IEC 9126
* 기능성(Functionality) : 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부
  * 적설성/적합성(Suitability)
  * 정밀성/정확성(Interoperability)
  * 보안성(Security)
  * 준수성(Compliance)
* 신뢰성(Reliability) : 요구된 기능을 정확하고 일관되게 오류 없이 수행할 수 있는지의 정도
  * 성숙성(Malurity)
  * 고장 허용성(Faut Tolerance)
  * 회복성(Recoverability)
* 사용성(Usability) : 사용자가 정확하게 이해하고 사용하는지 여부
  * 이해성(Understandability
  * 학습성(Learnability)
  * 운용성(Operability)
  * 친밀성(Attractiveness)
* 효율성(Efficiency) : 요구하는 기능을 할당된 시간 내 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도
  * 시간 효율성(Time Behaviour)
  * 자원 효율성(Resource Behaviour)
* 유지 보수성(Maintainability) : 요구사항이 발생했을 때 개선 및 확장 정도를 나타냄
  * 분석성(Analyzability)
  * 변경성(Changeability)
  * 안정성(Stability)
  * 시험성(Testability)
* 이식성(Portability) : 다른 환경에서 얼마나 쉽게 적용할 수 있는지 정도
  * 적용성(Adaptability)
  * 설치성(Installability)
  * 대체성(Replaceability)
  * 공존성(Co-existence)

------------

## 소프트웨어 아키텍처(Software Architecture)

### 설계의 기본 원리
* 모듈화(Modularity) : 시스템의 기능을 모듈 단위로 나누는 것
* 추상화(Abstraction) : 전체 개념 설계 후 차례로 세분화하여 구체화시켜 나가는 것
  * 과정 추상화
  * 데이터 추상화
  * 제어 추상화
* 단계적 분해(Stepwise Refinement) : 문제를 상위 주요 개념부터 하위 개념으로 구체화시키는 분할 기법
* 정보 은닉(Information Hiding) : 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

### 품질 속성
* 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성 등
* 비지니스 측면 : 시장 적시성, 비용과 혜택, 예상 시스템 수명 등
* 아키텍처 측면 : 개념적 무결성, 정확성, 완결성, 구축 가능성 등

### 설계 과정
1. 설계 목표 설정 : 비지니스 목표, 우선순위 등과 같은 요구사항을 분석하여 설계 목표 설정
2. 시스템 타입 결정 : 시스템 및 서브시스템 타입 결정, 설계 목표 고려, 아키텍처 패턴 선택
3. 아키텍처 패턴 적용 : 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처 설계
4. 서브시스템 구체화 : 서브시스템 기능 및 서브시스템 간 상호 작용 동작 인터페이스 정의
5. 검토 : 아키텍터 목표 부합, 요구사항 반영 여부, 설계 기본 원리 만족 검토

------------

## 소프트웨어 아키텍처 패턴(Software Architecture Pattern)

### 클라이언트-서버 패턴(Client-Server Pattern)
하나의 서버와 다수의 클라이언트 컴포넌트를 구분하여 구성하는 패턴
* 서버, 클라이언트는 요청 및 응답을 받기 위해 동기화 되는 경우를 제외하고 서로 독립적임

### 파이프-필터 패턴(Pipe-Filter Pattern)
파이프-필터 패턴이란 데이터 스트림의 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 전송하는 패턴을 말한다.
* 필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장 용이
* 필터 컴포넌트들을 재배치하여 다양한 파이프라인 구축 가능
* 데이터 변환, 버퍼링, 동기화 등에 주로 사용됨
* 대표적으로 UNIX의 쉘(Shell)이 있음

![image](https://user-images.githubusercontent.com/87363461/211544798-aad64319-b738-435f-81fd-2de98a58d2cb.png)

### 모델-뷰-컨트롤러 패턴(MVC, Model-View-Controller Pattern)
MVC 패턴이란 서브시스템을 3개의 부분으로 구조화하는 패턴을 말한다.
* 모델(Model) : 서브시스템의 핵심 기능과 데이터를 보관
* 뷰(View) : 사용자에게 정보 표시
* 컨트롤러(Controller) : 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보냄

![image](https://user-images.githubusercontent.com/87363461/211545073-9f46e7ea-e400-47c1-a80a-42a286823a49.png)

### 기타 패턴

* 마스터-슬레이브 패턴(Master-Slave Pattern) : 마스터 - 슬레이브 컴포넌트로 분할하여 동작 처리
  * 장애 허용 시스템, 병렬 컴퓨터 시스템에서 주로 활용
* 브로커 패턴(Broker Pattern) : 원하는 서비스와 특성을 브로커 컴포넌트에 요청, 브로커 컴포넌트가 맞는 컴포넌트 사용자 연결
  * 분산 환경 시스템에서 주로 사용
* 피어-투-피어 패턴(Peer-To-Peer Pattern) : 피어를 하나의 컴포넌트로 간주, 각 피어는 서비스를 호출하여 동작
* 이벤트-버스 패턴(Event-Bus Pattern) : 특정 채널에 이벤트 메시지 발행 - 해당 채널을 구독한 리스너들이 이벤트 처리
* 블랙보드 패턴(Blackboard Pattern) : 모든 컴포넌트들이 공유 데이터 저장소, 블랙보드 컴포넌트에 접근 가능 형태
  * 음성 인식, 차량 식별, 신호 해석등 에 주로 활용
* 인터프리터 패턴(Interpreter Pattern) : 코드의 각 라인을 수행하는 방법을 지정하고 기호마다 클래스를 갖도록 구성

---

## 객체 지향 프로그래밍(OOP, Object Oriented Programming)

### 객체(Object)
객체란 __데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화) 하나의 소프트웨어 모듈__
* 독립적으로 식별 가능한 이름을 보유
* 객체가 가질 수 있는 조건인 상태(State)는 일반적으로 시간에 따라 변함
* 객체와 객체는 상호 연관성에 의한 관계가 형성됨
* 객체의 __상태를 참조, 변경하는 수단이 되는 것을 메소드__(Method, 행위)라고 함
* 객체의 메소드는 다른 객체로부터 메시지 수신 시 정해진 기능 수행

### 클래스(Class)
클래스란 공통된 속성과 연산(행위)를 갖는 객체의 집합으로, 객체의 일반적인 타입을 의미
* 클래스는 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 툴
* 클래스는 객체지향 프로그래밍에서 __데이터를 추상화하는 단위__
* 클래스에 속한 각각의 __객체를 인스턴스(Instance) 라고 함__
* 클래스로부터 __새로운 객체를 생성하는 것을 인스턴스화(Instantiation) 라고 함__

### 캡슐화(Encapsulation)
캡슐화란 __데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것__을 의미
* 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부에서의 접근이 제한적
  * 외부 모듈의 변경으로 인한 파급 효과가 적음
* 캡슐화된 객체들은 재사용 용이
* 객체들 간 메시지 교환 시 상대 객체의 세부 내용은 무관하여 인터페이스가 단순해짐
  * 즉, __객체 간의 결합도가 낮아짐__
  
### 상속(Inheritance)
상속이란 이미 정의된 상위 클래스(부모)의 모든 속성과 연산을 하위 클래스(자식)가 물려받는 것
* 상속 이용 시 하위 클래스는 상속 클래스의 메소드와 객체 사용 가능
* 하위 클래스는 상위 클래스로부터 상속받은 객체와 메소드에 새로운 객체와 메소드 추가 가능
* 한 개의 클래스가 __두 개 이상의 클래스로부터 상속 받는 것을 다중 상속__이라고 함

### 다형성(Polymorphism)
다형성이란 __하나의 메시지에대해 각각의 객체가 보유한 특성으로 응답__하는 것
* 예를 들어 '+' 기호는 숫자 클래스에서는 덧셈, 문자열 클래스에서는 문자열 더하기
* 오버로딩(Overloading)의 경우 이름은 같지만 __매개변수와 자료형을 달리해 여러 기능 정의__ 가능
* 오버라이딩(Overriding)의 경우 상위 클래스 메소드와 이름은 같지만 __자식 클래스에서 재정의__ 가능

### 객체지향 설계 원칙
시스템 변경이나 확장에 유연한 시스템을 설계하기 위한 다섯 가지 원칙, __원칙의 앞 글자를 따 SOLID 원칙 이라고 부름__
* 단일 책임 원칙(SRP, Single Responsibility Principle) : 객체는 단 하나의 책임만 가져야 한다는 원칙
* 개방-폐쇄 원칙(OCP, Open-Closed Principle) : 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 하는 원칙
* 리스코프 치환 원칙(LSP, Liskov Subsitiution principle) : 자식 클래스는 최소 부모 클래스에서 가능한 행위는 수행할 수 있어야 하는 원칙
* 인터페이스 분리 원칙(ISP, Interface Segregation Principle) : 사용하지 않은 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 하는 규칙
* 의존 역전 원칙(DIP, Dependency Inversion Principle) : 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 하는 규칙
  * 각 객체들 간의 의존 관계가 성립될 때
  
### 결합도(Coupling)
결합도는 __모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계__를 의미
* 다양한 결합으로 모듈을 구성할 수 있으나 __결합도가 약할수록 품질이 높고 강할수록 품질이 낮음__
* __결합도가 강하면 시스템 구현 및 유지보수 작업이 어려움__

#### 결합도의 종류(강함 -> 약함 순)
* 자료(Data) 결합도 : 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도
* 스탬프(검인)(Stamp) 결합도 : 모듈 간의 인터페이스로 배열, 레코드 등의 자료 구조가 전달될 때의 결합도
* 제어(Control) 결합도 : 제어 신호를 이용 또는 제어 요소를 전달하는 결합도
* 외부(External) 결합도 : 어떤 모듈에 선언한 변수를 외부의 다른 모듈에서 참조할 때의 결합도
* 공통(공유)(Common) 결합도 : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
* 내용(Content) 결합도 : 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도

### 응집도(Cohesion)
정보 은닉 개념을 확장한 것으로 명령어나 호출문 등 모듈의 내부 요소들이 서로 관련되어 있는 정도
<br>
즉, __모듈이 독립적인 기능으로 정의되어 있는 정도__
* __응집도가 강할수록 품질이 높고 약할수록 품질이 낮음__

#### 응집도의 종류(강함 -> 약함 순)
* 기능적(Functional) 응집도 : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
* 순차적(Sequntial) 응집도 : 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
* 교환(통신)(Communication) 응집도 : 동일한 입출력을 사용하여 서로 다른 기능을 수행하는 요소들이 모였을 경우의 응집도
* 절차적(Procedural) 응집도 : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
* 시간적(Temporal) 응집도 : 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
* 논리적(Logical) 응집도 : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
* 우연적(Coincidental) 응집도 : 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

---

## 공통 모듈
공통 모듈이란 여러 프로그램에서 공통적으로 사용할 수 있는 모듈을 의미
* 자주 사용되느 계산식 또는 매번 필요한 사용자 인증과 같은 기능들이 공통 모듈로 구성 가능
* 모듈의 재사용성 확보, 중복 개발 회피를 위해 설계 과정에서 공통 부분 식별, 명세서 작성 필요

#### 공통 모듈 구현 시 명세 기법
다른 개발자들이 해당 기능을 명확히 이해할 수 있도록 하는 기법
* 정확성(Correctness) : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성
* 명확성(Clarity) : 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성
* 완전성(Completeness) : 시스템 구현 시 필요한 모든 것들 기술
* 일관성(Consistency) : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
* 추적성(Traceability) : 기능에 대한 요구 사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성
