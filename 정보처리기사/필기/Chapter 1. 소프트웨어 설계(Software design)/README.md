# 소프트웨어 설계 과목 정리 내용

## 소프트웨어 생명 주기(Software Life Cycle)
소프트웨어 생명 주기란 <b>소프트웨어 개발 방법론의 바탕</b>이 되는 것이다.
<br>
소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 과정을 각 단계 별로 나눈 것
<ul>
<li>소프트웨어 개발 단계와 각 단계별 주요 활동, 활동 결과에 대한 산출물로 표현</li>
<li>소프트웨어 생명 주기를 표현하는 형태를 소프트웨어 생명 주기 모형이라고 하며 소프트웨어 프로세스 모형 or 소프트웨어 공학 패러다임이라고 함</li>
<li>소프트웨어 생명 주기라고도 함</li>
</ul>

------------

### 소프트웨어 공학(SE, Software Enginerring)
소프트웨어 공학이란 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문을 말한다.
<br>
여러 가지의 방법론, 도구, 관리 기법들을 통하여 소프트웨어의 품질과 생산성 향상의 목적을 둔다.

#### 소프트웨어 공학의 기본 원칙
<ul>
<li>현대적인 프로그래밍 기술을 지속적으로 적용 필요</li>
<li>개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증 필요</li>
<li>소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록 유지 필요</li>
</ul>

------------

### 폭포수 모형(Waterfall Model)
폭포수 모형이란 이미 떨어진 폭포수 처럼 소프트웨어 개발도 이전 단계로 돌아갈 수 없다는 말에서 유래
<br>
돌아갈 수 없으니 <b>각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후 다음 단계로 진행</b>하는 개발 방법론
<ul>
<li>소프트웨어 공학에서 가장 오래되고 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형 (고전적 생명 주기 모형)</li>
<li>소프트웨어 개발 과정의 한 단계가 끝나야 다음 단계로 진행 가능한 <b>선형 순차적 모형</b></li>
<li>개발 중 <b>요구사항의 변경이 어려움</b></li>
</ul>

#### 타당성 검토 -> 계획 -> 요구분석 -> 설계 -> 구현(코딩) -> 시험(검사) -> 유지보수

------------

### 나선형 모형(Spiral Model, 점진적 모형)
나선형 모형은 나선을 따라 돌듯 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 환벽한 최종 소프트웨어를 개발하는 것으로, 점진적 모형이라고도 함
<ul>
<li><b>폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가</b>한 모형</li>
<li>소프트웨어 개발 시 발생할 수 있는 <b>위험을 관리, 최소화 하는 것을 목적</b>으로 함</li>
<li>점진적으로 개발이 진행되므로 누락 및 추가 요구사항 첨가 가능</li>
<li>유지보수 과정 불필요</li>
</ul>

#### 계획 수립 -> 위험 분석 -> 개발 및 검증 -> 고객 평가

------------

### 애자일 모형(Agile Model)
애자일 모형이란 '민첩함' 또는 '기민함' 이라는 뜻으로, 고객의 요구 사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하여 개발하는 것을 말한다.

<ul>
<li><b>좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점</b>을 맞춘 방법론을 통칭</li>
<li>기업 활동 전반에 걸쳐 사용됨</li>
</ul>

#### 애자일 모형을 기반으로 하는 소프트웨어 개발 모형
<ul>
<li>스크럼(Scrum)</li>
<li>XP(eXtreme Programming)</li>
<li>칸반(Kanban)</li>
<li>Lean</li>
<li>크리스탈(Crystal)</li>
<li>ASD(Adaptive Software Development)</li>
<li>기능 중심 개발(FDD, Feature Driven Decelopment)</li>
<li>DSDM(Dynamic System Development Mehod)</li>
<li>DAD(Disciplined Agile Delivery)</li>
</ul>

#### 애자일 개발 4가지 핵심 가치
<ol>
<li>프로세스와 도구보다는 <b>개인과 상호작용</b>에 더 가치를 둠</li>
<li>방대한 문석보다는 <b>실행되는 소프트웨어</b>에 더 가치를 둠</li>
<li>계약 협상보다는 <b>고객과 협업</b>에 더 가치를 둠</li>
<li>계획을 따르기 보다 <b>변화에 반응</b>하는 것에 더 가치를 둠</li>
</ol>

------------

## 스크럼(Scrum)
스크럼이란 럭비에서 반칙으로 경기가 중단된 경우 양 팀의 선수들이 럭비공을 가운데 두고 상대팀을 밀치기 위해 서로 대치해 있는 대형을 말한다.
<br>
스크럼은 이처럼 <b>팀이 중심이 되어 개발의 효율성을 높인다는 의미가 내포된 용어</b>이다.

<ul>
<li>팀원 스스로가 스크럼 팀을 구성(Self-Organizing)해야 함</li>
<li>개발 작업에 관한 모든 것을 스스로 해결(Cross-Functionnal)할 수 있어야 함</li>
<li>제품 책임자(PO), 스크럼 마스터(SM), 개발팀(DT)으로 구성</li>
</ul>

#### 제품 책임자(PO, Product Owner)
<ul>
<li>이해관계자들 중 개발된 제품에 대한 이해도가 높고, 요구 사항을 책임지고 의사 결정할 사람으로 선정</li>
  <li>개발 의뢰자나 사용자가 담당</li>
  <li>이해관계자들의 의견을 종합하여 제품에 대한 요구사항을 작성하는 주체</li>
  <li>제품에 대한 테스트를 수행하면서 주기적으로 요구사항의 우선순위 갱신</li>
</ul>

<br>

#### 스크럼 마스터(SM, Scrum Master)
<ul>
  <li>스크럼 팀이 스크럼을 잘 수행할 수 있도록 객관적인 시각에서 조언을 해주는 가이드 역할 수행</li>
  <li>일일 스크림 회의를 주관하여 진행 사항 점검</li>
  <li>개발 과정에서 발생된 장애 요소를 공론화하여 처리</li>
  </ul>

<br>
  
  #### 개발팀(DT, Development Team)
<ul>
  <li>제품 책임자(PO)와 스크럼 마스터(SM)틀 제외한 모든 팀원</li>
  <li>개발자 이외에도 디자이너, 테스터 등 제품 개발을 위해 참여하는 모든 사람이 대상</li>
  <li>보통 최대 인원은 7 ~ 8명이 적당</li>
  </ul>

### 스크럼 개발 프로세스
제품 백로그 -> 스프린트 계획 회의 -> 스프린트 -> 일일 스크럼 회의 -> 스프린트 검토 회의 -> 스프린트 회고

------------

## XP(eXtreme Programming)
XP란 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법을 말한다.

<ul>
<li>짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 빠른 개발을 목적으로 함</li>
<li>릴리즈의 기간을 짧게 반복하면서 요구사항 반영에 대한 가시성을 높임</li>
</ul>

### XP의 5가지 핵심 가치
<ol>
<li>의사소통(Communication)</li>
<li>단순성(Simplicity)</li>
<li>용기(Courage)</li>
<li>존중(Respect)</li>
<li>피드백(Feedback)</li>
</ol>

### XP의 주요 실천 방법
<ul>
<li>짝 프로그래밍(Pair Programming)</li>
<li>공동 코드 소유(Collective Ownership)</li>
<li>테스트 주도 개발(Test-Driven Development)</li>
<li>전체 팀(Whole Team)</li>
<li>계속적인 통합(Continuous Intergration)</li>
<li>디자인 개선(Design Improvement) 또는 리팩토링(Refactoring)</li>
<li>소규모 릴리즈(Small Releases)</li>
</ul>

------------

## 개발 기술 환경

### 운영체제(OS, Operating System)
운영체제란 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어를 말한다.

<ul>
<li>사용자 <-> 하드웨어 간 인터페이스로, 동작하는 시스템 소프트웨어의 일종</li>
<li>다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공</li>
<li>컴퓨터 운영체제로 Windows, UNIX, Linux, Mac OS 등이 존재, 모바일에는 Android, IOS가 있음</li>
</ul>

#### 운영체제 관련 요구사항 식별 시 고려 사항
<ul>
<li>가용성</li>
<li>성능</li>
<li>기술 지원</li>
<li>주변 기기</li>
<li>구축 비용</li>
</ul>

### 데이터베이스 관리 시스템(DBMS, DataBase Managment System)
DBMS란 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성, 관리해주는 소프트웨어를 말한다.

* 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성 문제를 해결하기 위해 제안된 시스템
* 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리
* 데이터베이스의 구성, 접근 방법, 유지관리에 모든 책임을 짐

#### DBMS 관련 요구사항 식별 시 고려 사항
* 가용성
* 성능
* 기술 지원
* 상호 호환성
* 구축 비용

#### 주요 데이터베이스의 종류
* Orcale
* IBM DB2
* Microsoft SQL Server
* MySQL
* SQLite
* MongoDB
* Redis

### 웹 어플리케이션 서버(WAS, pplication Server)
웹 어플리케이션이란 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어
* 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리 제공
* 주로 데이터베이스 서버와 연동해서 사용

#### 주요 웹 어플리케이션 서버 종류
* Tomcat
* GlassFish
* JBoss
* Jetty
* JEUS
* Resin
* WebLogic
* WebSphere

------------

## 요구사항 정리
요구사항은 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상 운영에 필요한 제약조건 등을 나타낸다.

### 기능 요구사항(Functional Requirements)
* 동작 사항 : 시스템이 무엇을, 어떤 기능을 하는지에 대한 사항
* 입출력 사항 : 시스템의 입력 출력이 무엇을 포함해야 하는지에 대한 사항
  * 어떤 데이터를 저장 및 연산해야 하는지 기술
* 필수 수행 기능 사항 : 시스템이 반드시 수행해야 하는 기능에 대한 사항
* 요구 기능 사항 : 사용자가 시스템을 통해 제공받기를 원하는 기능

### 비기능 요구사항(Non-Functional Requirements)
* 인터페이스 요구사항 : 시스템 인터페이스와 사용자 인터페이스에 대한 요구사항
  * 소프트웨어, 하드웨어, 통신 인터페이스, 모든 포로토콜과의 연계도 포함하여 기술
* 데이터 요구사항 : 초기자료 구축 및 데이터 변환을 위한 대상 방법
  * 보안이 필요한 데이터 등 데이터를 구축하기 위해 필요한 요구 사항
* 테스트 요구사항 : 도입되는 장비의 성능 테스트(BMT)나 구축된 시스템 등의 테스트 요구 사항
* 보안 요구사항 : 시스템의 데이터 및 기능, 운영 접근을 통제하기 위한 요구 사항
* 품질 요구사항 : 관리가 필요한 품질 항목, 품질 평가 대상에 대한 요구 사항
  * 가용성, 정합성, 상호 호환성, 대응성, 신뢰성, 사용성, 유지 관리성, 이식성, 확장성, 보안성 등으로 구분하여 기술
* 제약사항 : 시스템 설계, 구축, 운영과 관련된 기술, 표준, 업무, 법 제도 등 제약 조건
* 프로젝트 관리 요구사항 : 프로젝트의 원활한 수행을 위한 관리방법에 대한 요구사항
* 프로젝트 지원 요구사항 : 프로젝트의 원활한 수행을 위한 지원사항이나 방안에 대한 요구사항

### 요구사항 개발 프로세스
도출/추출licitation) -> 분석(Analysis) -> 명세(Specification) -> 확인/검증Validation)

### 요구사항 명세 기법
* 정형 명세 기법
* 비정형 명세 기법

### 요구사항 분석 기법
* 요구사항의 타당성 조사와 비용 및 일정 설정
* 목표 수립 및 해결 방안 결정
* 요구사항을 정확하고 일관성 있게 분석하여 문서화
* UML, 자료 흐름도(DFD), 자료 사전(DD), 소단위 명세서(Mini-Spec), 개체 관계도(ERD), 상태 전이도(STD), 제어 명세서 등 도구 이용

------------

## 요구사항 분석 도구

### 자료 흐름도(DFD, Data Flow Diagram)
요구사항 분석에서 자료의 흐름 및  변환 과정과 기능을 도행 중심으로 기술하는 방법
* 버블 차트(Bubble Chart) 라고도 함
* 프로세스(Process) : 자료를 변환시키는 부분, 원, 둥근 사각형으로 표시
* 자료 흐름(Data Flow) : 자료의 이동을 나타내며, 화살표로 표시
* 자료 저장소(Data Store) : 자료 저장소를 나타내며, 도형으로 표시
* 단말(Terminator) : 시스템과 교신하는 외부 개채를 말하며, 도형으로 표시

### 자료 사전(DD, Data Dictionary)
자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것으로 기호로 표시
* 메타 데이터(Meta Data) 라고도 함
* = : 자료의 정의, ~로 구성되어 있음
* + : 자료의 연결, 그리고(and)
* [] : 자료의 선택, 또는(or)
* () : 자료의 생략, 생략 가능한 자료(option)
* {} : 자료의 반복
* ** ** : 자료의 설명

### HIPO(Hierarchy Input Process Output)
시스템의 분석 및 설계, 문서화 시 사용되는 기법
* 기본 시스템 모델은 입력, 처리, 출력으로 구성
* 하향식 소프트웨어 개발을 위한 문서화 도구
* 체게적인 문서 관리 가능
* 기호, 도표 등을 사용하여 직관성이 좋음
* 기능과 자료의 의존 관계를 동시 표현 가능
* 변경 및 유지보수 용이

#### HIPO Chart
HIPO Chart란 시스템의 기능을 여러 개의 고유 모듈로 분할하여 이들 간 인터페이스 계층 구조 표현한 것을 말한다.
* 가시적 도표(도식 목차) : 시스템의 전체적인 기능과 흐름을 보여주는 계층(Tree) 구조도
* 총체적 도표(총괄 도표, 개요 도표) : 프로그램을 구성하는 기능을 기술한 것으로 입력, 출력, 처리에 대한 정보를 제공하는 도표
* 세부적 도표(상세 도표) : 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

------------

## UML(Unified Modeling Language)
개발자와 고객 상호간 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어
* 국제표준화기구 OMG(Object Management Group) 에서 표준으로 지정
* 시스템 구조를 표현하는 6개의 구조 다이어그램과 동작 표현 7개의 행위 다이어그램 작성 가능

### UML 구성 요소
* 사물(Things)
  *  구조
  *  행동
  *  그룹(Group)
* 관계(Relation-Ships)
  *  연관(Association) 관계
  *  집합(Aggregation) 관계
  *  포함(Composition) 관계
  *  일반화(Generalization) 관계
  *  의존(Dependency) 관계
  *  실체화(Realization) 관계
* 다이어그램(Diagram)
  * 구조적(Structural) 다이어그램
    * 클래스(Class) 다이어그램
    * 객체(Object) 다이어그램
    * 컴포넌트(Component) 다이어그램
    * 배치(Deployment) 다이어그램
    * 복합체 구조(Composite Structure) 다이어그램
    * 패키지(Package) 다이어그램
  * 행위(Behavioral) 다이어그램
    * 유스케이스(Use Case) 다이어그램
    * 순차(Sequence) 다이어그램
    * 커뮤니케이션(Communication) 다이어그램
    * 상태(State) 다이어그램
    * 활동(Activity) 다이어그램
    * 상호작용(Interaction Overview) 다이어그램
    * 타이밍(Timing) 다이어그램
    
    
------------

## 사용자 인터페이스(UI, User Interface)

### UI의 대표적인 특징
* 사용자 만족도에 가장 큰 영향을 미치는 중요한 요소
* 변경이 가장 많이 발생
* 편리성과 가독성을 높여 작업 시간을 단축 및 업무 이해도 향상
* 최소한의 노력으로 원하는 결과 성취 가능
* 사용자 중심 설계로 상호 작용이 가능하도록 함
* 수행 결과의 오류를 줄임
* 작업 기능에 대해 구체적인 방법 제시
* 정보 제공자 <-> 공급자 간 매개 역할 수행
* UI 설계를 위해 S/W 아키텍처 숙지 필수

### UI 구분
* CLI(Command Line Interface) : 명령과 출력이 텍스트 형태로 이루어진 인터페이스
* GUI(Graphical User Interface) : 아이콘 및 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스
* NUI(Natural User Interface) : 말이나 행동으로 기기를 조작하는 인터페이스
* OUI(Organic User Interface) : 모든 사물과 사용자 간의 인터페이스로 소프트웨어가 아닌 하드웨어 분야에서 대두는 중
  *  사물 인터넷(IoT)
  *  가상현실(VR)
  *  증강현실(AR)
  *  혼합현실(MR)
  
### UI의 기본 원칙
* 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함
* 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함
* 학습성 : 누구나 쉽게 배울 수 있어야 함
* 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함

### UI 설계 지침
* 사용자 중심 : 실사용자에 대한 이해를 바탕으로 쉽게 이해 및 편리 사용 환경 제공
* 사용성 : 사용자가 소프트웨어를 빠르고 쉽게, 효율적으로 이용할 수 있도록 하는 것으로 <b>가장 우선적으로 고려</b>
* 심미성 : 가독성을 높여 디자인을 효율적으로 설계
* 오류 발생 해결 : 오류 발생 시 사용자 인지 

### UI 개발 시스템의 기능
* 사용자의 입력 검증 필요
* 에러 처리와 그와 관련된 여러 메시지 표시 필요
* 도움과 프롬프트(Promprt) 제공 필요

### UI 설계 도구
* 와이어프레임(Wireframe)
  *  손그림
  *  파워포인트
  *  일러스트
  *  포토샵
  *  키노트
  *  스케치
* 목업(Mockup)
  *  파워 목업
  *  발사믹 목업
* 스토리 보드(Story Board)
  *  파워포인트
  *  키노트
  *  스케치
  *  Axure
* 프로토 타입(Proto Type)
* 유스케이스(Use Case)

### UI 요소
* 체크 박스(Check Box) : 여러 개의 선택 상황 중 여러 개 선택 가능 타입
* 라디오 버튼(Radio Button) 여러 개의 선택 상황 중 1개만 선택 가능 타입
* 텍스트 박스(Text Box) : 사용자가 데이터 입력 및 수정 가능 상자
* 콤보 상자(Combo Box) : 내용 표시 및 새로 입력 가능한 여러 내용을 표시하는 상자
* 목록 상자(List Box) : 콤보 상자와 같지만 새로운 내용 입력 불가능한 상자



------------


## 품질 요구사항
품질 요구사항이란 소프트웨어의 기능, 성능, 만족조 등 소프트웨어 요구사항 총족도에 대한 특성을 말한다.

### 국제 제품 품질 표준
* ISO/IEC 9126
* ISO/IEC 25010
* ISO/IEC 12119
* ISO/IEC 14598

### ISO/IEC 9126
* 기능성(Functionality) : 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부
  * 적설성/적합성(Suitability)
  * 정밀성/정확성(Interoperability)
  * 보안성(Security)
  * 준수성(Compliance)
* 신뢰성(Reliability) : 요구된 기능을 정확하고 일관되게 오류 없이 수행할 수 있는지의 정도
  * 성숙성(Malurity)
  * 고장 허용성(Faut Tolerance)
  * 회복성(Recoverability)
* 사용성(Usability) : 사용자가 정확하게 이해하고 사용하는지 여부
  * 이해성(Understandability
  * 학습성(Learnability)
  * 운용성(Operability)
  * 친밀성(Attractiveness)
* 효율성(Efficiency) : 요구하는 기능을 할당된 시간 내 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도
  * 시간 효율성(Time Behaviour)
  * 자원 효율성(Resource Behaviour)
* 유지 보수성(Maintainability) : 요구사항이 발생했을 때 개선 및 확장 정도를 나타냄
  * 분석성(Analyzability)
  * 변경성(Changeability)
  * 안정성(Stability)
  * 시험성(Testability)
* 이식성(Portability) : 다른 환경에서 얼마나 쉽게 적용할 수 있는지 정도
  * 적용성(Adaptability)
  * 설치성(Installability)
  * 대체성(Replaceability)
  * 공존성(Co-existence)

------------

## 소프트웨어 아키텍처(Software Architecture)

### 설계의 기본 원리
* 모듈화(Modularity) : 시스템의 기능을 모듈 단위로 나누는 것
* 추상화(Abstraction) : 전체 개념 설계 후 차례로 세분화하여 구체화시켜 나가는 것
  * 과정 추상화
  * 데이터 추상화
  * 제어 추상화
* 단계적 분해(Stepwise Refinement) : 문제를 상위 주요 개념부터 하위 개념으로 구체화시키는 분할 기법
* 정보 은닉(Information Hiding) : 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

### 품질 속성
* 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성 등
* 비지니스 측면 : 시장 적시성, 비용과 혜택, 예상 시스템 수명 등
* 아키텍처 측면 : 개념적 무결성, 정확성, 완결성, 구축 가능성 등

### 설계 과정
1. 설계 목표 설정 : 비지니스 목표, 우선순위 등과 같은 요구사항을 분석하여 설계 목표 설정
2. 시스템 타입 결정 : 시스템 및 서브시스템 타입 결정, 설계 목표 고려, 아키텍처 패턴 선택
3. 아키텍처 패턴 적용 : 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처 설계
4. 서브시스템 구체화 : 서브시스템 기능 및 서브시스템 간 상호 작용 동작 인터페이스 정의
5. 검토 : 아키텍터 목표 부합, 요구사항 반영 여부, 설계 기본 원리 만족 검토

------------

## 소프트웨어 아키텍처 패턴(Software Architecture Pattern)

### 클라이언트-서버 패턴(Client-Server Pattern)
하나의 서버와 다수의 클라이언트 컴포넌트를 구분하여 구성하는 패턴
* 서버, 클라이언트는 요청 및 응답을 받기 위해 동기화 되는 경우를 제외하고 서로 독립적임

### 파이프-필터 패턴(Pipe-Filter Pattern)
파이프-필터 패턴이란 데이터 스트림의 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 전송하는 패턴을 말한다.
* 필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장 용이
* 필터 컴포넌트들을 재배치하여 다양한 파이프라인 구축 가능
* 데이터 변환, 버퍼링, 동기화 등에 주로 사용됨
* 대표적으로 UNIX의 쉘(Shell)이 있음

![image](https://user-images.githubusercontent.com/87363461/211544798-aad64319-b738-435f-81fd-2de98a58d2cb.png)

### 모델-뷰-컨트롤러 패턴(MVC, Model-View-Controller Pattern)
MVC 패턴이란 서브시스템을 3개의 부분으로 구조화하는 패턴을 말한다.
* 모델(Model) : 서브시스템의 핵심 기능과 데이터를 보관
* 뷰(View) : 사용자에게 정보 표시
* 컨트롤러(Controller) : 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보냄

![image](https://user-images.githubusercontent.com/87363461/211545073-9f46e7ea-e400-47c1-a80a-42a286823a49.png)

### 기타 패턴

* 마스터-슬레이브 패턴(Master-Slave Pattern) : 마스터 - 슬레이브 컴포넌트로 분할하여 동작 처리
  * 장애 허용 시스템, 병렬 컴퓨터 시스템에서 주로 활용
* 브로커 패턴(Broker Pattern) : 원하는 서비스와 특성을 브로커 컴포넌트에 요청, 브로커 컴포넌트가 맞는 컴포넌트 사용자 연결
  * 분산 환경 시스템에서 주로 사용
* 피어-투-피어 패턴(Peer-To-Peer Pattern) : 피어를 하나의 컴포넌트로 간주, 각 피어는 서비스를 호출하여 동작
* 이벤트-버스 패턴(Event-Bus Pattern) : 특정 채널에 이벤트 메시지 발행 - 해당 채널을 구독한 리스너들이 이벤트 처리
* 블랙보드 패턴(Blackboard Pattern) : 모든 컴포넌트들이 공유 데이터 저장소, 블랙보드 컴포넌트에 접근 가능 형태
  * 음성 인식, 차량 식별, 신호 해석등 에 주로 활용
* 인터프리터 패턴(Interpreter Pattern) : 코드의 각 라인을 수행하는 방법을 지정하고 기호마다 클래스를 갖도록 구성

---

## 객체 지향 프로그래밍(OOP, Object Oriented Programming)

### 객체(Object)
객체란 __데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화) 하나의 소프트웨어 모듈__
* 독립적으로 식별 가능한 이름을 보유
* 객체가 가질 수 있는 조건인 상태(State)는 일반적으로 시간에 따라 변함
* 객체와 객체는 상호 연관성에 의한 관계가 형성됨
* 객체의 __상태를 참조, 변경하는 수단이 되는 것을 메소드__(Method, 행위)라고 함
* 객체의 메소드는 다른 객체로부터 메시지 수신 시 정해진 기능 수행

### 클래스(Class)
클래스란 공통된 속성과 연산(행위)를 갖는 객체의 집합으로, 객체의 일반적인 타입을 의미
* 클래스는 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 툴
* 클래스는 객체지향 프로그래밍에서 __데이터를 추상화하는 단위__
* 클래스에 속한 각각의 __객체를 인스턴스(Instance) 라고 함__
* 클래스로부터 __새로운 객체를 생성하는 것을 인스턴스화(Instantiation) 라고 함__

### 캡슐화(Encapsulation)
캡슐화란 __데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것__을 의미
* 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부에서의 접근이 제한적
  * 외부 모듈의 변경으로 인한 파급 효과가 적음
* 캡슐화된 객체들은 재사용 용이
* 객체들 간 메시지 교환 시 상대 객체의 세부 내용은 무관하여 인터페이스가 단순해짐
  * 즉, __객체 간의 결합도가 낮아짐__
  
### 상속(Inheritance)
상속이란 이미 정의된 상위 클래스(부모)의 모든 속성과 연산을 하위 클래스(자식)가 물려받는 것
* 상속 이용 시 하위 클래스는 상속 클래스의 메소드와 객체 사용 가능
* 하위 클래스는 상위 클래스로부터 상속받은 객체와 메소드에 새로운 객체와 메소드 추가 가능
* 한 개의 클래스가 __두 개 이상의 클래스로부터 상속 받는 것을 다중 상속__이라고 함

### 다형성(Polymorphism)
다형성이란 __하나의 메시지에대해 각각의 객체가 보유한 특성으로 응답__하는 것
* 예를 들어 '+' 기호는 숫자 클래스에서는 덧셈, 문자열 클래스에서는 문자열 더하기
* 오버로딩(Overloading)의 경우 이름은 같지만 __매개변수와 자료형을 달리해 여러 기능 정의__ 가능
* 오버라이딩(Overriding)의 경우 상위 클래스 메소드와 이름은 같지만 __자식 클래스에서 재정의__ 가능

### 객체지향 설계 원칙
시스템 변경이나 확장에 유연한 시스템을 설계하기 위한 다섯 가지 원칙, __원칙의 앞 글자를 따 SOLID 원칙 이라고 부름__
* 단일 책임 원칙(SRP, Single Responsibility Principle) : 객체는 단 하나의 책임만 가져야 한다는 원칙
* 개방-폐쇄 원칙(OCP, Open-Closed Principle) : 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 하는 원칙
* 리스코프 치환 원칙(LSP, Liskov Subsitiution principle) : 자식 클래스는 최소 부모 클래스에서 가능한 행위는 수행할 수 있어야 하는 원칙
* 인터페이스 분리 원칙(ISP, Interface Segregation Principle) : 사용하지 않은 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 하는 규칙
* 의존 역전 원칙(DIP, Dependency Inversion Principle) : 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 하는 규칙
  * 각 객체들 간의 의존 관계가 성립될 때
  
### 결합도(Coupling)
결합도는 __모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를__ 의미
* 다양한 결합으로 모듈을 구성할 수 있으나 __결합도가 약할수록 품질이 높고 강할수록 품질이 낮음__
* __결합도가 강하면 시스템 구현 및 유지보수 작업이 어려움__

#### 결합도의 종류(강함 -> 약함 순)
* 자료(Data) 결합도 : 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도
* 스탬프(검인)(Stamp) 결합도 : 모듈 간의 인터페이스로 배열, 레코드 등의 자료 구조가 전달될 때의 결합도
* 제어(Control) 결합도 : 제어 신호를 이용 또는 제어 요소를 전달하는 결합도
* 외부(External) 결합도 : 어떤 모듈에 선언한 변수를 외부의 다른 모듈에서 참조할 때의 결합도
* 공통(공유)(Common) 결합도 : 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
* 내용(Content) 결합도 : 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도

### 응집도(Cohesion)
정보 은닉 개념을 확장한 것으로 명령어나 호출문 등 모듈의 내부 요소들이 서로 관련되어 있는 정도
<br>
즉, __모듈이 독립적인 기능으로 정의되어 있는 정도__
* __응집도가 강할수록 품질이 높고 약할수록 품질이 낮음__

#### 응집도의 종류(강함 -> 약함 순)
* 기능적(Functional) 응집도 : 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도
* 순차적(Sequntial) 응집도 : 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도
* 교환(통신)(Communication) 응집도 : 동일한 입출력을 사용하여 서로 다른 기능을 수행하는 요소들이 모였을 경우의 응집도
* 절차적(Procedural) 응집도 : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도
* 시간적(Temporal) 응집도 : 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
* 논리적(Logical) 응집도 : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
* 우연적(Coincidental) 응집도 : 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도

---

## 공통 모듈
공통 모듈이란 여러 프로그램에서 공통적으로 사용할 수 있는 모듈을 의미
* 자주 사용되는 계산식 또는 매번 필요한 사용자 인증과 같은 기능들이 공통 모듈로 구성 가능
* 모듈의 재사용성 확보, 중복 개발 회피를 위해 설계 과정에서 공통 부분 식별, 명세서 작성 필요

#### 공통 모듈 구현 시 명세 기법
다른 개발자들이 해당 기능을 명확히 이해할 수 있도록 하는 기법
* 정확성(Correctness) : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성
* 명확성(Clarity) : 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성
* 완전성(Completeness) : 시스템 구현 시 필요한 모든 것들 기술
* 일관성(Consistency) : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
* 추적성(Traceability) : 기능에 대한 요구 사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성

### 재사용(Reuse)
재사용이란 이미 개발된 기능들을 파악, 재구성하여 신규 시스템 또는 기능 개발에 사용하기 적합하도록 최적화 시키는 작업
* 비용과 개발 시간을 절약하기 위함
* 재사용을 위해서는 누구나 이해할 수 있고 사용이 가능하도록 사용법 공개
* 재사용되는 대상은 외부 모듈과의 결합도는 낮게, 응집도는 높게

### 효과적인 모듈 설계 방안
* 결합도는 줄이고 응집도는 높여 모듈의 독립성과 재사용성을 높임
* 모듈의 제어 영역 안에서 그 모듈의 영향 영역을 유지
* 복잡도와 중복성을 줄이고 일관성 유지
* 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이면 안 됨
* 유지보수가 용이해야 함
* 모듈 크기는 시스템의 전반적인 기능 및 구조를 이해하기 쉬운 크기로 분해
* 모듈 간의 계층적 관계를 정의하는 자료 제시 필요

---

## 코드(Code)
코드란 분류,조합 및 집ㄱ졔를 용이하게 하고 특정 자료의 추출을 쉽게 하기 위해 사용하는 기호
* 정보를 신속-정확-명료하게 전달할 수 있게 함
* 일반적인 코드로 주민등록번호, 학번, 전화번호 등이 있음

### 코드의 주요 기능
* 식별 기능 : 데이터 간의 성격에 따라 구분 가능
* 분류 기능 : 특정 기준 또는 동일한 유형에 해당하는 데이터 그룹화 가능
* 배열 기능 : 의미를 부여하여 나열 가능
* 표준화 기능 : 다양한 데이터를 기준에 맞추어 표현 가능
* 간소화 기능 : 복잡한 데이터를 간소화 가능

### 코드의 종류
* 순차(Sequence) 코드 : 시료의 발생 순서, 크기 순서 등 일정 기준에 따라 최초의 자료부터 일련번호를 부여하는 방법
  * 일련번호 코드라고도 함
  * Ex) 1, 2, 3, 4 ...
* 블록(Block) 코드 : 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하여 일련번호를 부여하는 방법
  * 구분 코드라고도 함
  * Ex) 1001 ~ 1100 : 총무부, 1101 ~ 1200 : 영업부 등
* 10진(Decimal) 코드 : 대상 항목을 0 ~ 9 까지 10진 분할 후 다시 각각 10할 분할하는 방법
  * 도서 분류식 코드라고도 함
  * Ex) 1000 : 공학, 1100 : 소프트웨어 공학, 1110 : 소프트웨어 설계 등...
* 그룹 분류(Group Classification) 코드 : 일정 기준에 따라 대분류, 중분류, 소분류로 구분하여 각 그룹 안에서 일련번호를 부여하는 방법
  * Ex) 1-01-001 : 본사-총무부-인사계, 2-01-001 : 지사-총무부-인사계 등
*연상(Mnemonic) 코드 : 대상 항목의 명칭이나 약호와 관계있는 숫자, 문자, 기호 등을 이용하여 코드를 부여하는 방법
  * Ex) TV-40 : 40인치, TV, L-15-220 : 15W 220V의 램프
* 표의 숫자(Significant Digit) 코드 : 길이, 넓이, 부피, 지름, 높이 등과 같이 물리적 수치를 그대로 코드에 적용하는 방법
  * 유효 숫자코드라고도 함
  * Ex )120-720-1500 : 두께 x 폭 x 길이가 120 x 720 x 1500인 강판
* 합성(Combined) 코드 : 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법
  * 연상코드 + 순차코드
  * Ex) KE-711 : 대한항공 711기, AC-253 : 에어캐나다 253기

--- 


## 디자인 패턴(Design Pattern)
디자인 패턴이란 각 모듈의 세분화된 역할이나 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 <b>설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제</b>를 의미한다.
* 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성되어 있음
* 개발 과정 중 문제가 생길 경우 새 해결책 강구보다는 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 효율적
* GoF의 디자인 패턴은 유형에 따라 <b>생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴</b>으로 구성

### 디자인 패턴 사용의 장단점

#### 장점
* 범용적인 코딩 스타일로 인해 구조 파악 용이
* 객체지향 설계 및 구현의 생산성을 높이는데 적합
* 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약
* 개발자 간 원활한 의사소통 가능
* 설계 변경 요청에 대한 유연한 대처 가능

#### 단점
* 초기 투자 비용이 부담될 수 있음
* 객체지향을 기반으로 한 설계와 구현을 다루므로 다른 기반의 애플리케이션에 개발에 적합하지 않음

### 생성(Creational) 패턴
생성 패턴이란 <b>객체의 생성과 관련된 패턴</b>으로 총 5개의 패턴이 존재한다.
<br>
객체의 생성과 참조 과정을 캡슐화 하여 객체가 생성 및 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 <b>프로그램에 유연성을 더하는 것</b>
* 추상 팩토리(Abstract Factory) 패턴
  * 구체적인 <b>클래스에 의존하지 않고, 인터페이스를 통해 서로 연관 및 의존하는 객체들의 그룹으로 생성</b>하여 추상적으로 표현
  * 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능
* 빌더(Builder) 패턴
  * 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성
  * <b>객체의 생성 과정과 표현 방법을 분리하고 있어 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼</b> 수 있음
* 팩토리 메소드(Factory Method) 패턴
  * <b>객체 생성을 서브 클래스에서 처리</b>하도록 분리하여 캡슐화한 패턴
  * <b>상위 클래스에서 인터페이스만 정의, 실제 생성은 서브 클래스가 담당</b>
  * 가상 생성자(Virtual Constructor) 패턴이라고도 함
* 프로토타입(Prototype) 패턴
  * 원본 객체를 복제하는 방법으로, 객체를 생성하는 패턴
  * 일반적인 방법으로 객체를 생성하여 비용이 큰 경우 주료 이용
* 싱글톤(Singleton) 패턴
  * <b>하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만</b> 여러 프로세스가 동시에 참조할 수 없음
  * 클래스 내에서 인스턴스가 하나뿐임을 보장
  * 불필요한 메모리 낭비 최소화 가능
  
### 구조(Structural) 패턴
구조 패턴은 클래스나 객체들을 조합하여 더 큰 구조로 맏늘 수 있게 해주는 패턴으로, <b>총 7개의 패턴</b>이 있다.
<br>
구조 패턴은 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.
* 어댑터(Adapter) 패턴
  * 호환성이 없는 클래스들의 인터페이스를 <b>다른 클래스가 이용할 수 있도록 변환</b>해주는 패턴
  * 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용
* 브리지(Bridge) 패턴
  * 구현부에서 <b>추상층을 분리, 서로가 독립적으로 확장</b>할 수 있도록 구성한 패턴
  * <b>기능과 구현을 두 개의 별도 클래스</b>로 구현
* 컴포지트(Composite) 패턴
  * 여러 객체를 <b>가진 복합 객체와 단일 객체를 구분없이 다루고자 할 때 사용</b>하는 패턴
  * <b>객체들을 트리 구조로 구성</b>하여 복합 객체 안에 복합 객체가 포함되는 구조 구현 가능
* 데코레이터(Decorator) 패턴
  * <b>객체 간 결합을 통해 능동적으로 기능을 확장</b>할 수 있는 패턴
  * 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체를 덧붙이는 방식으로 구현
* 퍼싸드(Facade) 패턴
  * 복잡한 서브 클래스들을 피해 상위에 인터페이스를 구현
  * <b>서브 클래스들의 기능을 편하게 사용</b>할 수 있도록 하는 패턴
  * 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요
* 플라이웨이트(Flyweight) 패턴
  * <b>인스턴스를 공유해서 사용함으로써 메모리를 절약</b>하는 패턴
  * 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용 가능
* 프록시(Proxy) 패턴
  * <b>접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할</b>을 수행하는 패턴
  * 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용

### 행위(Behavioral) 패턴
행위 패턴은 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로 <b>총 11개의 패턴</b>이 있다.
<br>
행위 패턴은 <b>하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화</b> 할 수 있도록 도와준다.
* 책임 연쇄(Chain of Responsi-bility) 패턴
  * <b>요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태</b>의 패턴
  * 요청을 처리할 수 있는 각 객체들이 고리(Chain)으로 묶여 있어 요청 해결 까지 고리를 따라 책임이 넘어감
* 커맨드(Command) 패턴
  * 요청을 객체의 형태로 캡슐화하여 <b>재이용 및 취소할 수 있도록 요청에 필요한 정보를 저장 또는 로그에 남기는</b> 패턴
  * 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함
* 인터프리터(Interpreter) 패턴
  * <b>언어에 문법 표현을 정의하는 패턴</b>
  * SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용
* 반복자(Iterator) 패턴
  * 자료 구조와 같이 <b>접근이 잦은 객체에 대해 동일한 인터페이스를 사용</b>하도록 하는 패턴
  * 내부 표현 방법의 노출 없이 순차적인 접근이 가능
* 중재자(Mediator)
  * 수많은 <b>객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의</b>하는 패턴
  * 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있음
* 메멘토(Memento)
  * <b>객체 내부 상태를 객체화함</b>으로써 요청에 따라 <b>객체를 해당 시점의 상태로 돌릴 수</b> 있는 기능을 제공하는 패턴
  * Ctrl + Z 와 같은 되돌리기 기능을 개발할 때 주로 사용
* 옵서버(Observer) 패턴
  * 한 <b>객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달</b>하는 패턴
  * 주로 분산된 시스템 간 이벤트 생성 및 발행 하고 이를 수신해야 할 때 이용
* 상태(State) 패턴
  * <b>객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용</b>하는 패턴
  * 객체 상태를 캡슐화, 이를 참조하는 방식으로 처리
* 전략(Strategy) 패턴
  * 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
  * 클라이언트는 독립적으로 원하는 알고리즘 선택 및 변경이 가능
* 템플릿 메소드(Template Method) 패턴
  * <b>상위 클래스에서 골격 정의, 하위 클래스에서 세부 처리를 구체화</b>하는 구조 패턴
  * 유사한 서브 클래스 내용을 묶어 상위 클래스에서 정의
  * 코드의 양을 줄이고 유지보수를 용이하게 해줌
* 방문자(Visitor) 패턴
  * 각 클래스들의 데이터 구조에서 처리 기능을 분리, 별도의 클래스로 구성하는 패턴
  * 분리된 처리 기능은 각 클래스를 방문(Visit)하여 수행
  
--- 

## 인터페이스 요구사항 검증 방법

### 요구사항 검토(Requirements Review)
요구사항 명세서의 오류 확인 및 표준 준수 여부 등을 결함 여부를 검토, 담당자들이 수작업으로 분석하는 방법을 말함
<br>
동료검토, 워크스루, 인스펙션 등 3가지 방법이 있음
* 동료 검토(Peer Review)
  * 요구사항 명세서 작성자가 명세서 내용을 직접 설명
  * 동료들이 <b>이를 들으면서 결함을 발견</b>하는 형태의 검토 방법
* 워크 스루(Walk Through)
  * 검토 회의 전 요구사항 명세서를 미리 배포하여 사전 검토
  * 이후 <b>검토 회의를 통해 결함을 발견</b>하는 형태의 검토 방법
* 인스펙션(Inspection)
  * 요구사항 <b>명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서 확인하면서 결함을 발견</b>하는 방법
  
#### 프로토타이핑(Prototyping)
* 사용자의 요구사항을 정확히 파악하기 위해 실제 개발된 소프트웨어대한 견본품을 만들어 최종 결과물 예측

#### 테스트 설계
* 요구사항은 테스트할 수 있도록 테스트 케이스(Test Case) 생성 필요
* 요구사항이 현실적으로 테스트 가능한지 검토

#### CASE 도구 활용
* 일관성 분석(Consistency Analysis)을 통해 변경사항의 추적 및 분석, 관리, 표준 준수 여부 확인

### 인터페이스 방법 명세
* DB Link : DB에서 제공하는 DB Link 객체를 이용하는 방식
* API/Open API : 송신 시스템의 데이터베이스를 읽어와 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램
* 연계 솔루션 : EAI 서버와 송수신 시스템에 설치되는 클라이언트를 이용하는 방식
* Socket : 통신을 위한 소켓을 생성하여 포트 할당, 클라이언트의 통신 요청 시 연결하는 통신 네트워크 기술
* Web Service : 웹서브시에서 WSDL, UDDI, SOAP 프로토콜을 이용하여 연계하는 서비스

### 인터페이스 매커니즘 구성요소
* 송신 시스템 : 연계 프로그램으로부터 생성된 데이터를 전송 형식에 맞게 인터페이스 테이블 또는 파일로 변환 후 송신하는 시스템
* 수신 시스템 : 수신한 인터페이스 테이블이나 파일을 연계 프로그램에서 처리할 수 있는 형식으로 변환 후 연계 프로그램에 반영하는 시스템
* 연계 서버 : 송수신 시스템 사이에 위치하여 데이터의 송수신 현황을 모니터링하는 역할 수행

---

## 미들웨어(Middleware)
미들웨어란 미들(Miidle)과 소프트웨어(Software)의 합성어이다.
<br>
<b>운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어</b>를 말한다.

### 미들웨어의 종류
* DB(DataBase)
  * DB는 데이터베이스 밴더에서 제공하는 <b>클라이언트에서 원격의 데이터베이스와 연결하기 위한 미들웨어</b>
  * DB를 사용하여 시스템을 구축하는 경우 2-Tier 아키텍처라고 함
* RPC(Remote Procedure Call) : 원격 프로시저 호출
  * RPC는 응용 프로그램의 프로시저를 이용
  * <b>원격 프로시저를 마치 로컬 프로시저처럼 호출하는 방식의 미들웨어</b>
* MOM(Message Oriented Middleware) : 메시지 지향 미들웨어
  * MOM은 <b>메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어</b>
  * 온라인 업무보다는 <b>이기종 분산 데이터 시스템 데이터 동기를 위해 많이 사용</b>됨
* TP-Monitor(Transaction Processing Monitor) : 트랜잭션 처리 모니터
  * TP는 항공기나 철도 예약 업무 등과 같은 <b>온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어</b>
  * <b>사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무</b>에 주로 사용
* ORB(Object Request Broker) : 객체 요청 브로커
  * ORB는 객체 지향 미들웨어로, <b>코바(CORBA) 표준 스펙을 구현한 미들웨어</b>
  * 최근 Tp-Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음
* WAS(Web Application Server) : 웹 애플리케이션 서버
  * WAS는 정적인 콘텐츠를 처리하는 웹 서버와 달리 <b>사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어</b>
