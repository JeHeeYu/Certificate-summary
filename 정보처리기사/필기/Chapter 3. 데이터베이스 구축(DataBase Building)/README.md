# 데이터베이스 구축 과목 정리 내용

## 데이터베이스 설계

### 데이터베이스 설계 순서
* 요구 조건 분석 : 요구 조건 명세서 작성
* 개념적 설계 : 개념 스키마, 트랜잭션 모델링, E-R 모델
* 논리적 설계 : 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
* 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
* 구현 : 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성

### 개념적 설계(정보 모델링, 개념화)
개념적 설계란 <b>정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해, 현실 세계에 대한 인식을 추상적 개념으로 표현</b>하는 과정
* 개념 설계 단계에서는 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행
* 개념 설계 단계에서는 요구 분석 단계에서 나온 결과인 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성
* DBMS에 독립적인 개념 스키마 설계

### 논리적 설계(데이터 모델)
현실 세계에서 발생하는 <b>자료를 컴퓨터가 이해하고 처리 및 물리적 저장장치에 저장할 수 있도록 자료 구조로 변환(Mapping)</b>시키는 과정 
* 데이터 타입들 간 관계로 표현되는 논리적 구조의 데이터로 모델화
* 개념 스키마를 평가 및 정제, DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계
* 트랜잭션의 인터페이스 설계
* 관계형 데이터베이스라면 테이블을 설계하는 단계

### 물리적 설계(데이터 구조화)
논리적 설계 단계에서 <b>논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환</b>하는 과정
* 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로 결정
* 저장 레코드의 양식, 순서, 접근 경로, 조회가 집중되는 레코드와 같은 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법 묘사
* 물리적 설계 시 고려할 사항 : 트랜잭션 처리량, 응답 시간, 디스크 용량, 저장 공간 등

---

## 데이터 모델(Data Model)
데이터 모델은 현실 세계의 <b>정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형</b>

### 데이터 모델의 구성 요소
* 개체(Entitiy) : <b>데이터베이스에 표현하려는 것</b>으로 현실 세계의 대상체
* 속성(Attribute) : <b>데이터의 가장 작은 논리적 단위</b>로서 데이터 항목 또는 데이터 필드에 해당
* 관계(Relationship) : 개체 간의 <b>관계 또는 속성 간의 논리적 연결을 의미</b>

### 데아터 모델에 표시할 요소
* 구조(Structure) : <b>논리적으로 표현된 개체 타입들 간의 관계</b>로서 데이터 구조 및 정적 성질 표현
* 연산(Operation) : <b>데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세</b>로서 데이터베이스를 조작하는 기본 도구
* 제약 조건(Constraint) : 데이터베이스에 저장될 수 있는 실제 데이터들의 논리적인 제약 조건

### E-R 모델
<b>E-R 모델은 개념적 데이터 모델의 가장 대표</b>적인 것
* 1976년 피터 첸(Peter Chen)에 의해 제안되고 기본적인 구성 요소 정립
* <b>개체 타입과 이들 간의 관계 타입을 이용해 현실 세계를 개념적으로 표현</b>
* 데이터를 개체, 관계, 속성으로 묘사
* 특정 DBMS를 고려한 것은 아님
* E-R 다이어그랭므로 표현할 수 있으며 1:1, 1:N, N:M 등의 관계 유형을 제한없이 나타낼 수 있음

#### E-R 모델 다이어그램
  
![image](https://user-images.githubusercontent.com/87363461/213858380-33a44cd3-620d-4826-b349-87c264368fd3.png)

---
  
## 관계형 데이터 모델
관계형 데이터 모델은 2차원적인 표(Table)를 이용해 데이터 상호 관계를 정의하는 DB 구조를 말함
* 가장 널리 사용되는 데이터 모델
* 파일 구조처럼 구성한 테이블들을 하나의 DB로 묶어 테이블 내에 있는 속성들 간의 관계를 설정하거나 테이블 간의 관계를 설정하여 이용
* 기본키(Primary Key)와 이를 참조하는 외래 키(Foreign Key)로 데이터 간의 관계를 표현
* 계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델
* 관계형 모델의 대표적인 언어는 SQL
* 1:1, 1:N, N:M 관계를 자유롭게 표현할 수 있음

### 관계형 데이터베이스의 Relation 구조
릴레이션은 데이터들을 표(Table)의 형태로 표현한 것
* 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성

### 튜플(Tuple)
* 튜플은 릴레이션을 구성하는 각각의 행
* 튜플의 속성은 모임으로 구성
* 파일 구조에서 레코드와 같은 의미
* 튜플의 수를 카디널리티(Cardinality) 또는 기수, 대응 수 라고도 함

### 속성(Attribute)
* 속성은 데이터베이스를 구성하는 가장 작은 논리적 단위
* 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
* 속성은 개체의 특성을 기술
* 속성의 수를 디그리(Degree) 또는 차수라고 함

### 도메인(Domain)
* 도메인은 하나의 속성(Attribute)가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합
* 도메인의 실제 속성 값이 나타낼 때 그 값의 합법 여부를 시스템이 감시하는데 사용
  * Ex) 성별 속성의 도메인은 '남'과 '여'로 그 이외 값은 입력 불가능


### 릴레이션 특징
* 한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 릴레이션에 포함된 튜플들은 모두 상이함
  * Ex) <학생> 릴레이션을 구성하는 홍길동의 레코드는 홍길동의 대한 학적 사항을 나타내는 것으로 <학생> 릴레이션 내에서 유일함
* 한 릴레이션에 포함될 튜플 사이에는 순서가 없음
  * Ex) <학생> 릴레이션에서 홍길동 레코드와 동길홍 레코드의 위치가 바뀌어도 상관 없음
* 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변함
  * Ex) <학생> 릴레이션에 새로운 학생의 레코드를 삽입하거나 기존 학생에 대한 레코드를 삭제함으로써 테이블의 크기, 내용이 변함
* 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않음
  * Ex) 학번, 이름 등의 속성을 나열하는 순서가 이름, 학번으로 바뀌어도 데이터 처리에 영향을 미치지 않음
* 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수도 있음
  * Ex) 각 학생의 학년 속성인 '학년'은 다른 속성 명들과 구분되어야 하지만, '학년' 속성에는 '1학년', '2학년' 등 동일할 수 있음
* 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로 설정
  * Ex) <학생> 릴레이션에서는 '학번'이나 '이름'이 튜플들을 구분하는 유일한 값이 키가 될 수 있음
* 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자 값만을 저장
  * '학년'에 저장된 1, 2, 4 등은 더 이상 세분화 할 수 없음

---

## 키(Key)
키는 <b>데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플을 구분할 수 있는 기준 속성을 말함</b>
* 후보키(Candidate Key)
  * 기본 키로 사용할 수 있는 속성들을 말함
  * 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 함
* 기본키(Primary Key)
  * 후보키 중 특별히 선정된 주키(Main Key)로 중복된 값을 가질 수 없음
  * 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
  * 기본키는 NULL값을 가질 수 없음
  * 튜플에서는 기본키로 설정된 속성에는 NULL값이 있어서는 안 됨
* 대체키(Alternate Key)
  * 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미
  * 보조키라고도 함
* 슈퍼키(Super Key)
  * 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키
  * 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음
  * 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함
* 외래키(Foreign Key)
  * 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미
  * 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때 속성A를 외래키라고 함

---

## 무결성(Intergrity)
무결성이란 <b>데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미</b>
* 개체 무결성(Entity Intergrity, 실체 무결성) : 기본 테이블의 기본 키를 구성하는 어떤 속성도 NULL 값이나 중복값을 가질 수 없다는 규정
* 도메인 무결성(Domain Intergrity, 영역 무결성) : 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정
* 참조 무결성(Referential Intergirty) : 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
  * 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함
* 사용자 정의 무결성(User-Defined Intergrity) : 속성 값들이 사용자가 정의한 제약조건에 만족해야 한다는 규정

---

## 관계대수
관계대수란 <b>관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해 어떻게 유도하는가를 기술하는 절차적 언어</b>
* 관계대수는 릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공하는 언어
* 피연산자가 릴레이션, 결과도 릴레이션
* 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시
* 관계 데이터베이스에 적용하기 위해 특별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있음
* 순수 관계 연산자 Ex) Select, Project, Join, Division
* 일반 집합 연산자 Ex) UNION(합집합), INTERSECTION(교집합), DIFFERENCE(차집합), CARTESIAN PRODUCT(교차곱)

### 순수 관계 연산자
* Select : 릴레이션에 존재하는 튜플 중 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
  * 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것으로 <b>수평 연산자</b> 이라고도 함
  * 연산자의 기호는 그리스 문자 시그마(σ)를 사용
* Project : 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산
  * 연산 결과에 중복이 발생하면 중복 제거
  * 릴레이션의 열(세로)에 해당하는 Attribute를 추출하는 것으로 <b>수직 연산자</b>라고도 함
  * 연산자의 기호는 그리스 문자 파이(π)를 사용
* Join : 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
  * 연산자의 기호는 ><를 사용
* Division : X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때 R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산
  * 연산자의 기호는 ÷를 사용

### 일반 집합 연산자
* UNION(합집합) : 두 릴레이션에 존재하는 튜플의 합집합을 구하고 결과로 생성된 릴레이션에서 중복되는 튜플은 제거되는 연산
  * 합집합의 카디널리티는 두 릴레이션 카디널리티의 합보다 크지 않음
* INTERSECTION(교집합) : 두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산
  * 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않음
* DIFFERENCE(차집합) : 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산
  * 차집합의 카디널리티는 릴레이션 R의 카디널리티보다 크지 않음
* CARTESIAN PRODUCT(교차곱) : 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산
  * 교차곱의 디그리는 두 릴레이션의 디그리를 더한 것과 같음
  * 교차곱의 카디널리티는 두 릴레이션의 카디널리티를 곱한 것과 같음

### 관계해석(Relational Calculus)
관계해석은 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 <b>술어 해석에 기반을 두고 관계 데이터베이스를 위해 제안</b>
* 관계 데이터의 연산을 표현하는 방법
* 원하는 정보를 정의할 때는 계산 수식을 사용
* 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지님
* 튜플 관계해석과 도메인 관계해석이 있음
* 기본적으로 관계해석과 관계대수는 관계 데이터베이스를 처리하는 기능과 능력 면에서 동등
* * 질의어로 표현
* 관계대수로 표현한 식은 관계해석으로 표현할 수 있음 
  * ∀ : 전칭 정량자로 가능한 모든 튜플에 대함(For All)
  * ∃ : 존재 전량자로 하나의 일치하는 튜플이 있음(There Exists)


---

## 정규화
정규화란 <b>종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어 가는 과정</b>이다.
* 하나의 종속성이 하나의 릴레이션에 포함될 수 있도록 분해해가는 과정
* 제1정규형 ~ 제5정규형, BCNF형 등 차수가 높아질수록 만족시켜야 할 제약 조건이 늘어남
* 정규화는 데이터베이스의 논리적 설계 단계에서 수행
* 정규화는 논리적 처리 및 품질에 큰 영향을 미침
* 정규화된 데이터 모델은 일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장함

### 정규화의 목적
* 데이터 구조의 안정성 및 무결성 유지
* 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만듦
* 효과적인 검색 알고리즘 생성 가능
* 데이터 중복을 배제하여 이상(Anomaly)의 발생 방지 및 자료 저장 공간 최소화 가능
* 데이터 삽입 시 릴레이션을 재구성할 필요을 줄임
* 데이터 모형의 단순화 가능
* 속성의 배열 상태 검증 가능
* 개체와 속성의 누락 여부 확인 가능
* 자료 검색과 추출의 효율성 추구

#### 정규화 과정

![image](https://user-images.githubusercontent.com/87363461/214211103-8a83ab22-ec11-47f4-80fe-c6dc76162be7.png)


### 이상(Anomaly)의 개념 및 종류
이상이란 <b>정규화를 거치지 않은 데이터베이스 내의 데이터들이 불필요하게 중복되어 릴레이션 조작 시 문제가 생기는 현상</b>을 말한다.
<br>
삽입 이상, 삭제 이상, 갱신 이상이 있음
* 삽입 이상 : 릴레이션에 데이터 삽입 시 의도와 상관없이 원하지 않은 값들도 함께 <b>삽입</b>되는 현상
* 삭제 이상 : 릴레이션에서 한 튜플 삭제 시 의도와 상관없는 값들도 함께 삭제되는 <b>연쇄</b>가 일어나는 현상
* 갱신 이상 : 릴레이션에서 튜플에 있는 속성값 갱신 시 일부 튜플의 정보만 갱신되어 정보에 <b>모순</b>이 생기는 현상

---

## 반정규화
반정규화란 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, <b>의도적으로 정규화 원칙을 위반하는 행위</b>를 말한다.
* 반정규화 수행 시 시스템 성능 향상, 관리 효율 증가하지만, 데이터의 일관성 및 정합성이 저하될 수 있음
* 과도한 반정규화는 오히려 성능을 저하시킬 수 있음
* 반정규화를 위해 데이터 일관성과 무결성을 우선 또는 데이터베이스의 성능과 단순화를 우선으로 할지 결정해야 함
* 반정규화 방법에는 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가 등이 있음

### 반정규화 방법
* 테이블 통합
  * 두 개의 테이블이 조인되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행
  * 두 개의 테이블을 이용하여 항상 조회를 수행하는 경우 테이블 통합 고려
* 테이블 분할
  * 테이블을 수직 또는 수평으로 분할하는 것
  * 수평 분할 : 레코드(Record)를 기준으로 테이블을 분할하는 것
  * 수직 분할 : 하나의 테이블 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할하는 것
* 중복 테이블 추가
  * 여러 테이블에서 데이터 추출 또는 다른 서버에 저장된 테이블 이용 시 중복 테이블을 추가하여 작업의 효율성 향상
  * 중복 테이블 추가 방법 : 집계 테이블의 추가, 신행 테이블의 추가, 특정 부분만을 포함하는 테이블의 추가
* 중복 속성 추가
  * 조인해서 데이터를 처리할 때 데이터 조회 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것
  
---

## 시스템 카탈로그
시스템 카탈로그는 <b>시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스</b>를 말한다.
* 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블
* 카탈로그들이 생성되면 데이터 사전에 저장됨 (좁은 의미로 카탈로그를 데이터 사전이라고도 함)
* 시스템 카탈로그에 저장된 정보를 메타 데이터라고 함
* 카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 이용자도 SQL을 이용하여 내용 검색 가능
* INSERT, DELETE, UPDATE문으로 카탈로그 갱신 불가능
* 데이터베이스 시스템에 따라 상이한 구조를 갖음
* 카탈로그는 DBMS가 스스로 생성하고 유지함

### 카탈로그의 갱신
사용자가 SQL문을 실행시켜 기본 테이블, 뷰, 인덱스 등에 변화를 주면 시스템이 자동으로 갱신

### DataDirctory
* 데이터 사전에 수록된 데이터를 실제로 접근하는 데 필요한 정보 관리를 유지하는 시스템
* 시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있지만 데이터 디렉터리는 시스템만 접근 가능

---

## 프랜잭션
트랜잭션이란 <b>데이터베이스의 상태를 변환 시키는 하나의 작업 또는 수행되는 모든 일련의 연산을 의미</b>
* 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용
* 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용

### 트랜잭션의 상태
* 활동(Active) : 트랜잭션이 실행 중인 상태
* 실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태
* 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
* 부분 완료(Paritally Committed) : 트랜잭션을 모두 성공적으로 실행한 후 Commit 연산 실행 직전 상태
* 완료(Committed) : 트랜잭션을 모두 성공적으로 실행한 후 Commit 연산 실행 후 상태

### 트랜잭션의 특성
* 원자성(Atomicity)
  * 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit) 상태 또는 미반영 복구(Rollback)되어야 함
  * 트랜잭션 내의 명령은 반드시 완벽히 수행되어야 함
  * 트랜잭션의 명령이 완벽히 수행되지 않고 어느 하나라도 오류 발생 시 트랜잭션이 전부 취소되어야 함
* 일관성(Consistency)
  * 트랜잭션이 실행을 성공하면 언제나 일관성 있는 데이터베이스 상태로 변환
  * 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 완료 전후 상태가 같아야 함
* 독립성, 격리성, 순차성(Isolation)
  * 둘 이상의 트랜잭션이 동시 병행 수행 시 다른 트랜잭션의 연산에 끼어들 수 없음
  * 수행 중인 트랜잭션은 완전히 완료 전까지 다른 트랜잭션에서 수행 결과 참조 불가능
* 영속성, 지속성(Durability)
  * 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

---

## CRUD(Create Read Update Delete)
CRUD른 생성, 읽기, 갱신, 삭제의 앞 글자만 만든 용어
<br>
* CRUD 분석은 데이터베이스 테이블에 변화를 주는 트랜잭션의 CRUD 연산에 대해 CRUD 매트릭스를 작성하여 분석하는 것
* CRUD 분석으로 테이블에 발생되는 트랜잭션의 주기별 발생 횟수를 파악하여 테이블에 저장되는 데이터의 양 유추 가능

---

## 인덱스(Index)
인덱스는 <b>데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍을 구성하는 데이터 구조</b>
* 데이터가 저장된 물리적 구조와 밀접한 관계가 있음
* 레코드가 저장된 물리적 구조에 접근하는 방법 제공
* 파일의 레코드에 대한 액세스를 빠르게 수행 가능
* 삽입과 삭제가 수시로 일어나는 경우 인덱스의 개수를 최소화하는 것이 효율적
* 데이터 정의어(DDL)를 이용하여 사용자가 생성, 변경, 제거 가능

### 인덱스의 종류
* 트리 기반 인덱스
  * 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것
  * 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용
* 비트맵 인덱스
  * 인덱스 컬럼의 데이터를 Bit 갑싱ㄴ 0 또는 1로 변환하여 인덱스 키로 사용하는 방법
* 함수 기반 인덱스
  * 컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용하는 것
  * B+ 트리 인덱스 또는 비트맵 인덱스를 생성하여 사용
  데이터를 입력 또는 수정 시 함수를 적용해야 하므로 부하가 발생할 수 있음
* 비트맵 조인 인덱스
  * 다수의 조인된 객체로 구성된 인덱스
  * 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다름
* 도메인 인덱스
  * 확장형 인덱스(Extensible Index)라고도 함
  * 개발자가 필요한 인덱스를 직접 만들어 사용하는 것
  
---
  
## 뷰(View)
뷰는 <b>사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 요도된, 이름을 가지는 가상 테이블</b>
* 저장장치 내에 물리적으로 존재하지는 않지만, 사용자에게 있는 것처럼 간주
* 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용됨

### 뷰의 특징
* 기본 테이블과 같은 형태의 구조를 사용하며조작도 기본 테이블과 거이 같음
* 가상 테이블이기 때문에 물리적으로 구현되어 있지 않음
* 데이터의 논리적 독립성을 제공할 수 있음
* 데이터의 논리적 독립성을 제공할 수 있음
* 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해짐
* 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용 가능
* 기본 테이블의 기본 키를 포함한 속성(열) 집합으로 뷰를 구성해야만 CRUD 연산 가능
* 정의된 뷰는 다른 뷰에 정의에 기초가 될 수 있음
* 뷰를 정의할 때는 CREATE, 제거 시 DROP문을 사용

### 뷰의 장단점

#### 장점
* 논리적 데이터 독립성을 제공
* 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용
* 사용자의 데이터 관리를 간단하게 해줌
* 접근 제어를 통한 자동 보안 제공

#### 단점
* 독립적인 인덱스를 가질 수 없음
* 뷰의 정의를 변경할 수 없음
* 뷰로 구성된 내용에 대한 CRUD 연산에 제약이 따름


---

## 파티션(Patition)
데이터베이스에서 파티션은 <b>테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것</b>을 말한다.
* 대용량 DB의 경우 중요한 몇 개의 테이블에만 집중되어 데이터가 증가, 테이블들을 나눠 분산시키면 성능 저하 방지 및 데이터 관리 용이

### 파티션의 종류
* 범위 분할(Range Partitioning)
  * 지정한 열의 값을 기준으로 범위 지정하여 분할
  * Ex) 일별, 월별, 분기별 등
* 해시 분할(Hash Partitioning)
  * 해시 함수를 적용한 결과 값에 따라 데이터 분할
  * 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것 (데이터를 고르게 분산 시 유용)
  * 특정 데이터가 어디에 있는지 판단할 수 없음
  * 고객번호, 주민번호 등과 같이 데이터가 고른 컬럼에 효과적
* 조합 분할(Composite Partitioning)
  * 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식
  * 범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용
* 목록 분할(List Partitioning)
  * 지정한 열 값에 대한 목록을 만들어 이를 기준으로 분할
  Ex) '국가'라는 열에 '한국', '미국', '일본' 이 있는 경우 '미국'을 제외할 목적으로 '아시아'를 만들어 분할
* 라운드 로빈 분할(Round Robin Partitioning)
  * 레코드를 균일하게 분배하는 방식
  * 각 레코드가 순차적으로 분배되며, 기본키가 필요 없음

---

## 분산 데이터베이스
분산 데이터베이스는 논리적으로는 하나의 시스템에 속하지만, 물리적으로 네트워크를 통해 여러 사이트에 분산되어 있는 데이터베이스를 말한다.

### 분산 데이터베이스의 구성 요소
* 분산 처리기 : 자체적으로 처리 능력을 가지며, 지리적으로 분산 되어 있는 컴퓨터 시스템
* 분산 데이터베이스 : 지리적으로 분산되어 있는 데이터베이로서 해당 지역의 특성에 맞게 데이터베이스가 구성됨
* 통신 네트워크 : 분산 처리그들을 통신망으로 연결하여 논리적으로 하나의 시스템처럼 작동할 수 있는 통신 네트워크

### 분산 데이터베이스 목표
* 위치 투명성(Location Transparency)
  * 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 데이터베이스의 논리적인 명칭만으로 액세스 가능
* 중복 투명성(Replication Transparency)
  * 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 하나의 데이터만 존재하는 것처럼 사용
  * 시스템은 자동으로 여러 자료에 대한 작업 수행
* 병행 투명성(Concurrency Transparency)
  * 분산 데이터 베이스와 관련된 다수의 트랜잭션들이 동시에 실현되어도 그 트랜잭션의 결과는 영향을 받지 않음
* 장애 투명성(Failure Transparency)
  * 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리
  
### 분산 데이터베이스의 장단점
* 장점
  * 지역 자치성이 높음
  * 자료의 공유성이 향상됨
  * 분산 제어가 가능함
  * 시스템 성능이 향상됨
  * 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음
  * 효용성과 융통성이 높음
  * 신뢰성 및 가용성이 높음
  * 점진적 시스템 용량 확장 용이
* 단점
  * DBMS가 수행할 기능이 복잡함
  * 데이터베이스 설계가 어려움
  * 처리 비용 증가
  * 잠재적 오류 증가

---

## 암호화(Encryption)
암호화란 데이터를 보낼 때 <b>송신자가 지정한 수신자 외에는 그 내용을 알 수 없도록 평문을 암호문으로 변화하는 것</b>을 말한다.
* 암호화(Encryption) 과정 : 암호화되지 않은 평문을 정보 보호를 위해 암호문으로 바꾸는 과정
* 복호화(Decryption) 과정 : 암호문을 원래의 평문으로 바꾸는 과정

### 개인키 암호 방식(Private Key Encryption) = 비밀키 암호 방식
비밀키 암호화 기법은 동일한 키로 데이터를 암호화하고 복화하는 것
* 대칭 암호 방식 또는 단일키 암호화 기법이라고도 함
* 비밀키는 제 3자에게는 노출시키지 않고 데이터베이스 사용 권한이 있는 사용자만 나누어 가짐
* 종류 : 전위 기법, 대체 기법, 대수 기법, 합성 기법

### 공개키 암호 방식(Public Key Encryption)
공개키 암호화 기법은 서로 다른 키로 데이터를 암호화하고 복화하는 것
* 데이터를 암호화 시 사용하는 키는 데이터베이스 사용자에게 공개
* 복호화 시 키는 관리자가 비밀리에 관리하는 방법
* 비대칭 암호 방식이라고도 하며 대표적으로 RSA(Rivest Shamir Adleman)가 있음

---

## 접근 통제 기술

### 임의 접근 통제(DAC, Discretionary Access Control)
임의 접근통제는 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식을 말한다.
* 데이터 소유자가 접근통제 권한을 지정 및 제어
* 객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받음
* 부여된 권한을 다른 사용자에게 허가할 수 있음
* 임의 접근통제에 사용되는 SQL문으로 GRANT와 REVOKE가 있음
