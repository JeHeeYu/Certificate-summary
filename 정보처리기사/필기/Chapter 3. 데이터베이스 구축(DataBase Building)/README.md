# 데이터베이스 구축 과목 정리 내용

## 데이터베이스 설계

### 데이터베이스 설계 순서
* 요구 조건 분석 : 요구 조건 명세서 작성
* 개념적 설계 : 개념 스키마, 트랜잭션 모델링, E-R 모델
* 논리적 설계 : 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
* 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
* 구현 : 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성

### 개념적 설계(정보 모델링, 개념화)
개념적 설계란 <b>정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해, 현실 세계에 대한 인식을 추상적 개념으로 표현</b>하는 과정
* 개념 설계 단계에서는 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행
* 개념 설계 단계에서는 요구 분석 단계에서 나온 결과인 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성
* DBMS에 독립적인 개념 스키마 설계

### 논리적 설계(데이터 모델)
현실 세계에서 발생하는 <b>자료를 컴퓨터가 이해하고 처리 및 물리적 저장장치에 저장할 수 있도록 자료 구조로 변환(Mapping)</b>시키는 과정 
* 데이터 타입들 간 관계로 표현되는 논리적 구조의 데이터로 모델화
* 개념 스키마를 평가 및 정제, DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계
* 트랜잭션의 인터페이스 설계
* 관계형 데이터베이스라면 테이블을 설계하는 단계

### 물리적 설계(데이터 구조화)
논리적 설계 단계에서 <b>논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환</b>하는 과정
* 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로 결정
* 저장 레코드의 양식, 순서, 접근 경로, 조회가 집중되는 레코드와 같은 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법 묘사
* 물리적 설계 시 고려할 사항 : 트랜잭션 처리량, 응답 시간, 디스크 용량, 저장 공간 등

---

## 데이터 모델(Data Model)
데이터 모델은 현실 세계의 <b>정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형</b>

### 데이터 모델의 구성 요소
* 개체(Entitiy) : <b>데이터베이스에 표현하려는 것</b>으로 현실 세계의 대상체
* 속성(Attribute) : <b>데이터의 가장 작은 논리적 단위</b>로서 데이터 항목 또는 데이터 필드에 해당
* 관계(Relationship) : 개체 간의 <b>관계 또는 속성 간의 논리적 연결을 의미</b>

### 데아터 모델에 표시할 요소
* 구조(Structure) : <b>논리적으로 표현된 개체 타입들 간의 관계</b>로서 데이터 구조 및 정적 성질 표현
* 연산(Operation) : <b>데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세</b>로서 데이터베이스를 조작하는 기본 도구
* 제약 조건(Constraint) : 데이터베이스에 저장될 수 있는 실제 데이터들의 논리적인 제약 조건

### E-R 모델
<b>E-R 모델은 개념적 데이터 모델의 가장 대표</b>적인 것
* 1976년 피터 첸(Peter Chen)에 의해 제안되고 기본적인 구성 요소 정립
* <b>개체 타입과 이들 간의 관계 타입을 이용해 현실 세계를 개념적으로 표현</b>
* 데이터를 개체, 관계, 속성으로 묘사
* 특정 DBMS를 고려한 것은 아님
* E-R 다이어그랭므로 표현할 수 있으며 1:1, 1:N, N:M 등의 관계 유형을 제한없이 나타낼 수 있음

#### E-R 모델 다이어그램
  
![image](https://user-images.githubusercontent.com/87363461/213858380-33a44cd3-620d-4826-b349-87c264368fd3.png)

---
  
## 관계형 데이터 모델
관계형 데이터 모델은 2차원적인 표(Table)를 이용해 데이터 상호 관계를 정의하는 DB 구조를 말함
* 가장 널리 사용되는 데이터 모델
* 파일 구조처럼 구성한 테이블들을 하나의 DB로 묶어 테이블 내에 있는 속성들 간의 관계를 설정하거나 테이블 간의 관계를 설정하여 이용
* 기본키(Primary Key)와 이를 참조하는 외래 키(Foreign Key)로 데이터 간의 관계를 표현
* 계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델
* 관계형 모델의 대표적인 언어는 SQL
* 1:1, 1:N, N:M 관계를 자유롭게 표현할 수 있음

### 관계형 데이터베이스의 Relation 구조
릴레이션은 데이터들을 표(Table)의 형태로 표현한 것
* 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성

### 튜플(Tuple)
* 튜플은 릴레이션을 구성하는 각각의 행
* 튜플의 속성은 모임으로 구성
* 파일 구조에서 레코드와 같은 의미
* 튜플의 수를 카디널리티(Cardinality) 또는 기수, 대응 수 라고도 함

### 속성(Attribute)
* 속성은 데이터베이스를 구성하는 가장 작은 논리적 단위
* 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
* 속성은 개체의 특성을 기술
* 속성의 수를 디그리(Degree) 또는 차수라고 함

### 도메인(Domain)
* 도메인은 하나의 속성(Attribute)가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합
* 도메인의 실제 속성 값이 나타낼 때 그 값의 합법 여부를 시스템이 감시하는데 사용
  * Ex) 성별 속성의 도메인은 '남'과 '여'로 그 이외 값은 입력 불가능


### 릴레이션 특징
* 한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 릴레이션에 포함된 튜플들은 모두 상이함
  * Ex) <학생> 릴레이션을 구성하는 홍길동의 레코드는 홍길동의 대한 학적 사항을 나타내는 것으로 <학생> 릴레이션 내에서 유일함
* 한 릴레이션에 포함될 튜플 사이에는 순서가 없음
  * Ex) <학생> 릴레이션에서 홍길동 레코드와 동길홍 레코드의 위치가 바뀌어도 상관 없음
* 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변함
  * Ex) <학생> 릴레이션에 새로운 학생의 레코드를 삽입하거나 기존 학생에 대한 레코드를 삭제함으로써 테이블의 크기, 내용이 변함
* 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않음
  * Ex) 학번, 이름 등의 속성을 나열하는 순서가 이름, 학번으로 바뀌어도 데이터 처리에 영향을 미치지 않음
* 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수도 있음
  * Ex) 각 학생의 학년 속성인 '학년'은 다른 속성 명들과 구분되어야 하지만, '학년' 속성에는 '1학년', '2학년' 등 동일할 수 있음
* 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로 설정
  * Ex) <학생> 릴레이션에서는 '학번'이나 '이름'이 튜플들을 구분하는 유일한 값이 키가 될 수 있음
* 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자 값만을 저장
  * '학년'에 저장된 1, 2, 4 등은 더 이상 세분화 할 수 없음

---

## 키(Key)
키는 <b>데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플을 구분할 수 있는 기준 속성을 말함</b>
* 후보키(Candidate Key)
  * 기본 키로 사용할 수 있는 속성들을 말함
  * 릴레이션에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 함
* 기본키(Primary Key)
  * 후보키 중 특별히 선정된 주키(Main Key)로 중복된 값을 가질 수 없음
  * 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
  * 기본키는 NULL값을 가질 수 없음
  * 튜플에서는 기본키로 설정된 속성에는 NULL값이 있어서는 안 됨
* 대체키(Alternate Key)
  * 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미
  * 보조키라고도 함
* 슈퍼키(Super Key)
  * 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키
  * 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음
  * 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못함
* 외래키(Foreign Key)
  * 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미
  * 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때 속성A를 외래키라고 함

---

## 무결성(Intergrity)
무결성이란 <b>데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미</b>
* 개체 무결성(Entity Intergrity, 실체 무결성) : 기본 테이블의 기본 키를 구성하는 어떤 속성도 NULL 값이나 중복값을 가질 수 없다는 규정
* 도메인 무결성(Domain Intergrity, 영역 무결성) : 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정
* 참조 무결성(Referential Intergirty) : 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정
  * 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함
* 사용자 정의 무결성(User-Defined Intergrity) : 속성 값들이 사용자가 정의한 제약조건에 만족해야 한다는 규정

---

## 관계대수
관계대수란 <b>관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해 어떻게 유도하는가를 기술하는 절차적 언어</b>
* 관계대수는 릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공하는 언어
* 피연산자가 릴레이션, 결과도 릴레이션
* 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시
* 관계 데이터베이스에 적용하기 위해 특별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자가 있음
* 순수 관계 연산자 Ex) Select, Project, Join, Division
* 일반 집합 연산자 Ex) UNION(합집합), INTERSECTION(교집합), DIFFERENCE(차집합), CARTESIAN PRODUCT(교차곱)

### 순수 관계 연산자
* Select : 릴레이션에 존재하는 튜플 중 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
  * 릴레이션의 행(가로)에 해당하는 튜플을 구하는 것으로 <b>수평 연산자</b> 이라고도 함
  * 연산자의 기호는 그리스 문자 시그마(σ)를 사용
* Project : 주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산
  * 연산 결과에 중복이 발생하면 중복 제거
  * 릴레이션의 열(세로)에 해당하는 Attribute를 추출하는 것으로 <b>수직 연산자</b>라고도 함
  * 연산자의 기호는 그리스 문자 파이(π)를 사용
* Join : 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
  * 연산자의 기호는 ><를 사용
* Division : X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때 R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산
  * 연산자의 기호는 ÷를 사용

### 일반 집합 연산자
* UNION(합집합) : 두 릴레이션에 존재하는 튜플의 합집합을 구하고 결과로 생성된 릴레이션에서 중복되는 튜플은 제거되는 연산
  * 합집합의 카디널리티는 두 릴레이션 카디널리티의 합보다 크지 않음
* INTERSECTION(교집합) : 두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산
  * 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않음
* DIFFERENCE(차집합) : 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산
  * 차집합의 카디널리티는 릴레이션 R의 카디널리티보다 크지 않음
* CARTESIAN PRODUCT(교차곱) : 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산
  * 교차곱의 디그리는 두 릴레이션의 디그리를 더한 것과 같음
  * 교차곱의 카디널리티는 두 릴레이션의 카디널리티를 곱한 것과 같음


---

## 관계해석(Relational Calculus)
관계해석은 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 <b>술어 해석에 기반을 두고 관계 데이터베이스를 위해 제안</b>
* 관계 데이터의 연산을 표현하는 방법
* 원하는 정보를 정의할 때는 계산 수식을 사용
* 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 지님
* 튜플 관계해석과 도메인 관계해석이 있음
* 기본적으로 관계해석과 관계대수는 관계 데이터베이스를 처리하는 기능과 능력 면에서 동등
* * 질의어로 표현
* 관계대수로 표현한 식은 관계해석으로 표현할 수 있음 
  * ∀ : 전칭 정량자로 가능한 모든 튜플에 대함(For All)
  * ∃ : 존재 전량자로 하나의 일치하는 튜플이 있음(There Exists)




