# SQL 응용 과목 정리 내용


# 트랜잭션(:star::star::star:)

## 1. 트랜잭션(Transaction)


### 1-1. 트랜잭션 개념
- **인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야 하는 특성**이자, 데이터베이스 시스템에서 **하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위**를 말함


### 1-2. 트랜잭션 특성

|특성|설명|주요기법|
|:---:|:---|:---:|
|<b>원자성</b>(Atomicity)|- 트랜잭션을 구성하는 연산 전체가 **모두 정상적으로 실행**되거나 **모두 취소**되어야 하는 성질|- Commit/Rollback<br>- 회복성 보장|
|<b>일관성</b>(Consistency)|- 시스템이 가지고 있는 고정요소는 **트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야** 하는 성질|- 무결성 제약조건<br>- 동시성 제어|
|<b>격립성=고립성</b>(Isolation)|- 동시에 실행되는 트랜잭션들이 **서로 영향을 미치지 않아야 한다**는 성질|- Read Uncommitted<br>- Read Committed<br> - Repleatable Read<br>- Serializable|
|<b>영속성</b>(Durability)|- 성공이 완료된 트랜잭션의 결과는 **영송적으로 데이터베이스에 저장되어야 하는** 성질|- 회복기법|


### 1-3. 트랜잭션의 상태 변화

![image](https://user-images.githubusercontent.com/87363461/233035229-8718e213-2505-4b3b-a26f-ea88a26005bb.png)

#### 트랜잭션의 상태 설명

|상태|설명|
|:---:|:---|
|<b>활동 상태</b><br>(Active)|초기 상태, 트랜잭션이 실행 중일 때 가지는 상태|
|<b>부분 완료 상태</b><br>(Partialy Committed)|마지막 명령문이 실행된 후에 가지는 상태|
|<b>완료 상태</b><br>(Committed)|트랜잭션이 성공적으로 완료된 후 가지는 상태|
|<b>실패 상태</b><br>(Failed)|정상적인 실행이 더 이상 진행될 수 없을 때 가지는 상태|
|<b>철회 상태</b><br>(Aborted)|트랜잭션이 취소되고 데이터베이스가 트랜잭션 시작 전 상태로 환원된 상태|



### 1-4. 트랜잭션 제어
- 트랜잭션 제어언어는 TCL(Transaction Control Language)이라고 하며, **트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어**를 지칭함


#### TCL 명령어

|명령어|핵심|설명|
|:---:|:---:|:---|
|<b>커밋</b><br>(COMMIT)|트랜잭션 확정|트랜잭션을 메모리에 영구적으로 저장하는 명령어|
|<b>롤백</b><br>(ROLLBACK)|트랜잭션 취소|트랜잭션 내용을 저장 무효화시키는 명령어|
|<b>체크포인트</b><br>(CHECKPOINT)|저장 시기 설정|ROLLBACK을 위한 시점을 지정하는 명령어|



### 1-5. 병행 제어(Concurrency Control)(일관성 주요 기법)

#### 1. 병행 제어 개념
- 병행 제어는 **다수 사용자 환경에서 여러 트랜잭션을 수행할 때**, 데이터베이스 **일관성 유지를 위해 상호 작용을 제어하는 기법**임

#### 2. 병행 제어의 목적
- 데이터베이스의 공유를 최대화함
- 시스템의 활용도를 최대화함
- 데이터베이스의 일관성을 유지함
- 사용자에 대한 응답시간을 최소화함


#### 3. 병행 제어 미보장 시 문제점

|문제점|설명|
|:---:|:---|
|<b>갱신 손실</b><br>(Lost Update)|먼저 실행된 트랜잭션의 결과를 나중에 실행된 트랜잭션이 덮어쓸 때 발생하는 오류|
|<b>현황 파악오류</b><br>(Dirty Read)|트랜잭션의 중간 수행 결과를 다른 트랜잭션이 참조하여 발생하는 오류|
|<b>모순성</b><br>(Inconsistency)|두 트랜잭션이 동시에 실행되거나 데이터베이스의 일관성이 결여되는 오류|
|<b>연쇄 복귀</b><br>(Cascading<br>Rollback)|복수의 트랜잭션이 데이터 공유 시 특정 트랜잭션이 처리를 취소할 경우 트랜잭션이 처리한 곳의 부분을 취소하지 못하는 오류|


#### 4. 병행 제어 기법의 종류

- **로킹(Locking)**
  - **하나의 트랜잭션을 실행하는 동안** 특정 데이터 항목에 대해서 **다른 트랜잭션이 동시에 접근하지 못하도록 상호 배제(Mutual Exclusion) 기능을 제공**하는 기법
  - 로킹의 특징은 다음과 같음
    - 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음
    - 로킹 단위가 작아지면 데이터베이스 공유도가 증가
    - 로킹 단위가 작아지면 로킹 오버헤드도 증가
    - 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함

- **낙관적 검증(Optimistic Validation)**
  - 트랜잭션이 어떠한 검증도 수행하지 않고 **일단 트랜잭션을 수행하고** 트랜잭션 종료 시 **검증을 수행하여 데이터베이스에 반영하는 기법**
- **타임 스탬프 순서(Time Stamp Ordering)**
  - 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임 스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
- **다중버전 동시성 제어(MVCC, Multi Version Concurrency Control)**
  - 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법


### 1-6. 데이터베이스 고립화 수준(격리성 주요 기법)

#### 1. 고립화 수준(Isolation Level) 개념
- 고립화 수준은 **다른 트랜잭션이 현재의 데이터에 대한 무결성을 해치지 않기 위해 잠금을 설정**하는 정도임

#### 2. 고립화 수준 종류

|수준|설명|
|:---:|:---|
|<b>Read Uncommitted</b>|- 한 트랜잭션에서 연산(갱신) 중인(아직 커밋되지 않은) 데이터를 다른 트랜잭션이 읽는 것을 허용하는 수준<br>- 연산(갱신) 중인 데이터에 대한 연산은 불허|
|<b>Read Committed</b>|- 한 트랜잭션에서 연산(갱신)을 수행할 때, 연산이 완료될 때까지 연산 대상 데이터에 대한 읽기를 제한하는 수준<br>- 연산이 완료되어 커밋된 데이터는 다른 트랜잭션이 읽는 것을 허용|
|<b>Repeatable Read</b>|- 선행 트랜잭션이 특정 데이터를 읽을 때, 트랜잭션 종료 시까지 해당 데이터에 대한 갱신 및 삭제를 제한하는 수준|
|<b>Serializable Read</b>|- 선행 트랜잭션이 특정 데이터 영역을 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근 제한하는 수준|

### 1-7. 회복 기법(영속성 주요 기법)


#### 1. 회복 기법(Recovery) 개념
- 회복 기법은 트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업임

#### 2. 회복 기법 종류

- 데이터베이스 회복을 위한 주요 요소로 REDO, UNDO가 있음

|구분|설명|
|:---:|:---|
|<b>REDO</b>|- 데이터베이스가 비정상적으로 종료되었을 때 디스크에 저장된 로그를 분석하여 트랜잭션의 시작(Start)과 완료(Commit)에 대한 기록이 있는 트랜잭션들의 작업을 재작업하는 기법<br>- 데이터베이스 내용 자체가 손상된 경우, 가장 최근의 복제본을 적재한 후 이후 일어난 변경만을 로그를 이용하여 재실행함으로써 데이터베이스를 복원하는 기법|
|<b>UNDO</b>|- 데이터베이스가 비정상적으로 종료되었을 때 디스크에 저장된 로그를 분석하여 트랜잭션의 시작(Start)은 있지만, 완료(Commit) 기록이 없는 트랜잭션들이 작업한 변경 내용들을 모두 취소하는 기법<br>- 데이터베이스 내용 자체는 손상되지 않았지만, 변경 중이거나 변경된 내용에 대한 신뢰성을 잃어버린 경우, 모든 변경 내용을 취소하여 복원하는 기법|


- 회복 기법 종류로 로그 기반 회복 기법, 체크 포인트 회복 기법, 그림자 페이징 회복 기법이 있음


#### 회복 기법 종류

|기법|설명|
|:---:|:---|
|<b>로그 기반<br>회복 기법</b>|- 지연 갱신 회복 기법과 즉각 갱신 회복 기법이 있음<br>- 지연 갱신 회복 기법 : 트랜잭션이 완료되기 전까지 데이터베이스에 기록하지 않는 기법<br>- 즉각 갱신 회복 기법 : 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영하는 기법|
|<b>체크 포인트<br>회복 기법</b><br>(Checkpoint<br>Recovery)|- 장애 발생 시 검사점 이후에 처리된 트랜잭션에 대해서만 장애 발생 이전의 상태로 복원시키는 회복 기법|
|<b>그림자 페이징<br>회복 기법</b><br>(Shadow Paging<br>Recovery)|- 데이터베이스 트랜잭션 수행 시 복제본을 생성하여 데이터베이스 장애 시 이를 이용해 복구하는 기법|


## 2. DDL(Data Definition Language)

### 1. 데이터 정의어(DDL)의 개념

- 데이터 정의어는 데이터를 정의하는 언어로서 '**데이터를 담는 그릇을 정의하는 언어**'이다.
- 테이블과 같은 데이터 구조를 정의하는 데 사용되는 명령어들로 **특정 구조를 생성, 변경, 삭제, 이름을 바꾸는 데이터 구조와 관련된 명령어들을 데이터 정의어**라고 부름

### 2. DDL의 대상

- **도메인(Domain)**
  - 하나의 속성이 가질 수 있는 원자값들이 집합
  - 속성의 데이터 타입과 크기, 제약조건 등의 정보
- **스키마(Schema)**
  - 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
  - 스키마는 외부/개념/내부 3계층으로 구성되어 있음
  - **외부 스키마(External Schema)**
    - 사용자나 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조
    - **사용자 뷰**를 나타냄
    - 서브 스키마로 불림
  - **개념 스키마(Conceptual Schema)**
    - 데이터베이스의 전체적인 논리적 구조
    - **전체적인 뷰**를 나타냄
    - 개체 간의 관계, 제약조건, 접근 권한, 무결성, 보안에 대해 정의
  - **내부 스키마(Internal Schema)**
    - 물리적 저장 장치의 관점에서 보는 데이터베이스 구조
    - 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 표현
- **테이블(Table)**
  - 데이터 저장 공간
- **뷰(View)**
  - 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
- **인덱스(Index)**
  - 검색을 빠르게 하기 위한 데이터 구조


#### 1. 테이블(Table)

#### 테이블의 개념
- 테이블은 데이터를 저장하는 항목인 **필드(Field)들로 구성된 데이터의 집합체**
- 하나의 DB 내에 여러 개의 테이블로 구성될 수 있고, **릴레이션(Relation) 혹은 엔티티(Entity)라고도** 불림

#### 테이블의 용여

![image](https://user-images.githubusercontent.com/87363461/233052174-97451d10-4d4d-4c10-b2f9-aaf2c03a838c.png)

|용어|설명|
|:---:|:---|
|튜플(Tuple)<br>행(Row)|- 테이블 내의 행을 의미하며 레코드(Record)라고도 함<br>- 튜플은 릴레이션(Relation)에서 같은 값을 가질 수 없음|
|애트리뷰트(Attribute)<br>열(Column)|- 테이블 내의 열을 의미<br>- 열의 개수를 디그리(Degree)라고 함|
|식별자(Identifier)|- 여러 개의 집합체를 담고 있는 관계형 데이터베이스에서 각각의 구분할 수 있는 논리적인 개념|
|카디널리티(Cardinality)|- 튜플(Tuple)의 개수|
|차수(Degree)|- 애트리뷰트(Attribute)의 개수
|도메인(Domain)|- 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값 들의 집합|

#### 2. 뷰(View)

#### 뷰의 개념
- 뷰는 논리 테이블로서 **사용자에게 테이블과 동일**함
- 아래 그림에서 '테이블 A'와 '테이블 B'는 물리 테이블을 의미하고, '뷰 C'는 두 개의 테이블을 이용하여 생성한 뷰를 의미함

![image](https://user-images.githubusercontent.com/87363461/233053135-cee56415-e5c5-4e4f-8c39-cb2e63bf0b22.png)

- 뷰는 '테이블 A'와 같은 하나의 물리 테이블로부터 생성 가능하며, 다수의 테이블 또는 다른 뷰를 이용해 만들 수 있음
- 뷰와 같은 결과를 만들기 위해 조인 기능을 활용할 수 있으나 뷰가 만들어져 있다면 사용자는 조인 없이 하나의 테이블을 대상으로 하는 단순한 질의어를 사용할 수 있음


#### 뷰의 특징
|특징|설명|
|:---:|:---|
|<b>논리적 데이터<br>독립성 제공</b>|데이터베이스에 영향을 주지 않고 애플리케이션이 원하는 형태로 데이터에 접근 가능|
|<b>데이터 조작<br>연산 간소화</b>|애프릴케이션이 원하는 형태의 논리적 구조를 형성하여 데이터 조작 연산을 간소화<br>- 예) 회원 테이블에서 우수 회원을 뷰로 생성하여 활용|
|<b>보안 기능<br>(접근제어) 제공</b>|특정 필드만을 선택해 뷰를 생성할 경우 애플리케이션은 선택되지 않은 필드의 조회 및 접근 불가|
|<b>뷰 변경 불가</b>|뷰 정의는 ALTER 문을 이용하여 변경할 수 있음<br>(뷰는 CREATE 문을 사용하여 정의, 뷰를 제거할 때에는 DROP 문을 사용)|

#### 뷰의 목적
- 뷰를 사용하는 주된 이유는 **단순 질의어를 사용할 수 있기 때문**임
- FROM 절에 있는 하나의 뷰를 통해 뷰를 구성하는 복수의 테이블을 대체하는 단순성에 그 의이가 있음
- 테이블의 중요 데이터 일부만을 제공할 수 있는 장단점이 있음

#### 뷰의 장단점

- **장점**
  - **논리적 독립성 제공**
    - 뷰는 논리 테이블(테이블의 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 됨)
  - **사용자 데이터 관리 용이**
    - 복수 테이블에 존재하는 여러 종류의 데이터에 대해 단순한 질의어 사용이 가능
  - **데이터 보안이 용이**
    - 중요 보안 데이터를 저장 중인 테이블에는 접근 불허
    - 해당 테이블의 일부 정보만을 볼 수 있는 뷰에는 접근을 허용
    - 보안 데이터에 대한 접근 제어 가능
- **단점**
  - **뷰 자체 인덱스 불가**
    - 인덱스는 물리적으로 저장된 데이터를 대상으로 하기에 논리적 구성인 뷰 자체는 인덱스를 가지지 못함
  - **뷰 정의 변경 불가**
    - 뷰의 정의를 변경하려면 뷰를 삭제하고 재생성
  - **데이터 변경 제약 존재**
    - 뷰의 내용에 대한 삽입, 삭제, 변경 제약이 있음


#### 3. 인덱스(Index)

#### 인덱스의 개념
- 인덱스는 검색 연산의 최적화를 위해 데이터베이스 내 값에 대한 **주소 정보로 구성된 데이터 구조**임
- 인덱스는 데이터를 빠르게 찾을 수 있는 수단으로서, 테이블에 대한 조회 속도를 높여 주는 자료 구조임
- 인덱스는 테이블의 특정 레코드 위치를 알려 주는 용도로 사용함

![image](https://user-images.githubusercontent.com/87363461/233055694-e685770d-5308-4359-a2a4-1f6f7de850c7.png)


#### 인덱스의 특징
- 기본 키(PK, Primary Key) 컬럼은 자동으로 인덱스가 생성됨
- 연월일이나 이름을 기준으로 하는 인덱스는 자동으로 생성되지 않음
- 테이블의 컬럼에 인덱스가 없는 경우, 테이블의 전체 내용을 검색함(테이블 전체 스캔 Table Full Scan)
- 조건절에 '='로 비교되는 컬럼을 대상으로 인덱스를 생성하면 검색 속도를 높일 수 있음

#### 인덱스의 종류

|유형|설명|
|:---:|:---|
|<b>순서 인덱스</b><br>(Ordered Index)|- 데이터가 정렬된 순서로 생성되는 인덱스<br>- B-Tree 알고리즘 활용(오름차순/내림차순 지정 가능)|
|<b>해시 인덱스</b><br>(Hash Index)|- 해시 함수에 의해 직접 데이터케 기 값으로 접근하는 인덱스<br>- 데이터 접근 비용이 균일, 튜플(Row) 양에 무관|
|<b>비트맵 인덱스</b><br>(Bitmap Index)|- 각 컬럼에 적은 개수 값이 저장된 경우 선택하는 인덱스<br>- 수정 변경이 적을 경우 유용(생년월일, 상품번호 등)|
|<b>함수기반 인덱스</b><br>(Functional Index)|- 수식이나 함수를 적용하여 만든 인덱스|
|<b>단일 인덱스</b><br>(Singled Index)|- 하나의 컬럼으로만 구성한 인덱스<br>- 주 사용 컬럼이 하나일 경우 사용|
|<b>결합 인덱스</b><br>(Concatenated Index)|- 두 개 이상의 컬럼으로 구성한 인덱스<br>- WHERE 조건으로 사용하는 빈도가 높은 경우 사용|
|<b>클러스터드 인덱스</b><br>(Clustered Index)|- 기본 키(PK) 기준으로 레코드를 묶어서 저장하는 인덱스<br>- 저장 데이터의 물리적 순서에 따라 인덱스가 생성<br>- 특정 범위 검색 시 유리함|



### 2-3. DDL 명령어

|구분|명령어|설명|
|:---:|:---:|:---|
|<b>생성</b>|<b>CREATE</b>|데이터베이스 오브젝트 생성 명령어|
|<b>수정</b>|<b>ALTER</b>|데이터베이스 오브젝트 변경 명령어|
|<b>삭제</b>|<b>DROP</b>|데이터베이스 오브젝트 삭제 명령어|
|<b>삭제</b>|<b>TRUNCATE</b>|데이터베이스 오브젝트 내용 삭제 명령어|


### 2-4. TABLE 관련 DDL

#### 1. CREATE TABLE

- CREATE TABLE은 테이블을 생성하는 명령어임
- CREATE TABLE에서 하나의 컬럼(속성)에 대해 '컬럼명 데이터타입 제약조건'으로 구성됨

#### CREATE TABLE 문법

```
CREATE TABLE 테이블명
(
    컬럼명 데이터타입 PRIMARY KEY, -- 기본키 설정
	  컬럼명 데이터타입 FOREIGN KEY REFERENCES 참조테이블(기본키), -- 외래키 설정
    컬럼명 데이터타입 UNIQUE,
    컬럼명 데이터타입 NOT NULL,
    컬럼명 데이터타입 CHECK(조건식), -- 제약조건 설정
    컬럼명 데이터타입 DEFAULT 값
);
```


#### CREATE TABLE 예제
```
CREATE TABLE
(
    사번 VARCHAR(10) PRIMARY KEY,
    업무 VARCHAR(20) FOREIGN KEY REFERENCES 부서(부서코드),
    이름 VARCHAR(10) UNIQUE,
    생년월일 CHAR(10) NOT NULL,
    성별 CHAR(1) CHECK (성별 = 'M' OR 성별 = 'F'),
    입사일 DATE DEFAULT SYSTEM -- SYSDATE는 현재시간/날짜
);
```

- CREATE TABLE에 들어갈 수 있는 제약조건으로 기본 키, 외래 키, UNIQUE, NOT NULL, CHECK, DEFAULT가 있음

#### CREATE TABLE 제약 조건

|제약 조건|설명|
|:---:|:---|
|<b>PRIMARY KEY</b>|- 테이블의 기본 키 정의<br>- 유일하게 테이블의 각 행을 식별|
|<b>FOREIGN KEY</b>|- 외래 키를 정의<br>- 참조 대상을 테이블(컬럼명)로 명시<br>- 열과 참조된 테이블 열 사이의 외래 키 관계를 적용하고 설정|
|<b>UNIQUE</b>|- 테이블 내에서 얻은 유일한 값을 갖도록 하는 제약조건|
|<b>NOT NULL</b>|- 해당 컬럼은 NULL 값을 포함하지 않도록 하는 제약조건|
|<b>CHECK</b>|- 개발자가 정의하는 제약조건<br>- 참(TRUE)이어야 하는 조건을 지정|
|<b>DEFAULT</b>|- 데이터를 INSERT 할 때 해당 컬럼의 값을 넣지 않는 경우 기본값으로 설정해주는 제약조건|


#### 2. ALTER TABLE
- ALTER TABLE은 테이블을 수정하는 명령어임

#### ALTER TABLE 컬럼 추가
- 테이블에 필요한 컬럼을 추가하는 문법임
- CREATE TABLE 컬럼에 사용되는 제약조건인 PRIMARY KEY, POREIGN KEY, UNIQUE, NOT NULL, CHECK, DEFAULT를 ALTER TABLE에서도 사용할 수 있음



#### ALTER TABLE 컬럼 추가 문법

```
ALTER TABLE 테이블명 ADD 컬럼명 데이터타입 [제약조건];

// 예제
ALTER TABLE 사원 ADD 전화번호 VARCHAR(11) UNIQUE;

- 사원 테이블에 전화번호라는 컬럼에 대해 타입이 VARCHAR(11)이면서 UNIQUE 제약조건을 걸도록 추가
```


#### ALTER TABLE 컬럼 수정
- 테이블에 필요한 컬럼을 수정하는 문법임
- 테이블 생성을 위한 CREATE 문에 제약조건을 명시 후에 ALTER를 통해 테이블 제약조건의 변경이 가능함

#### ALTER TABLE 컬럼 수정 문법

```
ALTER TABLE 테이블명 MODIFY 컬럼명 데이터타입 [제약조건];

// 예제
ALTER TABLE 사원 MODIFY 이름 VARCHAR(30) NOT NULL;

- 사원 테이블의 이름이라는 컬럼에 대해 타입이 VARCHAR(30)이면서 NOT NULL 제약조건을 걸도록 수정
```

#### ALTER TABLE 컬럼 삭제
- 테이블에 필요한 컬럼을 삭제하는 문법

#### ALTER TABLE 컬럼 삭제 문법

```
ALTER TABLE 테이블명 DROP COLUMN 컬럼명;

// 예제
ALTER TABLE 사원 DROP COULMN 생년월일;

- 사원 테이블에 생년월일이라는 컬럼 삭제
```

#### 3. DROP TABLE
- DROP TABLE은 테이블을 삭제하는 명령어

#### DROP TABLE 문법

```
DROP TABLE 테이블명 [CASECAE | RESTRICT];

// 예제
DROP TABLE 사원;

- 사원 테이블 삭제
```

- DROP TABLE 명령어의 옵션에는 CASCADE와 RESTRICT가 있음
- CASCADE와 RESTRICT의 경우 외래 키(FOREIGN KEY)가 걸려 있을 때 해당함

#### DROP TABLE 명령어 옵션

|옵션|설명|
|:---:|:---|
|<b>CASCADE</b>|참조하는 테이블까지 연쇄적으로 제거하는 옵션|
|<b>RESTRICT</b>|다른 테이블이 삭제할 테이블을 참조 중이면 제거하지 않는 옵션|

#### 4. TRUNCATE TABLE
- TRUNCATE TABLE은 테이블 내의 데이터들을 삭제하는 명령어

#### TRUNCATE TABLE 문법

```
TRUNCATE TABLE 테이블명;

// 예제
TRUNCATE TABLE 사원;

- 사원 테이블 내의 모든 데이터 삭제
```

### 2-5. VIEW 관련 DDL

#### 1. CREATE VIEW
- CREATE VIEW는 뷰를 생성하는 명령어임

#### CREATE VIEW 문법

```
CREATE VIEW 뷰이름 AS
조회쿼리;

// 예제
CREATE VIEW 사원 AS
SELECT 사번, 이름
    FROM 사원
WHERE 성별 = 'M';

- 사원 테이블에서 성별 값이 'M'을 가진 사번, 이름으로 생성된 사원뷰라는 이름의 뷰 생성
```

- VIEW 테이블의 SELECT 문에는 UNION이나 ORDER BY절을 사용할 수 없음
- 컬럼명을 기술하지 않으면 SELECT 문의 컬럼명이 자동으로 사용됨


#### 2. CREATE OR REPLACE VIEW
- CREATE OR REPLACE VIEW는 뷰를 교체하는 명령어임
- OR REPLACE라는 키워드를 추가하는 것을 제외하고는 CREATE VIEW와 사용 방법이 동일함

#### CREATE OR REPLACE VIEW 기본 문법

```
CREATE OR REPLACE VIEW 뷰이름 AS
조회쿼리;
```

#### 3. DROP VIEW
- DROP VIEW는 뷰를 삭제하는 명령어

#### DROP VIEW 기본문법

```
DROP VIEW 뷰이름;
```


### 2-6. INDEX 관련 DDL

#### 1. CREATE INDEX

- CREATE INDEX는 인덱스를 생성하는 명령어
- UNIQUE는 생략 가능, 인덱스 걸린 컬럼에 중복 값을 허용하지 않음
- 복수 컬럼은 인덱스로 걸 수 있음


#### CREATE INDEX 문법

```
CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명1, 컬럼명2 ...);

// 예제
CREATE INDEX 사번인덱스 ON 사원(사번);

- 사원 테이블의 사번 컬럼에 대해 사번인덱스라는 인덱스 명으로 인덱스 생성
```


#### 2. ALTER INDEX
- ALTER INDEx는 인덱스를 수정하는 명령어
- 일부 DBMS는 ALTER INDEX를 제공하지 않음
- 기존 인덱스를 삭제하고 신규 인덱스를 생성하는 방식으로 사용 권고

#### ALTER INDEX 문법

```
ALTER [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명1, 컬럼명2 ...);

// 예제
ALTER INDEX 사번인덱스 ON 사원(시번);

- 사원 테이블의 사번 컬럼에 대해 사번인덱스 라는 인덱스 명으로 인덱스 수정
```

#### 3. DROP INDEX
- DROP INDEX는 인덱스를 삭제하는 명령어

#### DROP INDEX 문법

```
DROP INDEX 인덱스명

// 예제
DROP INDEX 사번인덱스;

- 사번인덱스 라는 인덱스 명을 가지고 있는 인덱스 삭제
```

## 3. 데이터 조작어(DML, Data Manipulation Language)

### 3-1. 데이터 조작어 개념
- 데이터 조작어는 데이터베이스에 저장된 자료들을 입력, 수정, 삭제, 조회하는 언어
