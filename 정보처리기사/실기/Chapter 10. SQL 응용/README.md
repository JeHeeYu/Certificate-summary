# SQL 응용 과목 정리 내용


# 트랜잭션(:star::star::star:)

## 1. 트랜잭션(Transaction)


### 1-1. 트랜잭션 개념
- **인가받지 않은 사용자로부터 데이터를 보장하기 위해 DBMS가 가져야 하는 특성**이자, 데이터베이스 시스템에서 **하나의 논리적 기능을 정상적으로 수행하기 위한 작업의 기본 단위**를 말함


### 1-2. 트랜잭션 특성

|특성|설명|주요기법|
|:---:|:---|:---:|
|<b>원자성</b>(Atomicity)|- 트랜잭션을 구성하는 연산 전체가 **모두 정상적으로 실행**되거나 **모두 취소**되어야 하는 성질|- Commit/Rollback<br>- 회복성 보장|
|<b>일관성</b>(Consistency)|- 시스템이 가지고 있는 고정요소는 **트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야** 하는 성질|- 무결성 제약조건<br>- 동시성 제어|
|<b>격립성=고립성</b>(Isolation)|- 동시에 실행되는 트랜잭션들이 **서로 영향을 미치지 않아야 한다**는 성질|- Read Uncommitted<br>- Read Committed<br> - Repleatable Read<br>- Serializable|
|<b>영속성</b>(Durability)|- 성공이 완료된 트랜잭션의 결과는 **영송적으로 데이터베이스에 저장되어야 하는** 성질|- 회복기법|


### 1-3. 트랜잭션의 상태 변화

![image](https://user-images.githubusercontent.com/87363461/233035229-8718e213-2505-4b3b-a26f-ea88a26005bb.png)

#### 트랜잭션의 상태 설명

|상태|설명|
|:---:|:---|
|<b>활동 상태</b><br>(Active)|초기 상태, 트랜잭션이 실행 중일 때 가지는 상태|
|<b>부분 완료 상태</b><br>(Partialy Committed)|마지막 명령문이 실행된 후에 가지는 상태|
|<b>완료 상태</b><br>(Committed)|트랜잭션이 성공적으로 완료된 후 가지는 상태|
|<b>실패 상태</b><br>(Failed)|정상적인 실행이 더 이상 진행될 수 없을 때 가지는 상태|
|<b>철회 상태</b><br>(Aborted)|트랜잭션이 취소되고 데이터베이스가 트랜잭션 시작 전 상태로 환원된 상태|



### 1-4. 트랜잭션 제어
- 트랜잭션 제어언어는 TCL(Transaction Control Language)이라고 하며, **트랜잭션의 결과를 허용하거나 취소하는 목적으로 사용되는 언어**를 지칭함


#### TCL 명령어

|명령어|핵심|설명|
|:---:|:---:|:---|
|<b>커밋</b><br>(COMMIT)|트랜잭션 확정|트랜잭션을 메모리에 영구적으로 저장하는 명령어|
|<b>롤백</b><br>(ROLLBACK)|트랜잭션 취소|트랜잭션 내용을 저장 무효화시키는 명령어|
|<b>체크포인트</b><br>(CHECKPOINT)|저장 시기 설정|ROLLBACK을 위한 시점을 지정하는 명령어|



### 1-5. 병행 제어(Concurrency Control)(일관성 주요 기법)

#### 1. 병행 제어 개념
- 병행 제어는 **다수 사용자 환경에서 여러 트랜잭션을 수행할 때**, 데이터베이스 **일관성 유지를 위해 상호 작용을 제어하는 기법**임

#### 2. 병행 제어의 목적
- 데이터베이스의 공유를 최대화함
- 시스템의 활용도를 최대화함
- 데이터베이스의 일관성을 유지함
- 사용자에 대한 응답시간을 최소화함


#### 3. 병행 제어 미보장 시 문제점

|문제점|설명|
|:---:|:---|
|<b>갱신 손실</b><br>(Lost Update)|먼저 실행된 트랜잭션의 결과를 나중에 실행된 트랜잭션이 덮어쓸 때 발생하는 오류|
|<b>현황 파악오류</b><br>(Dirty Read)|트랜잭션의 중간 수행 결과를 다른 트랜잭션이 참조하여 발생하는 오류|
|<b>모순성</b><br>(Inconsistency)|두 트랜잭션이 동시에 실행되거나 데이터베이스의 일관성이 결여되는 오류|
|<b>연쇄 복귀</b><br>(Cascading<br>Rollback)|복수의 트랜잭션이 데이터 공유 시 특정 트랜잭션이 처리를 취소할 경우 트랜잭션이 처리한 곳의 부분을 취소하지 못하는 오류|


#### 4. 병행 제어 기법의 종류

- **로킹(Locking)**
  - **하나의 트랜잭션을 실행하는 동안** 특정 데이터 항목에 대해서 **다른 트랜잭션이 동시에 접근하지 못하도록 상호 배제(Mutual Exclusion) 기능을 제공**하는 기법
  - 로킹의 특징은 다음과 같음
    - 데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있음
    - 로킹 단위가 작아지면 데이터베이스 공유도가 증가
    - 로킹 단위가 작아지면 로킹 오버헤드도 증가
    - 한꺼번에 로킹할 수 있는 객체의 크기를 로킹 단위라고 함

- **낙관적 검증(Optimistic Validation)**
  - 트랜잭션이 어떠한 검증도 수행하지 않고 **일단 트랜잭션을 수행하고** 트랜잭션 종료 시 **검증을 수행하여 데이터베이스에 반영하는 기법**
- **타임 스탬프 순서(Time Stamp Ordering)**
  - 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임 스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
- **다중버전 동시성 제어(MVCC, Multi Version Concurrency Control)**
  - 트랜잭션의 타임스탬프와 접근하려는 데이터의 타임스탬프를 비교하여 직렬가능성이 보장되는 적절한 버전을 선택하여 접근하도록 하는 기법


### 1-6. 데이터베이스 고립화 수준(격리성 주요 기법)

#### 1. 고립화 수준(Isolation Level) 개념
- 고립화 수준은 **다른 트랜잭션이 현재의 데이터에 대한 무결성을 해치지 않기 위해 잠금을 설정**하는 정도임

#### 2. 고립화 수준 종류

|수준|설명|
|:---:|:---|
|<b>Read Uncommitted</b>|- 한 트랜잭션에서 연산(갱신) 중인(아직 커밋되지 않은) 데이터를 다른 트랜잭션이 읽는 것을 허용하는 수준<br>- 연산(갱신) 중인 데이터에 대한 연산은 불허|
|<b>Read Committed</b>|- 한 트랜잭션에서 연산(갱신)을 수행할 때, 연산이 완료될 때까지 연산 대상 데이터에 대한 읽기를 제한하는 수준<br>- 연산이 완료되어 커밋된 데이터는 다른 트랜잭션이 읽는 것을 허용|
|<b>Repeatable Read</b>|- 선행 트랜잭션이 특정 데이터를 읽을 때, 트랜잭션 종료 시까지 해당 데이터에 대한 갱신 및 삭제를 제한하는 수준|
|<b>Serializable Read</b>|- 선행 트랜잭션이 특정 데이터 영역을 순차적으로 읽을 때, 해당 데이터 영역 전체에 대한 접근 제한하는 수준|

### 1-7. 회복 기법(영속성 주요 기법)


#### 1. 회복 기법(Recovery) 개념
- 회복 기법은 트랜잭션을 수행하는 도중 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 작업임

#### 2. 회복 기법 종류

- 데이터베이스 회복을 위한 주요 요소로 REDO, UNDO가 있음

|구분|설명|
|:---:|:---|
|<b>REDO</b>|- 데이터베이스가 비정상적으로 종료되었을 때 디스크에 저장된 로그를 분석하여 트랜잭션의 시작(Start)과 완료(Commit)에 대한 기록이 있는 트랜잭션들의 작업을 재작업하는 기법<br>- 데이터베이스 내용 자체가 손상된 경우, 가장 최근의 복제본을 적재한 후 이후 일어난 변경만을 로그를 이용하여 재실행함으로써 데이터베이스를 복원하는 기법|
|<b>UNDO</b>|- 데이터베이스가 비정상적으로 종료되었을 때 디스크에 저장된 로그를 분석하여 트랜잭션의 시작(Start)은 있지만, 완료(Commit) 기록이 없는 트랜잭션들이 작업한 변경 내용들을 모두 취소하는 기법<br>- 데이터베이스 내용 자체는 손상되지 않았지만, 변경 중이거나 변경된 내용에 대한 신뢰성을 잃어버린 경우, 모든 변경 내용을 취소하여 복원하는 기법|


- 회복 기법 종류로 로그 기반 회복 기법, 체크 포인트 회복 기법, 그림자 페이징 회복 기법이 있음


#### 회복 기법 종류

|기법|설명|
|:---:|:---|
|<b>로그 기반<br>회복 기법</b>|- 지연 갱신 회복 기법과 즉각 갱신 회복 기법이 있음<br>- 지연 갱신 회복 기법 : 트랜잭션이 완료되기 전까지 데이터베이스에 기록하지 않는 기법<br>- 즉각 갱신 회복 기법 : 트랜잭션 수행 중 갱신 결과를 바로 DB에 반영하는 기법|
|<b>체크 포인트<br>회복 기법</b><br>(Checkpoint<br>Recovery)|- 장애 발생 시 검사점 이후에 처리된 트랜잭션에 대해서만 장애 발생 이전의 상태로 복원시키는 회복 기법|
|<b>그림자 페이징<br>회복 기법</b><br>(Shadow Paging<br>Recovery)|- 데이터베이스 트랜잭션 수행 시 복제본을 생성하여 데이터베이스 장애 시 이를 이용해 복구하는 기법|


## 2. DDL(Data Definition Language)

### 1. 데이터 정의어(DDL)의 개념

- 데이터 정의어는 데이터를 정의하는 언어로서 '**데이터를 담는 그릇을 정의하는 언어**'이다.
- 테이블과 같은 데이터 구조를 정의하는 데 사용되는 명령어들로 **특정 구조를 생성, 변경, 삭제, 이름을 바꾸는 데이터 구조와 관련된 명령어들을 데이터 정의어**라고 부름

### 2. DDL의 대상

- **도메인(Domain)**
  - 하나의 속성이 가질 수 있는 원자값들이 집합
  - 속성의 데이터 타입과 크기, 제약조건 등의 정보
- **스키마(Schema)**
  - 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조
  - 스키마는 외부/개념/내부 3계층으로 구성되어 있음
  - **외부 스키마(External Schema)**
    - 사용자나 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조
    - **사용자 뷰**를 나타냄
    - 서브 스키마로 불림
  - **개념 스키마(Conceptual Schema)**
    - 데이터베이스의 전체적인 논리적 구조
    - **전체적인 뷰**를 나타냄
    - 개체 간의 관계, 제약조건, 접근 권한, 무결성, 보안에 대해 정의
  - **내부 스키마(Internal Schema)**
    - 물리적 저장 장치의 관점에서 보는 데이터베이스 구조
    - 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 표현
- **테이블(Table)**
  - 데이터 저장 공간
- **뷰(View)**
  - 하나 이상의 물리 테이블에서 유도되는 가상의 테이블
- **인덱스(Index)**
  - 검색을 빠르게 하기 위한 데이터 구조


#### 1. 테이블(Table)

#### 테이블의 개념
- 테이블은 데이터를 저장하는 항목인 **필드(Field)들로 구성된 데이터의 집합체**
- 하나의 DB 내에 여러 개의 테이블로 구성될 수 있고, **릴레이션(Relation) 혹은 엔티티(Entity)라고도** 불림

#### 테이블의 용여

![image](https://user-images.githubusercontent.com/87363461/233052174-97451d10-4d4d-4c10-b2f9-aaf2c03a838c.png)

|용어|설명|
|:---:|:---|
|튜플(Tuple)<br>행(Row)|- 테이블 내의 행을 의미하며 레코드(Record)라고도 함<br>- 튜플은 릴레이션(Relation)에서 같은 값을 가질 수 없음|
|애트리뷰트(Attribute)<br>열(Column)|- 테이블 내의 열을 의미<br>- 열의 개수를 디그리(Degree)라고 함|
|식별자(Identifier)|- 여러 개의 집합체를 담고 있는 관계형 데이터베이스에서 각각의 구분할 수 있는 논리적인 개념|
|카디널리티(Cardinality)|- 튜플(Tuple)의 개수|
|차수(Degree)|- 애트리뷰트(Attribute)의 개수
|도메인(Domain)|- 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값 들의 집합|

#### 2. 뷰(View)

#### 뷰의 개념
- 뷰는 논리 테이블로서 **사용자에게 테이블과 동일**함
- 아래 그림에서 '테이블 A'와 '테이블 B'는 물리 테이블을 의미하고, '뷰 C'는 두 개의 테이블을 이용하여 생성한 뷰를 의미함

![image](https://user-images.githubusercontent.com/87363461/233053135-cee56415-e5c5-4e4f-8c39-cb2e63bf0b22.png)

- 뷰는 '테이블 A'와 같은 하나의 물리 테이블로부터 생성 가능하며, 다수의 테이블 또는 다른 뷰를 이용해 만들 수 있음
- 뷰와 같은 결과를 만들기 위해 조인 기능을 활용할 수 있으나 뷰가 만들어져 있다면 사용자는 조인 없이 하나의 테이블을 대상으로 하는 단순한 질의어를 사용할 수 있음


#### 뷰의 특징
|특징|설명|
|:---:|:---|
|<b>논리적 데이터<br>독립성 제공</b>|데이터베이스에 영향을 주지 않고 애플리케이션이 원하는 형태로 데이터에 접근 가능|
|<b>데이터 조작<br>연산 간소화</b>|애프릴케이션이 원하는 형태의 논리적 구조를 형성하여 데이터 조작 연산을 간소화<br>- 예) 회원 테이블에서 우수 회원을 뷰로 생성하여 활용|
|<b>보안 기능<br>(접근제어) 제공</b>|특정 필드만을 선택해 뷰를 생성할 경우 애플리케이션은 선택되지 않은 필드의 조회 및 접근 불가|
|<b>뷰 변경 불가</b>|뷰 정의는 ALTER 문을 이용하여 변경할 수 있음<br>(뷰는 CREATE 문을 사용하여 정의, 뷰를 제거할 때에는 DROP 문을 사용)|

#### 뷰의 목적
- 뷰를 사용하는 주된 이유는 **단순 질의어를 사용할 수 있기 때문**임
- FROM 절에 있는 하나의 뷰를 통해 뷰를 구성하는 복수의 테이블을 대체하는 단순성에 그 의이가 있음
- 테이블의 중요 데이터 일부만을 제공할 수 있는 장단점이 있음

#### 뷰의 장단점

- **장점**
  - **논리적 독립성 제공**
    - 뷰는 논리 테이블(테이블의 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 됨)
  - **사용자 데이터 관리 용이**
    - 복수 테이블에 존재하는 여러 종류의 데이터에 대해 단순한 질의어 사용이 가능
  - **데이터 보안이 용이**
    - 중요 보안 데이터를 저장 중인 테이블에는 접근 불허
    - 해당 테이블의 일부 정보만을 볼 수 있는 뷰에는 접근을 허용
    - 보안 데이터에 대한 접근 제어 가능
- **단점**
  - **뷰 자체 인덱스 불가**
    - 인덱스는 물리적으로 저장된 데이터를 대상으로 하기에 논리적 구성인 뷰 자체는 인덱스를 가지지 못함
  - **뷰 정의 변경 불가**
    - 뷰의 정의를 변경하려면 뷰를 삭제하고 재생성
  - **데이터 변경 제약 존재**
    - 뷰의 내용에 대한 삽입, 삭제, 변경 제약이 있음


#### 3. 인덱스(Index)

#### 인덱스의 개념
- 인덱스는 검색 연산의 최적화를 위해 데이터베이스 내 값에 대한 **주소 정보로 구성된 데이터 구조**임
- 인덱스는 데이터를 빠르게 찾을 수 있는 수단으로서, 테이블에 대한 조회 속도를 높여 주는 자료 구조임
- 인덱스는 테이블의 특정 레코드 위치를 알려 주는 용도로 사용함

![image](https://user-images.githubusercontent.com/87363461/233055694-e685770d-5308-4359-a2a4-1f6f7de850c7.png)


#### 인덱스의 특징
- 기본 키(PK, Primary Key) 컬럼은 자동으로 인덱스가 생성됨
- 연월일이나 이름을 기준으로 하는 인덱스는 자동으로 생성되지 않음
- 테이블의 컬럼에 인덱스가 없는 경우, 테이블의 전체 내용을 검색함(테이블 전체 스캔 Table Full Scan)
- 조건절에 '='로 비교되는 컬럼을 대상으로 인덱스를 생성하면 검색 속도를 높일 수 있음

#### 인덱스의 종류

|유형|설명|
|:---:|:---|
|<b>순서 인덱스</b><br>(Ordered Index)|- 데이터가 정렬된 순서로 생성되는 인덱스<br>- B-Tree 알고리즘 활용(오름차순/내림차순 지정 가능)|
|<b>해시 인덱스</b><br>(Hash Index)|- 해시 함수에 의해 직접 데이터케 기 값으로 접근하는 인덱스<br>- 데이터 접근 비용이 균일, 튜플(Row) 양에 무관|
|<b>비트맵 인덱스</b><br>(Bitmap Index)|- 각 컬럼에 적은 개수 값이 저장된 경우 선택하는 인덱스<br>- 수정 변경이 적을 경우 유용(생년월일, 상품번호 등)|
|<b>함수기반 인덱스</b><br>(Functional Index)|- 수식이나 함수를 적용하여 만든 인덱스|
|<b>단일 인덱스</b><br>(Singled Index)|- 하나의 컬럼으로만 구성한 인덱스<br>- 주 사용 컬럼이 하나일 경우 사용|
|<b>결합 인덱스</b><br>(Concatenated Index)|- 두 개 이상의 컬럼으로 구성한 인덱스<br>- WHERE 조건으로 사용하는 빈도가 높은 경우 사용|
|<b>클러스터드 인덱스</b><br>(Clustered Index)|- 기본 키(PK) 기준으로 레코드를 묶어서 저장하는 인덱스<br>- 저장 데이터의 물리적 순서에 따라 인덱스가 생성<br>- 특정 범위 검색 시 유리함|



### 2-3. DDL 명령어

|구분|명령어|설명|
|:---:|:---:|:---|
|<b>생성</b>|<b>CREATE</b>|데이터베이스 오브젝트 생성 명령어|
|<b>수정</b>|<b>ALTER</b>|데이터베이스 오브젝트 변경 명령어|
|<b>삭제</b>|<b>DROP</b>|데이터베이스 오브젝트 삭제 명령어|
|<b>삭제</b>|<b>TRUNCATE</b>|데이터베이스 오브젝트 내용 삭제 명령어|


### 2-4. TABLE 관련 DDL

#### 1. CREATE TABLE

- CREATE TABLE은 테이블을 생성하는 명령어임
- CREATE TABLE에서 하나의 컬럼(속성)에 대해 '컬럼명 데이터타입 제약조건'으로 구성됨

#### CREATE TABLE 문법

```
CREATE TABLE 테이블명
(
    컬럼명 데이터타입 PRIMARY KEY, -- 기본키 설정
	  컬럼명 데이터타입 FOREIGN KEY REFERENCES 참조테이블(기본키), -- 외래키 설정
    컬럼명 데이터타입 UNIQUE,
    컬럼명 데이터타입 NOT NULL,
    컬럼명 데이터타입 CHECK(조건식), -- 제약조건 설정
    컬럼명 데이터타입 DEFAULT 값
);
```


#### CREATE TABLE 예제
```
CREATE TABLE
(
    사번 VARCHAR(10) PRIMARY KEY,
    업무 VARCHAR(20) FOREIGN KEY REFERENCES 부서(부서코드),
    이름 VARCHAR(10) UNIQUE,
    생년월일 CHAR(10) NOT NULL,
    성별 CHAR(1) CHECK (성별 = 'M' OR 성별 = 'F'),
    입사일 DATE DEFAULT SYSTEM -- SYSDATE는 현재시간/날짜
);
```

- CREATE TABLE에 들어갈 수 있는 제약조건으로 기본 키, 외래 키, UNIQUE, NOT NULL, CHECK, DEFAULT가 있음

#### CREATE TABLE 제약 조건

|제약 조건|설명|
|:---:|:---|
|<b>PRIMARY KEY</b>|- 테이블의 기본 키 정의<br>- 유일하게 테이블의 각 행을 식별|
|<b>FOREIGN KEY</b>|- 외래 키를 정의<br>- 참조 대상을 테이블(컬럼명)로 명시<br>- 열과 참조된 테이블 열 사이의 외래 키 관계를 적용하고 설정|
|<b>UNIQUE</b>|- 테이블 내에서 얻은 유일한 값을 갖도록 하는 제약조건|
|<b>NOT NULL</b>|- 해당 컬럼은 NULL 값을 포함하지 않도록 하는 제약조건|
|<b>CHECK</b>|- 개발자가 정의하는 제약조건<br>- 참(TRUE)이어야 하는 조건을 지정|
|<b>DEFAULT</b>|- 데이터를 INSERT 할 때 해당 컬럼의 값을 넣지 않는 경우 기본값으로 설정해주는 제약조건|


#### 2. ALTER TABLE
- ALTER TABLE은 테이블을 수정하는 명령어임

#### ALTER TABLE 컬럼 추가
- 테이블에 필요한 컬럼을 추가하는 문법임
- CREATE TABLE 컬럼에 사용되는 제약조건인 PRIMARY KEY, POREIGN KEY, UNIQUE, NOT NULL, CHECK, DEFAULT를 ALTER TABLE에서도 사용할 수 있음



#### ALTER TABLE 컬럼 추가 문법

```
ALTER TABLE 테이블명 ADD 컬럼명 데이터타입 [제약조건];

// 예제
ALTER TABLE 사원 ADD 전화번호 VARCHAR(11) UNIQUE;

- 사원 테이블에 전화번호라는 컬럼에 대해 타입이 VARCHAR(11)이면서 UNIQUE 제약조건을 걸도록 추가
```


#### ALTER TABLE 컬럼 수정
- 테이블에 필요한 컬럼을 수정하는 문법임
- 테이블 생성을 위한 CREATE 문에 제약조건을 명시 후에 ALTER를 통해 테이블 제약조건의 변경이 가능함

#### ALTER TABLE 컬럼 수정 문법

```
ALTER TABLE 테이블명 MODIFY 컬럼명 데이터타입 [제약조건];

// 예제
ALTER TABLE 사원 MODIFY 이름 VARCHAR(30) NOT NULL;

- 사원 테이블의 이름이라는 컬럼에 대해 타입이 VARCHAR(30)이면서 NOT NULL 제약조건을 걸도록 수정
```

#### ALTER TABLE 컬럼 삭제
- 테이블에 필요한 컬럼을 삭제하는 문법

#### ALTER TABLE 컬럼 삭제 문법

```
ALTER TABLE 테이블명 DROP COLUMN 컬럼명;

// 예제
ALTER TABLE 사원 DROP COULMN 생년월일;

- 사원 테이블에 생년월일이라는 컬럼 삭제
```

#### 3. DROP TABLE
- DROP TABLE은 테이블을 삭제하는 명령어

#### DROP TABLE 문법

```
DROP TABLE 테이블명 [CASECAE | RESTRICT];

// 예제
DROP TABLE 사원;

- 사원 테이블 삭제
```

- DROP TABLE 명령어의 옵션에는 CASCADE와 RESTRICT가 있음
- CASCADE와 RESTRICT의 경우 외래 키(FOREIGN KEY)가 걸려 있을 때 해당함

#### DROP TABLE 명령어 옵션

|옵션|설명|
|:---:|:---|
|<b>CASCADE</b>|참조하는 테이블까지 연쇄적으로 제거하는 옵션|
|<b>RESTRICT</b>|다른 테이블이 삭제할 테이블을 참조 중이면 제거하지 않는 옵션|

#### 4. TRUNCATE TABLE
- TRUNCATE TABLE은 테이블 내의 데이터들을 삭제하는 명령어

#### TRUNCATE TABLE 문법

```
TRUNCATE TABLE 테이블명;

// 예제
TRUNCATE TABLE 사원;

- 사원 테이블 내의 모든 데이터 삭제
```

### 2-5. VIEW 관련 DDL

#### 1. CREATE VIEW
- CREATE VIEW는 뷰를 생성하는 명령어임

#### CREATE VIEW 문법

```
CREATE VIEW 뷰이름 AS
조회쿼리;

// 예제
CREATE VIEW 사원 AS
SELECT 사번, 이름
    FROM 사원
WHERE 성별 = 'M';

- 사원 테이블에서 성별 값이 'M'을 가진 사번, 이름으로 생성된 사원뷰라는 이름의 뷰 생성
```

- VIEW 테이블의 SELECT 문에는 UNION이나 ORDER BY절을 사용할 수 없음
- 컬럼명을 기술하지 않으면 SELECT 문의 컬럼명이 자동으로 사용됨


#### 2. CREATE OR REPLACE VIEW
- CREATE OR REPLACE VIEW는 뷰를 교체하는 명령어임
- OR REPLACE라는 키워드를 추가하는 것을 제외하고는 CREATE VIEW와 사용 방법이 동일함

#### CREATE OR REPLACE VIEW 기본 문법

```
CREATE OR REPLACE VIEW 뷰이름 AS
조회쿼리;
```

#### 3. DROP VIEW
- DROP VIEW는 뷰를 삭제하는 명령어

#### DROP VIEW 기본문법

```
DROP VIEW 뷰이름;
```


### 2-6. INDEX 관련 DDL

#### 1. CREATE INDEX

- CREATE INDEX는 인덱스를 생성하는 명령어
- UNIQUE는 생략 가능, 인덱스 걸린 컬럼에 중복 값을 허용하지 않음
- 복수 컬럼은 인덱스로 걸 수 있음


#### CREATE INDEX 문법

```
CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명1, 컬럼명2 ...);

// 예제
CREATE INDEX 사번인덱스 ON 사원(사번);

- 사원 테이블의 사번 컬럼에 대해 사번인덱스라는 인덱스 명으로 인덱스 생성
```


#### 2. ALTER INDEX
- ALTER INDEx는 인덱스를 수정하는 명령어
- 일부 DBMS는 ALTER INDEX를 제공하지 않음
- 기존 인덱스를 삭제하고 신규 인덱스를 생성하는 방식으로 사용 권고

#### ALTER INDEX 문법

```
ALTER [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명1, 컬럼명2 ...);

// 예제
ALTER INDEX 사번인덱스 ON 사원(시번);

- 사원 테이블의 사번 컬럼에 대해 사번인덱스 라는 인덱스 명으로 인덱스 수정
```

#### 3. DROP INDEX
- DROP INDEX는 인덱스를 삭제하는 명령어

#### DROP INDEX 문법

```
DROP INDEX 인덱스명

// 예제
DROP INDEX 사번인덱스;

- 사번인덱스 라는 인덱스 명을 가지고 있는 인덱스 삭제
```

## 3. 데이터 조작어(DML, Data Manipulation Language)

### 3-1. 데이터 조작어 개념
- 데이터 조작어는 데이터베이스에 저장된 자료들을 입력, 수정, 삭제, 조회하는 언어



### 3-2. DML 명령어
- 데이터 조작어 명령어의 유형으로 SELECT, INSERT, UPDATE, DELETE가 있음

#### DML 유형

|유형|동작|설명|
|:---:|:---:|:---|
|<b>SELECT</b>|<b>조회</b>|테이블 내 컬럼에 저장된 데이터를 조회|
|<b>INSERT</b>|<b>삽입</b>|테이블 내 컬럼에 테이블을 추가|
|<b>UPDATE</b>|<b>갱신</b>|테이블 내 컬럼에 저장된 데이터를 수정|
|<b>DELETE</b>|<b>삭제</b>|테이블 내 컬럼에 저장된 데이터를 삭제|

### 3-3. SELECT(데이터 조회) 명령어

#### 1. SELECT 명령어 개념
- SELECT 명령어는 데이터의 내용을 조회할 때 사용하는 명령어
- SELECT 명령어는 SELECT 절, FROM 절, WHERE 절, GROUP BY 절, HAVING 절, ORDER BY 절로 구성됨

```
SELECT [All | DISTINCT] 속성명1, 속성명2...
    FROM 테이블명1, ...
[WHERE 조건]
[GROUP BY 속성명1, ...]
[HAVING 그룹조건]
[ORDER BY 속성 [ASC | DESC] ];
```

#### SELECT 명령어

|구분|설명|
|:---:|:---|
|<b>SELECT</b>|- 검색하고자 하는 속성명, 계산식을 기술<br>- 속성명 별칭은 AS를 사용하여 생략 가능<br>- 2개 이상의 테이블을 대상으로 검색할 때는 '테이블명.속성명'으로 표현<br>-술어 부분은 ALL과 DISTINCT가 있으며 ALL이 기본값<br>- ALL : 모든 튜플을 검색할 때 사용하며 SELECT 뒤에 명시하지 않는 경우 ALL로 인식<br>- DISTINCT : 중복된 속성이 조회될 경우 그 중에 한 개만 검색|
|<b>FROM</b>|- 질의에 의해 검색될 데이터들을 포함하는 테이블명 기술|
|<b>GROUP BY</b>|- 속성값을 그룹으로 분류하고자 할 때 사용|
|<b>HAVING</b>|- GROUP BY에 의해 분류한 후 그룹에 대한 조건 지정|
|<b>ORDER BY</b>|- 속성값을 정렬하고자 할 때 사용 (ASC : 오름차순, DESC : 내림차순)<br>- ASC, DESC 키워드 생략 시 오름차순(ASC) 정렬|


#### SELECT 
- SELECT 절은 테이블에서 출력한 컬럼을 명시하기 위해 사용함

#### SELECT 예제
- 아래 테이블은 성적 테이블이라고 했을 때 쿼리 및 결과는 다음과 같음

- 성적 테이블
|이름|과목|학점|
|:---:|:---:|:---:|
|김철수|C언어|A|
|한유리|자료구조|A|
|신짱구|자료구조|A|
|이훈이|알고리즘|B|

- 성적 테이블에 대해 쿼리와 쿼리 결과는 다음과 같음

```
SELECT 과목
    FROM 성적;

// 출력 결과
과목
C언어
자료구조
자료구조
알고리즘

- 성적 테이블에서 과목을 모두 출력
```

```
SELECT DISTINCT 과목
    FROM 성적;

// 출력 결과
과목
C언어
자료구조
알고리즘

- 성적 테이블에서 과목 중에 중복된 값을 제거하여 출력
```

```
SELECT 과목
    FROM 성적
WHERE 학점 = 'A'

// 출력 결과
과목
C언어
자료구조
자료구조

- 성적 테이블에서 학점이 'A'인 과목을 모두 출력
```

```
SELECT DISTINCT 과목
    FROM 성적
WHERE 학점 ='A'

// 출력 결과
과목
C언어
자료구조

- 성적 테이블에서 과목 중에 중복된 값을 제거하여 출력
```

```
SELECT COUNT(DISTINCT 과목)
    FROM 성적;

// 출력 결과
COUNT(DISTINCT 과목)
3

- 성적 테이블에서 과목 중에 중복된 값을 제거한 튜플의 갯수 출력
```

```
SELECT DISTINCT 과목, 학점
    FROM 성적;

// 출력 결과
 과목     학점
C언어      A 
자료구조  A
알고리즘  B
```

#### WHERE
- WHERE은 조건에서는 비교, 범위, 집합, 패턴, NULL, 복합조건이 있음


#### WHERE 문법

- **비교**
  - =
    - 값이 같은 경우 조회
  - <>, !=
    - 값이 다른 경우 조회
  - <, <=, >, >= 
    - 비교 연산에 해당하는 데이터 조회
- **범위**
  - BETWEEN
    - 컬럼 BETWWEN 값1 AND 값2
    - 값1보다 크거나 같고, 값2보다 작거나 같은 데이터 조회
    - 아래와 동일한 결과
    - 컬럼 >= 값1 AND 컬럼 <= 값2
- **집합**
  - IN
    - 컬럼 IN (값1, 값2 ...)
    - 컬럼이 IN 안에 포함된 경우의 데이터 조회
  - NOT IN
    - 컬럼 NOT IN (값1, 값2 ...)
    - 컬럼이 IN 안에 포함되어 있지 않은 경우의 데이터 조회
- **패턴**
  - LIKE
    - 컬럼 LIKE 패턴
    - 컬럼이 패턴에 포함된 경우의 데이터 조회
    - % : 0개 이상의 문자열과 일치
    - [ ] : 1개의 문자와 일치
    - [^] : 1개의 문자와 불일치
    - _ : 특정 위치의 1개의 문자와 일치
- NULL
  - IS NULL
    - 컬럼 IS NULL
    - 컬럼이 NULL인 데이터 조회
  - IS NOT NULL
    - 컬럼 IS NOT NULL
    - 컬럼이 NULL이 아닌 데이터 조회
- 복합조건
  - AND
    - 조건1 AND 조건2
    - 조건1과 조건2 모두를 만족하는 데이터 조회
  - OR
    - 조건1 OR 조건2
    - 조건1과 조건2 둘 중 하나를 만족하는 데이터 조회
  - NOT
    - 조건에 해당하지 않는 데이터 조회


#### WHERE 절 예제

```
// BETWEEN

SELECT *
    FROM PRODUCT
WHERE PRICE BETWEEN 50000 AND 80000;

- 상품(PRODUCT) 테이블에서 가격(PRICE)이 50000보다 크거나 같고 80000보다 작거나 같은 튜플을 조회
```

```
// IN

SELECT *
    FROM PRODUCT
WHERE PRICE IN (40000, 50000, 60000);

- 상품(PRODUCT) 테이블에서 가격(PRICE)이 40000 또는 50000 또는 60000인 튜플을 조회
```

```
// LIKE

SELECT *
    FROM PRODUCT
WHERE NAME LIKE '정보%';

- 상품(PRODUCT) 테이블에서 이름(NAME)이 '정보'로 시작되는 문자열

SELECT *
    FROM PRODUCT
WHERE NAME LIKE '[ABCD]%';

- 첫 번째 문자가 'A' 또는 'B' 또는 'C' 또는 'D'인 문자열과 일치하는 문자열 검색
```

```
// IS NULL

SELECT *
    FROM PRODUCT
WHERE PRICE IS NULL;

- 상품(PRODUCT) 테이블에서 가격(PRICE)이 NULL 값인 경우의 튜플을 조회
```

#### GROUP BY
- GROUP BY 절은 속성값을 그룹으로 분류하고자 할 때 사용

#### GROUP BY 예제
- 아래 테이블은 급여 테이블이라고 했을 때 쿼리 및 결과는 다음과 같음

|이름|직책|부서|급여|
|:---:|:---:|:---:|:---:|
|김철수|차장|마케팅|5000|
|한유리|차장|전산|4800|
|신짱구|사원|마케팅|2500|
|이훈이|사원|마케팅|2700|

```
SELECT 직책,
    COUNT(직책),
    SUM(급여)
FROM 급여
GROUP BY 직책;

// 실행 결과
직책        COUNT(직책)     SUM(급여)
차장               2                 9800
사원               2                 5200

- GROUP BY 절에 명시된 직책을 기준으로 그룹을 묶었을 때 직책별 건수(COUNT)와 급여와 합계(SUM)
```

```
SELECT 부서,
        SUM(급여) AS 급여합계
FROM 급여
GROUP BY 부서;

// 실행 결과
부서       급여합계
마케팅      10200
전산         4800

- GROUP BY 절에 명시된 부서를 기준으로 그룹을 묶었을 때 부서별 급여의 합계(SUM)
```

```
SELECT 직책,
          부서,
          SUM(급여) AS 급여합계
    FROM 급여
GROUP BY 직책, 부서

// 실행 결과
직책         부서         급여합계
차장        마케팅           5000
차장          전산           4800
사원        마케팅           5200
```

```
SELECT COUNT(*)
    FROM 급여;

// 실행 결과
COUNT(*)
4

- GROUP BY 절이 없을 경우 전체 테이블이 하나의 그룹이 되고, 그룹에 해당하는 총 튜플의 수(COUNT)를 출력
```



#### HAVING
- HAVING은 GROUP BY에 의해 분류한 후 그룹에 대한 조건을 지정할 때 사용함


#### HAVING 예제
- 아래 테이블은 급여 테이블이라고 했을 때 쿼리 및 결과는 다음과 같음

|이름|직책|부서|급여|
|:---:|:---:|:---:|:---:|
|김철수|차장|마케팅|5000|
|한유리|차장|전산|4800|
|신짱구|사원|마케팅|2500|
|이훈이|사원|마케팅|2700|

```
SELECT 직책,
          부서,
          SUM(급여) AS 급여합계
    FROM 급여
  GROUP BY 직책, 부서
HAVING 급여합계 >= 5000;

// 실행 결과
직책       부서          급여합계
차장      마케팅          5000
사원      마케팅          5200

- GROUP BY 절에 명시된 직책, 부서를 기준으로 그룹을 묶었을 때 각 직책, 부서에 대한 급여합계가 5000 이상인 급여 합계
```

#### ORDER BY
- ORDER BY는 속성값을 정렬하고자 할 때 사용

#### ORDER BY 예제
- 아래 테이블은 성적 테이블이라고 했을 때 쿼리 및 결과는 다음과 같음

|이름|과목|학점|
|:---:|:---:|:---:|
|김철수|C언어|A|
|한유리|자료구조|A|
|신짱구|자료구조|A|
|이훈이|알고리즘|B|

```
SELECT *
    FROM 성적
ORDER BY 이름;

// 실행 결과
이름      과목      학점
김철수   C언어      A
신짱구  자료구조   A
이훈이  알고리즘   B
한유리  자료구조   A

- ORDER BY 절에 ASC와 DESC가 명시되어 있지 않은 경우 ASC가 기본값
- 이름에 대해 오름차순 정렬
- 문자열일 경우 가나다순으로 정렬
```

```
SELECT *
    FROM 성적
ORDER BY 과목, 이름;

// 실행 결과
이름      과목      학점
김철수   C언어      A
이훈이  알고리즘   B
신짱구  자료구조   A
한유리  자료구조   A

- ORDER BY 절에 2개 이상의 속성이 있는 경우 먼저 선언된 속성으로 정렬 후 같은 값일 때 다음 속성으로 정렬
```

```
SELECT *
    FROM 성적
ORDER BY 학점 DESC, 이름 ASC;

// 실행 결과
이름      과목      학점
이훈이   알고리즘  B
김철수  C언어       A
신짱구  자료구조   A
한유리  자료구조   A

- ORDER BY 절에 2개 이상의 속성에 대해서 오름차순과 내림차순을 섞어서 사용할 수 있음
- 학점은 내림차순으로 정렬한 후 같은 값일 때 이름을 오름차순으로 정렬
```


#### 2. 조인(Join)
- 조인은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법
- 두 릴레이션으로부터 관련된 튜플들을 결합하여 하나의 튜플로 만드는 가장 대표적인 데이터 연결 방법

#### 논리적 조인 유형
|유형|설명|
|:---:|:---|
|<b>내부 조인</b><br>(Inner Join)|공통 존재 컬럼의 값이 같은 경우를 추출하는 기법|
|<b>외부 조인</b><br>(Outer Join)|외부 조인의 종류로 왼쪽 외부 조인, 오른쪽 외부 조인, 완전 외부 조인이 있음<br>- 왼쪽 외부 조인 : 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일 데이터를 추출하는 기법<br>- 오른쪽 외부 조인 : 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 동일 데이터를 추출하는 기법<br>- 완전 외부 조인 : 양쪽의 모든 데이터를 추출하는 기법|
|<b>교차 조인</b><br>(Cross Join)|조인 조건이 없는 모든 데이터 조합을 추출하는 기법|
|<b>셀프 조인</b><br>(Self Join)|자기 자신에게 별칭을 지정한 후 다시 조인하는 기법|


#### 내부 조인

```
SELECT A.컬럼1, A.컬럼2 ...,
         B.컬럼1, B.컬럼2, ...
    FROM 테이블1 A [INNTER] JOIN 테이블2 B
    ON 조인조건
[WHERE 검색조건];

- 같은 이름의 컬럼이 여러 테이블에 있을 경우 '별칭.컬럼명' 형태로 표시
- INNER라는 키워드는 생략해도 내부 조인이 됨
- 검색조건을 추가할 경우 조인된 값에서 해당 조건에 맞는 결과만 출력하도록 설정
```

#### 왼쪽 외부 조인

```
SELECT A.컬럼1, A.컬럼2, ....,
          B.컬럼1, B.컬럼2, ...
    FROM 테이블1 A LEFT [OUTER] JOIN
            테이블2 B
       ON 조인조건
[WHERE 검색조건];

- OUTER라는 키워드는 생략해도 왼쪽 외부 조인이 됨
- 검색조건을 추가할 경우 조인된 값에서 해당 조건에 맞는 결과만 출력되도록 설정
```


#### 오른쪽 외부 조인

```
SELECT A.컬럼1, A.컬럼2, ...,
         B.컬럼1, B.컬럼2, ...
    FROM 테이블1 A RIGHT [OUTER] JOIN 테이블2 B
         ON 조인조건
[WHERE 검색조건];

- OUTER라는 키워드는 생략해도 오른쪽 외부 조인이 됨
- 검색조건을 추가할 경우 조인된 값에서 해당 조건에 맞는 결과만 출력되도록 설정
```


#### 완전 외부 조인

```
SELECT A.컬럼1, A.컬럼2, ...,
         B.컬럼1, B.컬럼2, ...
    FROM 테이블1 A FULL [OUTER] JOIN
             테이블2 B
       ON 조인조건
[WHERE 검색조건];

- OUTER라는 키워드는 생략해도 완전 외부 조인이 됨
- 검색조건을 추가할 경우 조인된 값에서 해당 조건에 맞는 결과만 출력되도록 설정
```


#### 교차 조인

```
SELECT 컬럼1, 컬럼2, ...
    FROM 테이블1 CROSS JOIN 테이블2

- 조인 조건이 없는 모든 데이터 조합을 추출하기 때문에 ON절이 없음
```



#### 셀프 조인

```
SELECT  A.컬럼1, A.컬럼2, ...,
          B.컬럼1, B.컬럼2, ....
     FROM 테이블1 A [INNTER] JOIN 테이블1 B ON 조인조건
[WHERE];

- 같은 테이블명을 쓰고 별칭만 A, B와 같이 다르게 함
- 검색조건을 추가할 경우 조인된 값에서 해당 조건에 맞는 결과만 출력되도록 설정
```



### 3. 서브쿼리(Sub-Query)

#### 서브쿼리 개념
- 서브쿼리는 SQL 문 안에 포함된 또 다른 SQL문임
- 서브쿼리의 용도는 알려지지 않은 기준을 위한 검색을 위해 사용함
- 메인쿼리와 서브쿼리 관계는 주종 관계로서, 서브쿼리에 사용되는 컬럼 정보는 메인쿼리의 컬럼 정보를 사용할 수 있으나 역으로는 성립하지 않음

#### 서브쿼리 유형

|서브쿼리 종류|설명|
|<b>FROM 절 서브쿼리</b>|- 서브쿼리가 FROM 절 안에 들어있는 형태<br>- 인라인 뷰(Inline Views) 라고 불림<br>- 뷰(View)처럼 결과가 동적으로 생성된 테이블 형태로 사용할 수 있음|
|<b>WHERE 절 서브쿼리</b>|- 서브쿼리가 WHERE 절 안에 들어있는 형태<br>- 중첩 서브쿼리(Netsted Sub-Query)라고 불림|


#### 4. 집합 연산자(Set Operator)

#### 집합 연산자 개념

- 집합 연산자는 테이블을 집합 개념으로 보고, 두 테이블 연산에 집합 연산자를 사용하는 방식
- 집합 연산자는 여러 질의 결과를 연결하여 하나로 결합하는 방식을 사용 (집합 연산자는 2개 이상의 질의 결과를 하나의 결과로 만들어 줌)

#### 집합 연산자 유형

|집합 연산자|구성|설명|
|<b>UNION</b>|중복 레코드 제외|중복 행이 제거된 쿼리 결과를 반환하는 집합 연산자|
|<b>UNION ALL</b>|중복 레코드도 허용|중복 행이 제거되지 않은 쿼리 결과를 반환하는 집합 연산자|
|<b>INTERSECT</b>|중복 레코드만 포함|두 쿼리 결과에 공통적으로 존재하는 결과를 반환하는 집합 연산자|
|<b>MNUS</b>|비교 레코드 제외|첫 쿼리에 있고 두 번째 쿼리에는 없는 결과를 반환하는 집합 연산자|



### 3-4. INSERT(데이터 삽입) 명령어

INSERT는 데이터의 내용을 삽입할 때 사용하는 명령어이다.

```
INSERT INTO 테이블명(속성명1, ...)
VALUES (데이터1, ...);

- 속성과 데이터 개수, 데이터 타입이 일치해야 함
- 속성명은 생략 가능
- 속성의 타입이 숫자인 경우 데이터는 따옴표를 붙이지 않아도 되며, 문자열인 경우 따옴표를 붙여야 함

// INSERT 예제

[학생] 테이블에 학번이 6677, 성명 '장길산', 학년이 3학년, 수강과목은 '수학'인 학생을 삽입

INSERT INTO 학생(학번, 성명, 학년, 수강과목)
VALUES(6677, '장길산', 3, '수학');
```

### 3-5. UPDATE(데이터 변경) 명령어
- UPDATE는 데이터의 내용을 변경할 때 사용하는 명령어임

```
UPDATE 테이블명
    SET 속성명 = 데이터, ...
WHERE 조건;

- UPDATE 명령문은 WHERE 절을 통해 어떤 조건이 만족할 경우에만 특정 컬럼의 값을 수정하는 용도로 자주 사용됨

// UPDATE 예제

[학생] 테이블에 장길산의 주소를 인천으로 수정

UPDATE 학생
    SET 주소 = '인천'
WHERE 이름 = '장길산';
```


### 3-6. DELETE(데이터 삭제)명령어
- DELETE는 데이터의 내용을 삭제할 때 사용하는 명령여임

```
DELETE FROM 테이블명
    WHERE 조건;

- 모든 레코드를 삭제할 때는 WHERE 절 없이 DELETE만 사용
- 레코드를 삭제해도 테이블 구조는 남아 있어서 디스크에서 테이블을 완전히 삭제하는 DROP 명령과는 다름

// DELETE 예제

[학생] 테이블에 장길산에 대한 튜플을 삭제

DELETE FROM 학생
WHERE 이름 = '장길산'
```

<br>

---

<br>


# 집계성 SQL 작성(:star::star::star:)

## 1. 데이터 분석 함수의 개념

### 1-1. 데이터 분석 함수의 개념
- 총합, 평균 등의 데이터 분석을 위해서는 복수 행 기준의 데이터를 모아서 처리하는 것을 목적으로 하는 다중 행 함수
- 데이터 분석을 위한 다중 행 함수의 공통적인 특성은 아래와 같음
  - 단일 행을 기반으로 산출하지 않고 복수 행을 그룹별로 모아 놓고 그룹당 단일 계산 결과를 반환함
  - GROUP BY 구문을 활용하여 복수 행을 그룹핑함
  - SELECT, HAVING, ORDER BY 등의 구분에 활용


### 1-2. 다중 행 연산자

#### 다중 행 연산자 개념
- 다중 행 연산자는 서브 쿼리의 결과가 여러 개의 튜플을 반환하는 다중 행 서브쿼리에서 사용되는 연산자

#### 다중 행 연산자 종류
- 다중 행 연산자로 IN, ANY, SOME, ALL, EXISTS를 사용함
- 다중 행 비교 연산자는 단일 행 비교 연산자(<, >, =)와 결합하여 사용 가능

|연산자|설명|
|:---:|:---|
|<b>IN</b>|리턴되는 값 중에서 조건에 해당하는 값이 있으면 참|
|<b>ANY</b>|서브쿼리에 의해 리턴되는 각각의 값과 조건을 비교하여 하나 이상을 만족하면 참|
|<b>ALL</b>|값을 서브쿼리에 의해 리턴되는 모든 값과 조건 값을 비교하여 모든 값을 만족해야먄 참|
|<b>EXISTS</b>|메인 쿼리의 비교 조건이 서브쿼리의 결과 중에서 만족하는 값이 하나라도 존재하면 참|

## 2. 데이터 분석 함수의 종류
- SQL 표준에서는 데이터 튜플 간의 상호 연관 및 계산 분석을 위한 세 가지 함수가 있음

|함수|설명|
|:---:|:---|
|<b>집계 함수</b>|여러 행 또는 테이블 전체 행으로부터 하나의 결괏값을 반환하는 함수|
|<b>그룹 함수</b>|소그룹 간의 소계 및 중계 등의 중간 합계 분석 데이터를 산출하는 함수|
|<b>윈도 함수</b>|데이터베이스를 사용한 온라인 분석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 기능|


## 3. 집계 함수

### 3-1. 집계 함수(Aggregate Function)의 개념
- 여러 행 또는 테이블 전체 행으로부터 하나의 결괏값을 반환하는 함수

### 3-2. 집계 함수 구분

```
SELECT 컬럼1, 컬럼2, ..., 집계함수
    FROM 테이블명
[WHERE 조건]
GROUP BY 컬럼1, 컬럼2, ...
[HAVING 조건식(집계함수 포함)]
```

- WHERE 조건으로 지정된 데이터 집합으로부터 그룹화된 집합에 대한 조건 선택 시에 HAVING을 사용하는 것임
- GROUP BY 구문 뒤에는 테이블을 구분하는 컬럼을 기재하여 그룹화함
- HAVING 구문은 그룹화된 집합에 대한 조건 지정 시 사용하고, 상수나 집약 함수, 집약 키를 사용할 수 있음



#### 1. GROUP BY 구문
- SQL에서는 WHERE 구문을 활용하여 조건별 대상 ROW를 선택함
- 복수 ROW 대상의 데이터 분석 시 그룹핑 대상이 되는 부분을 선별할 필요가 있음
- GROUP BY는 그와 같은 경우에 사용하며 다음과 같은 특성을 가짐
  - NULL값을 가지는 ROW는 제외한 후 산출함
  - SESLECT에서 사용하는 것과 같은 ALIAS 사용이 불가능함
  - WHERE 구문 안에 포함되지 않음
  - WHERE 구문은 GROUP BY 보다 먼저 실행되고, 대상이 되는 단일 행을 사전에 선별하는 역할을 함
- GROUP BY 구문은 실제 구체적 데이터 분석값을 보고자 하는 컬럼 단위를 선정할 때 사용하는 기준이 되며, 이 부분의 조정을 통해 사용자가 원하는 분석 데이터를 볼 수 있게 해줌

#### 2. HAVING 구문
- HAVING 구문은 WHERE 구문 내에는 사용할 수 없는 집계 함수의 구문을 적용하여 복수 행의 계산 결과를 조건별로 적용하는 데 사용됨
- 일반적으로 GROUP BY 뒤에 기재하며, GROUP BY 구문의 기준 항목이나 소그룹 집계 함수를 활용한 조건을 적용하는 데 사용함
- 쉽게 생각하면 GROUP BY 및 집계 함수에 대한 WHERE 구문임


### 3-3 .집계 함수의 종류
- 집계 특성상 숫자 유형의 계산에 사용되는 것이 대다수이나, MAX/MIN 또는 COUNT와 같이 문자열 유형의 최대/최소나 건수 계산 등에도 사용함

|함수 종류|내용|
|:---:|:---|
|<b>COUNT</b>|복수 행의 줄 수를 반환하는 함수|
|<b>SUM</b>|복수 행의 해당 컬럼 간의 합계를 계산하는 함수|
|<b>AVG</b>|복수 행의 해당 컬럼 간의 평균을 계산하는 함수|
|<b>MAX</b>|복수 행의 해당 컬럼 중 최댓값을 계산하는 함수|
|<b>MIN</b>|복수 행의 해당 컬럼 중 최솟값을 계산하는 함수|
|<b>STDDEV</b>|복수 행의 해당 컬럼 간의 표준편차를 계산하는 함수|
|<b>VARIANCE</b>|복수 행의 해당 컬럼 간의 분산을 계산하는 함수|


### 3-4. 집계 함수 활용 예시
- 아래 테이블은 학생(STUDENT) 테이블이라고 했을 때 집계 함수에 대한 쿼리 및 결과는 다음과 같음

|학생명|국어|영어|
|:---:|:---:|:---:|
|유리|100|80|
|철수|50|70|
|영식|80|90|
|미선|70|100|

|쿼리|설명|
|:---|:---|
|SELECT COUNT(*)<br>FROM STUDENT<br>WHERE 국어 >= 80|국어 점수가 80점 이상인 학생들(국어 >= 80)의 숫자를 알려줌(2명)|
|SELECT SUM(국어), AVG(영어)<br>FROM STUDENT|국어 점수의 합(300점), 영어 점수의 평균 값(85점)을 알려줌|
|SELECT MAX(국어), MIN(국어)<br>FROM STUDENT|국어 점수 최고점(100점)과 최저점(50점)을 알려줌|
|SELECT STDDEV(국어)<br>VARIAN(국어)<br>FROM STUDENT|국어 점수의 표준편차(18.03), 분산(235)을 알려줌|


## 4. 그룹 함수(Group Function)

### 4-1. 그룹 함수의 개념
- 테이블의 전체 행을 하나 이상의 컬럼을 기준으로 컬럼 값에 따라 그룹화하여 그룹별로 결과를 출력하는 함수임

### 4-2. 그룹 함수의 유형

#### 1. ROLLUP 함수
- ROULL에 의해 지정된 컬럼은 소계(소그룹의 합계) 등 중간 집계 값을 산출하기 위한 그룹 함수
- 지정 컬럼의 수보다 하나 더 큰 레벨만큼의 중간 집계 값이 생성됨
- ROLLUP의 지정 컬럼은 계층별로 구성되기 때문에 순서가 바뀌면 수행 결과가 바뀜을 유의함

```
SELECT 컬럼1, 컬럼2, ..., 집계 함수
    FROM 테이블명
[WHERE ...]
GROUP BY [컬럼 ...] ROLLUP (컬럼1, 컬럼2, ...)
[HAVING ...]
[ORDER BY ...]
```
- 소계 집계 대상이 되는 컬럼을 ROLLUP 뒤에 기재하고, 소계 집계 대상이 아닌 경우 GROUP BY 뒤에 기재함
- SELECT 뒤에 포함되는 컬럼이 GROUP BY 또는 ROLLUP 뒤에 기재되어야 한다는 점만 숙지하고 쿼리를 작성함
- ORDER BY 구문을 활용해 계층 내 정렬에 사용이 가능하며, SQL의 결과를 보다 체계적으로 보여줌

#### ROLLUP 함수 사례
- 부서별 연봉 테이블이 DEPT_SALARY에서 부서명-직위에 해당되는 연봉 정보, 부서별 연봉 합계, 전체 연봉 합계를 나타내는 쿼리

|부서명(DEPT)|직위(JOB)|연봉(SALARY)|
|:---:|:---:|:---:|
|마케팅부|부장|4,000|
|마케팅부|차장|2,000|
|마케팅부|과장|1,500|
|기획부|부장|3,800|
|기획부|차장|1,800|

````
SELECT DEPT, JOB, SUM(SALARY)
    FROM DEPT_SALARY
GROUP BY ROLLUP(DEPT, JOB);
```

#### ROLLUP 결괏값

|부서명(DEPT)|직위(JOB)|연봉(SALARY)|
|:---:|:---:|:---:|
|마케팅부|부장|4,000|
|마케팅부|차장|2,000|
|마케팅부|과장|1,500|
|마케팅부|-|7,500|
|기획부|부장|3,800|
|기획부|차장|1,800|
|기획부|-|5,600|
|-|-|13,100|

#### 2. CUBE 함수
- CUBE는 결합 가능한 모든 값에 대해 다차원 집계를 생성하는 그룹 함수임
- 연산이 많아 시스템에 부담을 줌

```
SELECT 컬럼명1, ..., 집계 함수
    FROM 테이블명
[WHERE ...]
    GROUP BY [컬럼명1, ...] CUBE(컬럼명a, ...)
[HAVING ...]
[ORDER BY ...]

- ROLLUP은 소계, 중간 집계를 나타내 주지만, CUBE는 결합 가능한 모든 값에 대해 다차원 집계 생성
- CUBE는 세분화된 소계가 구해짐
```

#### CUBE 함수 사례
- 부서별 연봉 테이블인 DEPT_SALARY에서 부서명 -> 직위에 해당되는 연봉 정보, 부서별 연봉 합계, 직위별 연봉 합계, 전체 연봉 합계를 나타내는 쿼리임

|부서명(DEPT)|직위(JOB)|연봉(SALARY)|
|:---:|:---:|:---:|
|마케팅부|부장|4,000|
|마케팅부|차장|2,000|
|마케팅부|과장|1,500|
|기획부|부장|3,800|
|기획부|차장|1,800|

```
SELECT DEPT, JOB, SUM(SALARY)
    FROM DEPT_SALARY
GROUP BY CUBE(DEPT, JOB);
```

|부서명(DEPT)|직위(JOB)|연봉(SALARY)|
|:---:|:---:|:---:|
|-|-|13,100|
|-|부장|7,800|
|-|차장|3,800|
|-|과장|1,500|
|마케팅부|-|7,500|
|마케팅부|부장|4,000|
|마케팅부|차장|2,000|
|마케팅부|과장|1,500|
|기획부|-|5,600|
|기획부|부장|3,800|
|기획부|차장|1,800|

#### 3. GROUPING SETS 함수
- 집계 대상 컬럼들에 대한 개별 집계를 구할 수 있으며, ROLLUP이나 CUBE 와는 달리 컬럼 간 순서와 무관한 결과를 얻을 수 있는 그룹 함수
- GORUPING SETS를 이용해 다양한 소계 집합을 만들 수 있음
- ORDER BY를 사용하여 집계 대상 그룹과의 표시 순서를 조정하여 체계적으로 보여줄 수 있음

```
SELECT 컬럼명1, ..., 집계 함수
    FROM 테이블명
[WHERE ...]
GROUP BY [컬럼명1, ...]
                 GROUPING SETS(컬럼명1, ....)
[HAVING ...]
[ORDER BY ...]

- 개별 집계를 구할 수 있으며, ROLLUP 계층구조와 달리 평등한 관계라 순서에 상관없이 동일한 결과
```

#### GROUPING SETS 함수 사례
- 부서별 연봉 테이블인 DEPT_SALARY에서 부서별 연봉 합계, 직위별 연봉 합계를 나타내는 쿼리

|부서명(DEPT)|직위(JOB)|연봉(SALARY)|
|:---:|:---:|:---:|
|마케팅부|부장|4,000|
|마케팅부|차장|2,000|
|마케팅부|과장|1,500|
|기획부|부장|3,800|
|기획부|차장|1,800|

```
SELECT DEPT, JOB, SUM(SALARY)
    FROM DEPT_SALARY
GROUP BY GROUPING SETS(DEPT, JOB, ());
```

|부서명(DEPT)|직위(JOB)|연봉(SALARY)|
|:---:|:---:|:---:|
|-|-|13,100|
|-|부장|7,800|
|-|차장|3,800|
|-|과장|1,500|
|마케팅부|-|7,500|
|기획부|5,600|

## 5. 윈도 함수

### 5-1. 윈도 함수의 개념
- 윈도 함수는 데이터베이스를 사용한 온라인 분석 처리 용도로 사용하기 위해서 표준 SQL에 추가된 함수임
- 윈도 함수를 OLAP 함수라고도 함

### 5-2. 윈도 함수의 구문

```
SELECT 함수명(파라미터)
    OVER
([PARTITION BY 컬럼1, ...]
[ORDER BY 컬럼A, ...])
    FROM 테이블명

- PARTITION BY는 선택 항목이며, 순위를 정할 대상 범위의 컬럼을 설정 PARTITION BY구에는 GROUP BY구가 가진 집약 기능이 없으며, 이로 인해 레코드가 줄어들지 않음
- PARTITION BY를 통해 구분된 레코드 집합을 윈도라고 함
- 윈도 함수에는 OVER 문구가 필수적으로 포함
- ORDER BY 뒤에는 SORT 컬럼을 입력 (어떤 열을 어떤 순서로 순위를 정할지를 지정)
```


### 5-3 순위 함수
- 순위 함수에는 RANK, DENS_RANK, ROW_NUMBER 함수가 있음

|순위 함수|설명|
|:---:|:---|
|<b>RANK</b>|- 특정 항목(컬럼)에 대한 순위를 구하는 함수<br>- 동일 순위의 레코드 존재 시 후순위는 넘어감<br>(2위가 3개인 레코드인 경우 : 2위, 2위, 5위 ,6위 ...)|
|<b>DENSE_RANK</b>|- 레코드의 순위를 계산<br>- 동일 순위의 레코드 존재 시에도 후순위를 넘어가지 않음<br>(2위가 3개인 레코드인 경우 : 2위, 2위, 3위, 4위 ...)|
|<b>ROW_NUMBER</b>|- 레코드의 순위를 계산<br>- 동일 순위의 값이 존재해도 이와 무관하게 연속 번호를 부여<br>(2위가 3개인 레코드인 경우 : 2위, 3위, 4위, 5위, 6위...)|

- 다음은 직원 테이블인 EMPLOYEE에서 연봉 컬럼인 SALARY를 기준으로 RANK 함수, DENSE_RANK, ROW_NUMBER 함수를 사용한 쿼리와 결과임

#### 순위 함수 예제

```
SELECT NAME,
          SALARY,
          RANK() OVER (ORDER BY SALARY DESC) A,
          DENSE_RANK() OVER (ORDER BY SALARY DESC) B,
          ROW_NUMBER() OVER (ORDER BY SALARY DESC) C
FROM EMPLOYEE;
```


#### 순위 함수 결과

|이름(NAME)|연봉(SALARY)|A|B|C|
|:---:|:---:|:---:|:---:|:---:|
|장길산|3000|1|1|1|
|임꺽정|2500|2|2|2|
|홍길동|2500|2|2|3|
|김철수|2200|4|3|4|
|한유리|2000|5|4|5|

