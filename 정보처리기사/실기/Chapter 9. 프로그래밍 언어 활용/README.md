# 프로그래밍 언어 활용 과목 정리 내용

# C언어 기본

## 1. C언어 기본 구조
- C언어는 본문 전에 처리하는 전처리 부분과 본문으로 구성되어 있음
- 헤더는 xxx.h 파일, 헤더 안에는 프로그래밍에 필요한 함수들이 포함되어 있음


## 2. 전처리기

### 2-1. 전처리기 개념
- 전처리기는 **실행 파일을 생성하는 과정에서 소스 파일 내에 존재하는 전처리 지시문을 처리하는 작업**임

### 2-2. 전처리기 종류
- #include : C언어 프로그램에서 헤더 파일을 포함할 때 사용하는 전처리기
- #define : 매크로를 정의할 때 사용하는 전처리기로 상숫값을 지정하기 위한 예약어로 구문의 상수로 치환할 때 사용

<br>

---

<br>

# 자료형(:star:)

## 1. 자료형(Data Type)의 개념
- 자료형은 프로그래밍 언어에서 실숫값, 정숫값과 같은 여러 종류의 데이터를 식별하는 형태임
- 메모리 공간을 효율적으로 사용하고 2진수 데이터를 다양한 형태로 사용하기 위해 존재함

## 2. 자료의 유형

|유형|설명|선언 형식|
|:---:|:---|:---:|
|<b>문자</b><br>(Character)|- 문자 하나를 저장하고자 할 때 사용하는 자료형<br>- 메모리에 저장은 숫자로 저장됨|char|
|<b>정수</b><br>(Integer)|- 정숫값을 저장하고자 할 때 사용하는 자료형|int|
|<b>부동 소수점</b><br>(Floating Point)|- 소수점을 포함하는 실숫값을 저장하고자 할 때 사용하는 자료형|float, double|



<br>


---

<br>


# 식별자(:star:)

## 1. 식별자(Identifier) 개념
- 식별자는 변수, 상수, 함수 등 서로 구분하기 위해 사용되는 이름
- 프로그램의 구성요소를 구별하기 위해 사용함

## 2. 식별자 표기법

|표기법|설명|예시|
|:---:|:---|:---:|
|<b>카멜 표기법</b><br>(Camel Case)|- 식별자로 표기 시 여러 단어가 이어지면 첫 글자만 소문자, 각 단어의 첫 글자는 대문자로 지정하는 표기법|inputFuction|
|<b>파스칼 표기법</b><br>(Pascal Case)|- 식별자 표기 시 여러 단어가 이어지면 각 단어의 첫 글자는 대문자로 지정하는 표기법|InputFuction|
|<b>스네이크 표기법</b><br>(Snake Case)|- 식별자를 표기 시 여러 단어가 이어지면 단어 사이에 언더바를 넣는 표기법|input_function|
|<b>헝가리안 표기법</b><br>(Hungarian Case)|- 식별자 표기 시 두어에 자료형을 붙이는 표기법<br>- int의 경우 n, char의 경우 c, 문자열의 경우 sz를 붙임|nScore|

<br>

---

<br>

# 변수(:star::star:)


## 1. 변수(Variable)의 개념
- 변수는 저장하고자 하는 **어떠한 값이 있을 때 그 값을 주기억장치에 기억하기 위한 공간**
- 자료형과 변수명을 작성하여 변수를 생성하는 과정

![image](https://user-images.githubusercontent.com/87363461/232180343-4750111b-c4aa-40a9-8de6-76308cec222b.png)

<br>

## 2. 변수 선언(Variable Declaration)
- 변수 선언은 변수나 함수가 있음을 알려주는 행위
- 변수가 어떤 자료형을 사용할지 알려주기 위해 사용함
- 초기화하지 않는 경우 : 자료형 변수명;
- 초기화하는 경우 : 자료형 변수명 = 초깃값;

## 3. 변수 유효범위(Variable Scope)

### 3-1. 전역 변수(Global Variable)
- 전역 변수는 어떤 블록에도 속하지 않는 변수
- 전역 변수는 **프로그램이 시작되면 변수가 생성되고, 프로그램이 종료되면 변수가 소멸됨**
- 전역 변수는 초기화하지 않으면 **정수형은 0, 실수형은 0.0, 문자열은 NULL로 초기화**
- 전역 변수는 아무 곳에서나 사용할 수 있음

### 3-2. 지역 변수(Local Variable)
- 지역 변수는 블록 내에서 선언하는 변수
- 지역 변수는 **블록이 시작되는 부분에 바로 선언해주어야 하고, 중괄호가 닫아야 하는 시점에 소멸**
- 지역 변수는 해당 블록 안에서만 사용 가능

### 3-3. static 변수(Static Variable)
- static 변수는 블록 내외부 상관없이 선언할 수 있는 변수
- static 변수는 변수 선언 시 static 이라는 키워드를 붙임
- static 변수는 블록 내외부 상관없이 프로그램이 시작되면 변수가 생성되고, 프로그램이 종료되면 변수가 소멸됨
- static 변수는 전역 변수로 선언할 경우 프로그램 전체에서 사용할 수 있고, 블록 내에 선언할 경우 블록 내에서만 사용할 수 있음

<br>

---

<br>

# 표준 입출력 함수(:star::star:)

## 1. 표준 출력 함수(printf)
- printf는 지정된 포맷 스트링으로 데이터를 출력하는 함수

### 1-1. 단순 출력
```
printf(문자열);
```

### 1-2. 이스케이프 문자를 이용한 출력
- 이스케이프 문자는 문자열 내에서 특수한 기능을 수행하는 문자임
- 특수한 기능을 수행하기 위해 이스케이프 문자를 printf 함수의 큰따옴표 안에 넣음

#### 이스케이프 문자 종류
|종류|의미|설명|
|:---:|:---:|:---|
|<b>\n</b>|<b>New Line</b>|커서를 다음 줄 앞으로 이동(개행)|
|<b>\t</b>|<b>Tab</b>|커서를 일정 간격만큼 수평 이동|

### 1-3. 포맷 스트링을 이용한 변수 출력
- 포맷 스트링은 일반적으로 scanf를 통해 사용자로부터 입력을 받아들이거나 printf를 통해 결과를 출력하기 위하여 사용하는 형식
- 인자에는 변수명, 값, 수식이 올 수 있음

```
printf(포맷 스트링이 포함된 문자열, 인자 ... );
```

#### 포맷 스트링 종류

- **문자(Character)**
  - **%c(Character)** : 문자 1글자에 대한 형식
- **문자열(String)**
  - **%s(String)** : 문자가 여러 개인 문자열에 대한 형식
- **정수(Integer)**
  - **%u(Unsigned Decimal)** : 부호 없는 10진수 정수
  - **%d(Decimal)** : 10진수 정수
  - **%o(Octal)** : 8진수 정수
  - **%x or %X(Hexa Decimal)** : 16진수로, x의 대소문자 여부에 따라 영어로 표기되는 부분이 대소문자로 표기됨
- **부동 소수점(Floating Point)**
  - **%e or %E(Exponent)** : 지수 표기로, e의 대소문자 여부에 따라 지수 표현 대소문자가 달라짐
  - **%f(Floating Point)** : 부동 소수점 표기
  - **%lf(Long Floating Point)** : 부동 소수점 표기


### 1-4. 포맷 스트링을 이용한 변수 상세 출력
- 포맷 스트링을 이용해 정렬, 0 채우기, 출력할 공간 확보, 소수점 자릿수 표기 지정 가능

```
%[-][0][전체자리수].[소수점자리수]스트링
```

|포맷 스트링|설명|
|:---:|:---|
|<b>[-]</b>|- [-]를 붙이면 왼쪽 정렬<br>- [-]를 붙이지 않고, [전체자리수]가 정해져 있을 경우 오른쪽 정렬|
|<b>[0]</b>|- [0]을 붙이면 전체 자릿수에서 앞에 빈공간 만큼 0으로 채움|
|<b>[전체자리수]</b>|- [전체자리수] 만큼 공간이 확보됨<br>- 소수점도 한 자릿수로 표현|
|<b>.[소수점자리수]</b>|- [소수점자리수]만큼 소수점 출력<br> - 실수형일 때만 적용|

## 2. 표준 입력 함수(scanf)
- scanf는 키보드로 입력받은 문자열에서 지정된 포맷 스트링으로 데이터를 읽는 함수
- printf의 포맷 스트링과 동일함


<br>

----

<br>

# 문자열(:star::star::star:)

## 1. 1차원 배열과 문자열
- C언어에서는 문자열은 char 형 배열로 표현함
- 문자열 초기화 시 마지막에 NULL 문자가 삽입되므로 초기화하는 글자 수보다 1이상 큰 값으로 배열을 선언해야 함

```
// 배열의 예

int a[5];

&a[0] : a의 0번 째 값의 주소
&a[3] : a의 3번 째 값 주소
a : a의 0번 째 값 주소
a + 3 : a의 3번 째 값 주소
```

<br.

---

<br>

# 함수(:star::star::star:)

## 1. main 함수

### 1-1. main 함수 개념
- main 함수는 프로그램이 실행하는 모든 프로그램의 시작점을 말함
- main 함수에 있는 명령어 실행

### 1-2. main 함수 형태

```
자료형 main(파라미터) {
    명령어;
}
```

- void main() 일 경우 반환할 값이 없으므로 return; 을 사용하거나 return 자체를 사용하지 않음
- int main() 일 경우 return  반환값; 을 명시해 주어야 함
- main 함수나 사용자 정의 함수는 return 을 만나면 그 즉시 함수를 종료함

## 3. 표준 함수

### 3-1. 문자열 함수

#### 1. strcat(String Concatenate)
- strcat는 문자열끼리 연결하는 함수임

- strcat(dest, src) : src의 문자열을 dest 문자열 뒤에 붙임
- strncat(dest, src, maxlen) : src의 문자열에서 maxlen의 개수만큼 dest 문자열 뒤에 붙임


#### 2. strcpy(String Copy)
- strcpy는 문자열을 복사하는 함수

- strcpy(dest, src) : src의 문자열을 dest 문자열에 복사
- strncpy(dest, src, maxlen) : src의 문자열에서 maxlen의 개수만큼 dest 문자열에 복사

#### 3. strcmp(String Compare)
- strcmp는 문자열을 비교하는 함수
- strcmp(s1, s2) : s1, s2의 대소를 비교
- strncmp(s1, s2, maxlen) : maxlen 길이만큼 s1, s2의 대소를 비교
- 문자열에 대해 ASCII 코드를 비교하여 s1이 s2보다 크면 1을, s1과 s2가 같으면 0, s1이 s2보다 작으면 -1 반환

#### 4. srlen(String Length)
- strlen은 문자열의 길이를 알려주는 함수
- strlen(s) : s

#### 5. strrev(String Reverse)
- strrev는 문자열을 거꾸로 뒤집는 함수
- strrev(str) : str내에 

#### 6. strchr
- strchr은 문자열 내에 일치하는 문자가 있는지 검사하는 함수
- strchr(str, c) : str 내에 c가 존재하는지 확인


### 3-2. 수학 함수


#### 1. sqrt
- sqrt는 양의 제곱근을 계산하는 함수
- sqrt(n) : n의 루트 값 계산

#### 2. ceil
- ceil은 소수점 올림 함수
- ceil(n) : 소수점 올림

#### 3. floor
- floor은 소수점 내림 함수
- floor(n) : 소수점 내림


### 3-3. 유틸리티 함수

#### 1. rand(Random)
- rand는 임의의 값을 생성하는 함수

- rand() : 임의의 정숫값 1개 생성

#### 2. srand(Seed Random)
- srand는 난수 생성 알고리즘에 사용하는 seed를 정해주는 함수
- srand를 사용하면 rand 함수를 사용할 때 해당 seed 값에 해당하는 난수 패턴으로 생성
- srnad(seed) : seed 값에 따라 난수 발생기를 초기화 함

#### 3. time
- time은 현재 시간을 가져오는 함수
- 1970년 1월 1일 이후로 몇 초가 경과했는지 나타냄
- time(NULL) : time 함수에 파라미터를 NULL로 하면 현재 시간을 리턴함


#### 4. atoi(ASCII to Integer)
- atoi는 문자열을 정수형으로 변환하는 함수
atoi(str) : 문자열(str)을 정수(int)형으로 변환

#### 5. atof(ASCII to Floating Point)
- atof는 문자열을 실수형으로 변환하는 핫무
- atof(str) : 문자열(str)을 실수형(float, double)으로 변환

#### 6. itoa(Integer to ASCII)
- itoa는 정수형을 문자열로 변환하는 함수
- itoa(value, str, radix) : value를 변환하여 str에 radix 진수로 저장

<br>

---

<br>

# 포인터(:star::star::star:)

## 1. 포인터(Pointer) 개념
- 포인터는 변수의 주솟값을 저장하는 공간임

![image](https://user-images.githubusercontent.com/87363461/232196811-de1321da-4863-4c78-bdb0-c1f2d774134d.png)


<br>

## 2. 포인터 선언

```
자료형* 포인터_변수명 = &변수명;
```

- 자료형 뒤에 *를 붙이면 주소를 저장하는 포인터 변수라는 의미이고, 일반 변수명에 &를 붙이면 해당 변수명의 주솟값임
- int 형 변수를 가리키는 포인터 변수 선언 시 int*를, char형 변수를 가리키는 포인터 선언 시 char*와 같은 방식을 사용
- **주소에 해당하는 값을 가리킬 때 * 사용**

## 3. 배열과 포인터
- "자료형 배열명[요소];" 일 때 다음 코드는 동일함

```
배열의 i번지 주소 : 배열 + i == &배열[i];
배열의 i번지 값 : *(배열 + i) == 배열[i];
```

### 3-1. 1차원 배열과 1차원 포인터
- 1차원 배열에서 배열명만 단독으로 사용할 경우 1차원 포인터와 동일함
- 1차원 배열일 때는 배열명[요소] 형태, *(배열명 + 요소) 일 경우 값을 가리키고, 1차원 포인터일 때는 포인터[요소] 형태, *(포인터 + 요소)일 경우 값을 가리킴

```
#include <stdio.h>

int main()
{
    int a[3] = { 1, 2 };
    int *p = a;
    
    // 모두 동일한 출력
    printf("%d %d %d\n", a[0], a[1], a[2]);
    printf("%d %d %d\n", *a, *(a + 1), *(a + 2));
    printf("%d %d %d\n", *p, *(p + 1), *(p + 2));
    printf("%d %d %d\n", p[0], p[1], p[2]);

    return 0;
}

// 출력 결과
1 2 0
1 2 0
1 2 0
1 2 0
```

![image](https://user-images.githubusercontent.com/87363461/232197319-69a8101e-9003-42bd-97c4-242ab6b4874a.png)

<br>


### 3-2. 2차원 배열과 1차원 포인터
- 2차원 배열에서 배열명만 단독으로 사용할 경우 2차원 포인터와 동일함
- 2차원 배열일 때 배열명[요소] 형태, *(배열명 + 요소)는 1차원 포인터와 동일하고, 1차원 포인터에 대해 *과 []을 이용해야 값을 가리킬 수 있음

```
#include <stdio.h>

int main()
{
    int a[3][2] = {{1, 2}, {3, 4}, {5, 6}};
    
    // a[1]은 &a[1][0]과 같음
    // a[1][0]의 주소를 p라는 이름의 포인터 변수에 저장
    // int *를 빼면 p = a[1]이므로 p 대신에 a[1]을 넣어도 결과가 동일
    int *p = a[1];
    
    // a[0]은 &a[0][0]과 같으므로 (배열 + 0 == &배열[0])
    // *a[0]은 *(a[0][0])이 되고, *a과 &는 반대 연산으로 서로 상새되어 a[0][0]값 출력
    // a[1]은 &a[1][0]과 같으므로 *a[1]은 *(&a[1][0])이 되어 a[1][0]값 출력
    // a[2]은 &a[2][0]과 같으므로 *a[2]은 *(&a[2][0])이 되어 a[2][0]값 출력
    printf("%d %d %d\n", *a[0], *a[1], *a[2]);
    
    // a는 &a[0]과 같으므로 **a는 **(&a[0])이 되고, *과 &는 반대 연산이므로 서로 상쇄되어 *(a[0])이 됨
    // a[0]은 &a[0][0]과 같으므로 *(a[0])은 *(&a[0][0])이 되어 a[0][0] 값을 출력
    // a + 1은 &a[1]과 같으므로 **(a + 1)은 *(a[1])이 되고, *(a[1])은 *(&a[1][0]))이 되어 a[1][0] 값을 출력
    // a + 2은 &a[2]과 같으므로 **(a + 2)은 *(a[2])이 되고, *(a[2])은 *(&a[2[0]))이 되어 a[2][0] 값을 출력
    printf("%d %d %d\n", **a, **(a + 1), **(a + 2));
    
    // p는 a[1]의 주솟값이 저장되어 있으므로 p 대신에 a[1]을 넣으면 *(p)는 *(a[1])이 되므로 a[1][0] 값을 출력함
    // *(p + 1)은 *(a[1] + 1)이 되므로 a[1][1] 값을 출력
    printf("%d %d\n", *p, *(p + 1));
    
    // p[0]에서 p 대신 a[1]을 넣으면 (a[1])[0] 이므로 a[1][0] 값 출력
    // p[1]에서 p 대신에 a[1]을 넣으면 (a[1])[1] 이므로 a[1][1] 값 출력
    printf("%d %d\n", p[0], p[1]);

    return 0;
}

// 실행 결과
1 3 5
1 3 5
3 4
3 4
```

![image](https://user-images.githubusercontent.com/87363461/232198786-2ae38bda-151a-4976-925e-026d134880cb.png)


### 3-3. 2차원 배열과 포인터 배열

```
#include <stdio.h>

int main()
{
    int a[3][2] = {{1, 2}, {3, 4}, {5, 6}};
    int *p[3] = {a[2], a[0]. a[1]};

    printf("%d %d %d\n", *a[0][0], *a[1][0], *a[2][0]);
    printf("%d %d %d\n", *a[0], *a[1], *a[2];
    printf("%d %d %d\n", p[1][0], p[2][0], p[0][0]);
    printf("%d %d %d\n", *p[1], *p[2], *p[0]);

    return 0;
}

// 실행 결과
1 3 5
1 3 5
1 3 5
1 3 5
```

### 3-4. 2차원 배열과 2차원 포인터
- 2차원 배열에서 배열명만 단독으로 사용할 경우 2차원 포인터와 동일함

```
#include <stdio.h>

int main()
{
    int a[3][2] = {{1, 2}, {3, 4}, {5, 6}};
    
    int (*p)[2] = a;
    int (*q)[2] = a + 1;

    printf("%d %d %d\n", a[0][0], a[0][1], a[1][0]);
    printf("%d %d %d\n", p[0][0], a[0][1], a[1][0]);
    printf("%d %d %d\n", q[0][0], a[0][1], a[1][0]);

    return 0;
}

// 실행 결과
1 2 3
1 2 3
3 4 5
```

## 4. 구조체와 포인터

### 4-1. 구조체 변수와 구조체 포인터
- 구조체는 일반 구조체 변수로 접근할 때는 .으로 접근, 구조체 포인터로 접근할 때는 ->로 접근함


## 5. 함수 포인터
- 함수 포인터는 함수의 주소를 저장하고, 해당 주소의 함수를 호출하는 데 사용하는 포인터임

```
리턴타입 (*함수_포인터)(함수 파라미터);
```




<br>

---

<br>


# 자바 기본 구조{:star:)
- Java에서 모든 소스 코드는 클래스 단위로 구성됨
- 프로그램은 public static void main 부터 시작

# 변수(:star::star:)

## 1. 변수(Variable) 개념
- 변수는 저장하고자 하는 어떠한 값이 있을 때, 그 값을 주기억장치에 기억하기 위한 공간임
- 자바의 변수는 초기화하지 않으면 정수형은 0, 실수형은 0.0, 문자형은 NULL로 초기화

## 2 변수 유효 범위(Variable Scope)

### 2-1. 클래스 변수(Class Variable)
- 클래스 변수는 **클래스 블록에 선언하는 변수**임
- 클래스 변수는 클래스가 시작되면 변수가 생성되고, 클래스가 종료되면 변수가 소멸됨
- 클래스 변수는 클래스 내에서 사용할 수 있음

### 2-2. 지역 변수(Local Variable)
- 지역 변수는 **블록 내에서 선언하는 변수**임
- 지역 변수는 블록이 시작되는 부분에 바로 선언해주어야 하고, 중괄호가 닫히는 시점에 소멸됨
- 지역 변수는 해당 블록 안에서만 사용할 수 있음

### 2-3. static 변수 (Static Variable)
- static 변수는 변수 선언 시 static 이라는 키워드를 붙여줌
- static 변수는 프로그램이 시작되면 변수가 생성되고, 프로그램이 종료되면 변수가 소멸됨
- static 변수는 프로그램 전체에서 사용할 수 있음


<br>

---

<br>

# 배열(:star::star::star:)

## 1. 배열(Array) 개념
- 배열은 같은 타입의 변수들로 이루어진 집합임

## 2. 배열 선언

### 2-1. 1차원 배열 선언

- 초깃값이 없는 경우 : 자료형 []배열명 = new 자료형[배열 요소 개수}; 또는 자료형 배열명[] = new 자료형[배열 요소 개수];

- 초깃값이 있는 경우 : 자료형 []배열명 = { 초깃값 };

- 배열 요소 개수에 정의된 숫자만큼 같은 타입의 데이터 공간이 선언됨
- 배열 요소 개수를 명시하지 않고 초깃값이 정의되어 있을 경우 초깃값 개수만큼 공간이 선언됨
- 초깃값을 선언하지 않을 경우 정수일 때는 0, 실수는 0.0, 문자열은 NULL이 저장됨
- 불린, 문자, 정수, 실수 등을 배열로 선언 시 사용함
- 자바에서 배열의 크기를 구할 때 length 속성을 사용함

### 2-2. 2차원 배열 선언

- 초깃값이 없는 경우 : 자료형 [][]배열명 = new 자료형[행의 개수][열의 개수]; 또는 자료형 배열명[][] = new 자료형[행의 개수][열의 개수];

- 초깃값이 있는 경우 : 자료형 [][]배열명 = {{ 초깃값 }, { 초깃값 } ... };

<br>

---

<br>

# 표준 입출력 함수(:star::star:)

## 1. 표준 출력 함수
- 표준 출력 함수로 print, println, printf 함수가 있음

|함수|설명|
|:---:|:---|
|<b>System.out.print()</b>|개행을 하지 않는 출력 함수|
|<b>System.out.println()</b>|개행을 하는 출력 함수|
|<b>System.out.printf()</b>|C언어처럼 변수를 출력할 수 있는 출력 함수|

## 2. 표준 입력 함수
- readLine은 입력장치(키보드)로부터 한 개의 문자를 읽는 함수 라인 전체를 읽는 표준 입력 함수임

```
System.in.readLine()
```

<br>

---

<br>

# 클래스(:star::star::star:)

## 1. 클래스(Class) 개념
- 클래스란 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메서드를 정의하는 틀을 말함

## 2. 클래스 제어 접근자

### 2-1. 클래스 접근 제어자(Access Modifier) 개념
- 접근 제어자는 지정된 클래스, 변수, 메서드를 외부에서 접근할 수 있도록 권한을 설정하는 기능임

#### 접근 제어자 졸유

|종류|설명|
|:---:|:---|
|<b>public</b>|- 외부의 모든 클래스에서 접근 가능한 접근 제어자|
|<b>protected</b>|- 같은 패키지 내부에 있는 클래스, 하위 클래스(상속받은 경우)에서 접근이 가능한 접근 제어자<br>- 자기 자신과 상속받은 하위 클래스 둘 다 접근이 가능한 접근 제어자|
|<b>default</b>|- 접근 제어자를 명시하지 앟ㄴ은 경우 같은 패키지 내부에 있는 클래스에서 접근이 가능한 접근 제어자|
|<b>private</b>|- 같은 클래스 내에서만 접근이 가능한 접근 제어자|

## 3. 클래스 정의
- 클래스에서 변수는 변수 선언과 동일하고 메서드는 사용자 정의 함수와 문법이 동일함
- 일반적으로 변수는 private 접근 제어자를 사용하여 외부에서 접근하지 못하게 하며, 메서드는 외부에 공개할 것만 public 접근 제어자를, 그렇지 않으면 protected나 private 접근 제어자를 사용하여 정보은닉 함

```
public class [클래스명] {
    private [자료형] [변수명];
    public [반환 자료형] [메서드명](매개변수) {
        명령어;
        
        return 반환값;
    }
}
```

## 4. 클래스 변수 생성
- 클래스는 객체를 생성하기 위해 변수와 메서드를 정의하는 틀이므로 실제 변수에 들어갈 인스턴스를 new 키워드로 생성해주어야 함
- 변수를 이용해 클래스의 메서드에 접근함

```
클래스명 변수명 = new 클래스명(파라미터);
변수명.메서드명();
```

## 5. 클래스 this
- this는 현재 객체를 가리키는 키워드임
- 클래스 내부의 변수와 메서드를 가리킬 수 있음

```
this.변수;
this.함수(매개변수);
```

## 6. 생성자(Constructor)
- 생성자는 해당 클래스의 객체가 생성될 때 자동으로 호출되는 특수한 종류의 메서드
- 생성자는 일반적으로 클래스의 멤버 변수를 초기화하거나 클래스를 사용하는 데 필요한 설정이 필요한 경우 사용
- 생성자는 클래스 명과 동일한 메서드명을 가지고, 반환 값이 없음
- 생성자가 없을 경우 public 클래스명() {} 이라는 아무 일도 하지 않는 생성자가 있는 것처럼 동작함

## 7. 소멸자(Destructor) - finalize 메서드
- finalize 메서드는 객체의 수명이 끝났을 때 객체를 제거하기 위한 목적으로 사용되는 메서드
- 반환 값이 없음


<br>

---

<br>

# 클래스 상속(:star::star::star:)

## 1. 클래스 상속(Inheritance) 개념
- 상속은 어떤 객체가 있을 때 그 객체의 변수와 메서드를 다른 객체가 물려받는 기능임
- 자식 클래스를 생성하면  무조건 부모 클래스의 생성자를 실행한 후 자식 클래스의 생성자를 실행함

## 2. 클래스 상속 문법

```
class 부모 클래스{
}

class 자식 클래스 extends 부모 클래스 {
}
```

## 3. 오버로딩(Overloading)
- 오버로딩은 동일 이름의 메서드를 매개변수만 다르게 하여 여러 개 정의할 수 있는 기능임

#### 오버로딩의 특징
- 메서드 이름이 같아야 함
- 매개변수 개수가 달라야 함
- 매개변수 개수가 같을 경우 데이터 타입이 달라야 함
- 반환형은 같거나 달라도 됨

## 4. 오버라이딩(Overriding)
- 오버라이딩은 하위 클래스에서 상위 클래스 메서드를 재정의할 수 있는 기능


#### 오버라이딩 특징
- 오버라이드 하고자 하는 메서드가 상위 클래스에 존재해야 함
- 메서드 이름은 같아야 함
- 메서드 매개변수 개수, 데이터 타입이 같아야 함
- 메서드 반환형이 같아야 함


## 5. 부모 클래스 접근
- 자바는 super 키워드를 이용하여 상위 클래스의 변수나 메서드에 접근할 수 있음

```
super.메서드명();
```

<br>


---

<br>


# 추상 클래스(:star::star:)

## 1. 추상 클래스(Abstract Class) 개념
- 추상 클래스는 미구현 추상 메서드를 한 개 이상 가지며, 자식 클래스에서 해당 추상 메서드를 반드시 구현하도록 강제하는 기능임

## 2. 추상 클래스 구문

```
abstract class 추상_클래스명 {
    abstract 자료형 메서드명(); // 메서드 내부는 정의하지 않음
}

class 자식_클래스명 extends 추상_클래스명 {
    자료형 메서드명() {
        명령어;  // 메서드를 상속받아 메서드 내부 재정의
    }
}
```


<br>


---

<br>


# 인터페이스(:star:)

## 1. 인터페이스(Interface) 개념
- 인터페이스는 자바의 다형성을 극대화하여 개발코드 수정을 줄이고 프로그램 유지보수성을 높이기 위한 문법 (일종의 추상 클래스)
- 오직 추상 메서드와 상수만을 멤버로 가질 수 있으며, 그 외의 다른 어떠한 요소도 허용하지 않음
- 인터페이스는 구현된 것은 아무것도 없고 밑그림만 그려져 있는 '기본 설계도'라고 할 수 있음

## 2. 인터페이스 구문

```
interface 인터페이스_클래스명 {
    자료형 메서드명();  // 메서드 내부는 정의하지 않음
}

class 자식_클래스명 implements 인터페이스_클래스명 {
    자료형 메서드명() {
        // interface를 상속받아 재정의
    }
}
```


<br>


---

<br>

# 스레드(:star:)

## 1. 스레드(Thread) 개념
- 스레드는 프로세스보다 가벼운, 독립적으로 수행되는 순차적인 제어의 흐름이며, 실행 단위임

## 2. 스레드 구현

### 2-1. Thread 클래스 상속

#### 1. Thread 클래스 상속 부분
- 스레드를 만들기 위해서는 Thread 클래스를 상속받고 run () 메서드에 스레드 동작 시 수행할 코드를 작성함 (run 메서드 오버라이딩)

```
class Class_Name extends Thread {
    public void run() {
        // 스레드 동작 시 수행할 코드
    }
}

```

#### 2. Thread 클래스 호출 부분
- 스레드 클래스를 생성하여 스레드 변수에 저장함
- 스레드변수.start()를 통해 스레드의 run() 메서드를 실행함

```
Thread 스레드변수 = new 상속받은스레드클래스();
Thread 스레드변수 = new Thread(new 상속받은스레드클래스());
```

### 2-2. Runnable 인터페이스 상속

#### 1. Runnable 인터페이스 상속 부분
- 스레드를 만들기 위해서는 Runnable 인터페이스 상속받고, run() 메서드에 스레드 동작 시 수행할 코드를 작성함 (run 메서드 오버라이딩)

```
class 클래스명 implements Runnable {
    public void run() {
        // 스레드 동작 시 수행할 코드
    }
}
```

#### 2. Thread 클래스 호출 부분

- 스레드 클래스를 생성하여 스레드변수에 저장
- 스레드변수.start()를 통해 스레드의 run() 메서드 실행

```
Thread 스레드변수 = new Thread(new 상속받은스레드클래스());
```


<br>


---

<br>


# 컬렉션(:star:)

## 1. 컬렉션 프레임워크(Collection Framework) 개념
- 컬렉션 프레임워크는 **다수의 데이터를 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합**임
- 자바에서는 컬렉션 프레임워크를 통해 모든 컬렉션 클래스와 인터페이스를 제공함

![image](https://user-images.githubusercontent.com/87363461/232202750-31a67998-146d-49e5-b5e4-311e1800f638.png)

<br>

## 2. 컬렉션 프레임워크 특징

|특징|상세 설명|
|:---:|:---|
|<b>배열의 단점 보완</b>|배열의 단점을 보완하여 만들어진 클래스로, 메모리 낭비 방지 및 동적인 크기 변경 가능|
|<b>자료구조의 구현</b>|자료구조 형태인 List, Set, Map 등이 클래스로 구현|
|<b>일관된 인터페이스</b>|대량의 데이터를 일관된 인터페이스를 제공하여 쉽고 효율적으로 프로그램 작성 가능|

## 3. 컬렉션 프레임워크 구조
- 자바에서 컬렉션 프렝미워크는 인터페이스로 List, Set, Map 등을 제공함

|인터페이스|구현 클래스|특징|
|:---:|:---:|:---|
|<b>List</b>|<b>LinkedList<br>ArrayList</b>|중복이 가능하고 순서가 있는 데이터의 집합|
|<b>Set</b>|<b>HashSet<br>TreeSet</b>|중복이 불가능하고 순서가 없는 데이터의 집합|
|<b>Map</b>|<b>Hashtable<br>HashMap<br>TreeMap</b>|<키, 값> 구조로 키는 중복이 불가능, 값은 중복이 가능한 데이터의 집합|

#### 1. LinkedList

#### LinkedList 개념
- 데이터의 삽입 삭제가 빈번한 경우 ArrayList보다 효울적으로 사용할 수 있는 클래스
- 리스트의 처음과 끝, 양쪽에서 데이터를 추가, 제거하는 메서드 제공
- Stack, Queue, Deque와 같은 자료구조를 쉽게 구현 가능

![image](https://user-images.githubusercontent.com/87363461/232202892-cc32afe5-ea38-4586-b74b-142d8ec9cc54.png)

<br>

#### LinkedList 선언
- LinkedList의 선언 방법은 타입을 설정하지 않는 방법, 타입을 설정하는 방법이 있음
- 자료형은 Class, Integer, String, Character 등 선언 가능

```
List 변수명 = new LinkedList();
LinkedList 변수명 = new LinkedList();

List<자료형> 변수명 = new LinkedList<자료형> ();
LinkedList<자료형> 변수명 = new LinkedList<자료형> ();
```

#### LinkedList 메서드
- add(값) : 값을 추가하는 메서드
- add(인덱스, 값) : 해당 인덱스에 값을 추가하는 메서드
- remove(인덱스) : 해당 인덱스에 값을 제거하는 메서드
- size() : 원소 개수를 출력하는 메서드
- get(인덱스) : 해당 인덱스에 값을 얻는 메서드



#### 2. ArrayList

#### ArrayList 개념
- ArrayList는 List의 자식 클래스로 크기가 가변적으로 변하는 선형리스트의 성질을 가지고 있는 자료형이며 클래스임

#### ArrayList 선언

```
List 변수명 = new ArrayList();
ArrayList 변수명 = new ArrayList();

List<자료형> 변수명 = new ArrayList<자료형> ();
ArrayList<자료형> 변수명 = new ArrayList<자료형> ();
```

#### ArrayList 메서드
- add(값) : 값을 추가하는 메서드
- add(인덱스, 값) : 해당 인덱스에 값을 추가하는 메서드
- remove(인덱스) : 해당 인덱스에 값을 제거하는 메서드
- size() : 원소 개수를 출력하는 메서드
- get(인덱스) : 해당 인덱스에 값을 얻는 메서드


#### 3. HashSet

#### HashSet 개념
- HashSet은 Set의 자식 클래스(하위 클래스; 파생 클래스)로 중복된 원소를 허욯아지 않는 집합의 성질을 가지고 있는 자료형이며 클래스

#### HashSet 선언

```
Set 변수명 = new HashSet();
HashSet 변수명 = new HashSet();

Set<자료형> 변수명 = new HashSet<자료형> ();
HashSet<자료형>변수명 = new Hash<자료형> ();
```

#### HashSet 메서드
- add(값) : 값을 추가하는 메서드
- remove(인덱스) : 해당 인덱스에 값을 제거하는 메서드
- size() : 원소 개수를 출력하는 메서드

#### 4. TreeSet

#### TreeSet 개념
- TreeSet은 이진 검색 트리라는 자료구조 형태로 데이터를 저장하는 자료형이며 클래스
- Set 인터페이스를 구현하여 중복된 데이터의 저장을 허용하지 않으며, 정렬된 위치에 저장하여 저장순서를 유지하지 않는 특성을 가짐

#### TreeSet 선언

```
Set 변수명 = new TreeSet();
TreeSet 변수명 = new TreeSet();

Set<자료형> 변수명 = new TreeSet<자료형> ();
TreeSet<자료형> 변수명 = new TreeSet<자료형> ();
```

#### TreeSet 메서드
- add(값) : 값을 추가하는 메서드로 중복된 값이 들어오면 추가하지 않음
- remove(값) : 값을 제거하는 메서드
- size() : 원소 개수를 출력하는 메서드
- headSet(값) : 값보다 작은 객체들을 반환하는 메서드
- tailSet(값) : 값보다 큰 객체들을 반환하는 메서드

#### HashMap

#### HashMap 개념
- HashMap은 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료구조로 구현한 클래스

#### HashMap 선언

```
Map 변수명 = newHashMap();
HashMap 변수명 = new HashMap();

Map<자료형> 변수명 = new HashMap<자료형> ();
HashMap<자료형> 변수명 = new HashMap<자료형> ();
```

#### HashMap 메서드
- put(키, 값) : 해당 키에 해당하는 값을 추가하는 메서드
- remove(키) : 해당 키에 해당하는 값을 제거하는 메서드
- get(키) : 해당 키에 해당하는 값을 얻는 메서드
- size() : HashMap에 들어있는 원소의 개수를 얻는 메서드


#### TreeMap


#### TreeMpa 개념
- TreeMap은 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료구조를 구현한 자료형이며 클래스
- 이진 검색 트리 형태로 데이터를 저장하여 저장 시 자동 정렬되는 특성을 가짐

#### TreeMap 선언

```
Map 변수명 = new TreeMap();
TreeMap 변수명 = new TreeMap();

Map<자료형> 변수명 = new TreeMap<자료형> ();
TreeMap<자료형> 변수명 = new TreeMap<자료형> ();
```

#### TreeMap 메서드
- put(키, 값) : 해당 키에 해당하는 값을 추가하는 메서드
- remove(키) : 해당 키에 해당하는 값을 제거하는 메서드
- get(키) : 해당 키에 해당하는 값을 얻는 메서드
- size() : TreeMap 들어있는 원소의 개수를 얻는 메서드


<br>

----

<br>

# 예외 처리(:star:)

## 1. 예외 처리(Exception Handling) 개념
- 예외 처리는 프로그램이 동작 중에 의도하지 않은 비정상적인 동작을 처리하는 기법임

## 2. 예외 처리 구문
- 예외 처리는 try, catch, finally로 구성됨
- try 다음에 수행할 명령문에서 예외가 발생하면 catch 에서 예외를 처리
- catch는 하나 이상 작성하며, 상황에 맞는 예외처리가 수행됨
- finally 문장은 예외처리가 끝나고 반드시 실행되어야 하는 명령문 수행

```
try {
    명령문 ;
}

catch (예외처리명) {
    예외처리_명령문;
}

finally {
    명령문;
}
```

<br>



---


<br>


# 파이썬 기본 구조(:star:)
- 파이썬은 사용자 정의 함수, 클래스가 먼저 정의되고 그 다음에 실행 코드가 나옴
- 파이썬은 가독성을 위해 들여쓰기를 함



# 자료형(:star::star::star:)

## 1. 자료형(Data Type) 개념
- 자료형은 프로그래밍 언어에서 실수, 정수, 자료형과 같은 여러 종류의 데이터를 식별하는 형태임

## 2. 자료형 유형

|유형|설명|세부 유형|
|:---:|:---|:---:|
|<b>기본 자료형</b><br>(Primtive Data type)|- 직접 자료를 표현하는 자료형|- 숫자형(Number)<br>- 논리형(Logical)|
|<b>컬렉션 자료형</b><br>(Collection Data Type)|- 다수의 데이터를 효과적으로 처리할 수 있는 자료형|- 문자열형(String)<br>- 리스트형(List)<br>- 튜플형(Tuple)<br>- 딕셔너리형(Dictionary)<br>- 세트형(Set)|


## 3. 기본 자료형(Primtive Data Type)
- 기본 자료형은 직접 자료를 표현하는 자료형임
- 기본 자료형으로 숫자형, 논리형이 있음

|유형|설명|
|:---:|:---|
|<b>숫자형<br>(Number)|- 숫자 저장 시 사용하는 자료형<br>- 정수형(int), 실수형(float)이 있음|
|<b>논리형<br>(Logical: Boolean)|- 변수의 참 거짓을 나타낼 때 사용하는 자료형<br>- True(참), False(거짓)를 저장|

## 4. 컬렉션 자료형(Collection Data Type)
- 컬렉션 자료형은 **시퀀스 자료형과 비시퀀스 자료형**이 있음
- 시퀀스 자료형은 문자열형, 리스트형, 튜플형이 있고 비시퀀스 자료형은 세트형, 딕셔너리형이 있음

#### 컬렉션 자료형
- **시퀀스 자료형**
  - **문자열형(String)**
    - 문자를 한 개 또는 여러 개 저장하고자 할 때 사용하는 자료형
    - 예) s = "ABCDEF"
  - **리스트형(List)**
    - 크기가 가변적으로 변하는 선형리스트의 성질을 가지고 있는 자료형
    - 읽기, 쓰기가 모두 가능
    - 예) l = [1, 2, 3]
  - **튜플형(Tuple)**
    - 초기에 선언된 값에서 값을 생성, 삭제, 수정할 수 없는 형태의 자료형
    - 읽기 전용이며 속도가 빠름
    - 예) t = (1, 2, 3)
- **비시퀀스 자료형**
  - **세트형(Set)**
    - 중복된 원소를 허용하지 않는 집합의 성질을 가지고 있는 자료형
    - 예) s = {1, 2, 3}
  - **딕셔너리형(Dictionary)**
    - 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료형
    - 예) d = {'s':1, 'j':2, 'b':3}

### 4-1. 시퀀스 자료형 구조
- 시퀀스 자료형은 순서가 존재하는 자료형으로 순서가 중요함
- 시퀀스 자료형에는 문자열형, 리스트형, 튜플형이 있음


#### 1. 시퀀스 자료형 종류

#### 문자열형(String)
- 문자열형은 문자를 한 개 또는 여러 개 저장하고자 할 때 사용하는 자료구조

#### 문자열 관련 함수
|함수|설명|
|:---:|:---|
|<b>upper()</b>|문자열을 대문자로 변환하는 함수|
|<b>lower()</b>|문자열을 소문자로 변환하는 함수|
|<b>isalnum()</b>|문자열이 알파벳 또는 숫자로만 구성되어 있으며, True아니면 False를 리턴하는 함수|
|<b>isalpha()</b>|문자열이 알파벳으로만 구성되어 있으면 True, 아니면 False를 리턴하는 함수|
|<b>isdecimal()</b>|문자열이 정수이면 True, 아니면 False를 리턴하는 함수|
|<b>isdigit()</b>|문자열이 숫자이면 True, 아니면 False를 리턴하는 함수|
|<b>isspace()</b>|문자열이 공백으로만 구성되어 있으면 True, 아니면 False를 리턴하는 함수|
|<b>split()</b>|문자열을 매개변수로 전달된 문자(구분자)로 나누어 리스트로 변환하는 함수|


#### 리스트형
- 리스트는 크기가 가변적으로 변하는 선형리스트의 성질을 가지고 있는 자료형
- [, ]]를 이용하여 리스트형을 선언함

```
리스트명 = [요소1, 요소2 ... ]
```

#### 리스트형 메서드
|메서드|설명|
|:---:|:---|
|<b>append(x)</b>|리스트 마지막 요소 뒤에 값 x를 추가하는 메서드|
|<b>clear()</b>|리스트의 모든 항목을 삭제하는 메서드|
|<b>copy()</b>|리스트를 복사하는 메서드|
|<b>count(x)</b>|리스트에서 x항목의 개수를 알려주는 메서드|
|<b>extend(i)</b>|리스트 마지막에 컬렉션 자료형 i를 추가하는 메서드|
|<b>index(x)</b>|값 x와 같은 값을 가지고 있는 인덱스 번호를 알려주는 메서드|
|<b>insert(i, x)</b>|리스트 i번지 위치에 값x를 삽입하는 메서드|
|<b>pop()</b>|마지막 항목을 삭제하고 값을 꺼내오는 메서드|
|<b>remove(x)</b>|리스트에 해당하는 값 x를 제거하는 메서드로 해당하는 값이 여러 개 있을 경우 가장 앞에 있는 값 제거|
|<b>reverse()</b>|리스트의 위치를 전부 역순으로 바꿔주는 메서드|
|<b>sort()</b>|리스트의 항목들을 정렬하는 메서드|


#### 튜플형
- 튜플형은 초기에 선언된 값에서 값을 생성, 삭제, 수정이 불가능한 형태의 자료형
- (, )를 이용하여 튜플형을 선언

```
튜플명 = (요소1, 요소2, ...)
```

#### 2. 시퀀스 자료형 요소 접근 방법 - 인덱싱(Indexing)
- 시퀀스 자료형은 여러 값으로 이루어져 있는데 인덱스를 이용해서 중간값에 접근 가능
- 인덱싱은 문자열, 리스트와 같은 자료구조에서 사용
- 문자열 인덱싱은 문자열에 부여된 번호로 원하는 문자를 기리킬 때 사용
- 문자열 앞에서부터 시작하면 인덱스는 0부터 시작하고, 뒤에서부터 시작하면 - 1부터 시작함

### 3. 슬라이싱(Slicing)
- 슬라이싱은 시퀀스 자료형에서 여러 개의 데이터에 동시에 접근하는 기법

```
시퀀스변수명[시작 : 종료 : 스텝]
```

|형태|설명|
|:---:|:---|
|<b>시작</b>|- 슬라이싱을 시작할 인덱스<br>- 생략할 경우 '시퀀스변수명[:종료]' 또는 '시퀀스변수명[: 종료 : 스텝'] 형태가 됨<br>- 생략할 경우 처음부터 슬라이싱|
|<b>종료</b>|- 슬라이싱을 종료할 인덱스<br>- 종료 인덱스에 있는 인덱스 전까지만 슬라이싱<br>- 생략할 경우 '시퀀스변수명[시작 :]' 또는 '시퀀스변수명[시작 :: 스텝]' 형태가 됨<br>- 생략할 경우 마지막까지 슬라이싱|
|<b>스텝</b>|- 몇 개씩 끊어서 슬라이싱을 할지 결정하는 값<br>- 생략할 경우 '시퀀스변수명[시작 : 종료]' 또는 시퀀스변수명[시작 : 종료 :]' 형태가 됨<br>- 생략할 경우 1이 기본값


### 4-2 비시퀀스 자료형 구조
- 비시퀀스 자료형은 순서가 존재하지 않는 자료형으로 순서가 중요하지 않음

#### 1. 세트형

#### 세트형 개념
- 세트형은 중복된 원소를 허용하지 않는 집합의 성질을 가지고 있는 자료형
- set이라는 키워드로 세트형을 초기화하거나 {, }를 이용하여 세트형을 선언함

```
세트명 = set{[요소1, 요소2, ...]}
세트명 = {요소1, 요소2, ... }
```

#### 세트형 메서드
|메서드|설명|
|:---:|:---|
|<b>add(값)</b>|값을 1개 추가하는 메서드|
|<b>update([값1, 값2])</b>|여러 개의 값을 한꺼번에 추가하는 메서드|
|<b>remove(값)</b>|특정 값을 제거하는 메서드|

#### 2 딕셔너리

#### 딕셔너리형 개념
- 딕셔너리형은 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료형

#### 딕셔너리형 요소 생성

```
딕셔너리명 = {키1:값1, 키2:값2 ... }
```

#### 딕셔너리형 요소 변경

```
딕셔너리명[키] = 값
```

- 기존 변수에 키와 값을 추가함
- 기존 변수에 해당 키에 해당하는 값이 있었으면 값을 변경함

#### 딕셔너리형 요소 삭제
- 기존 변수에서 해당 키와 키에 해당하는 값 삭제

```
del 딕셔너리명[키]
```


## 5. 자료형 함수

### 5-1. type 함수
- type 함수는 자료형을 확인하는 함수임

#### type 함수 유형
- 기본 자료형(Primtive Data Type)
  - 정수형(Integer) / 출력 : <class 'int'>
  - 실수형(Floating Point) / 출력 : <class 'float'>
  - 논리형(Logical) / 출력 : <class 'bool'>
- 컬렉션 자료형(Collection Data Type)
  - 문자열형(String) / 출력 : <class 'str'>
  - 리스트형(List) / 출력 : <class 'list'>
  - 튜플형(Tuple) / 출력 : <class 'tuple'>
  - 딕셔너리형(Dictionary) / 출력 : <class 'dict'>
  - 세트형(Set) / 출력 : <class 'set'>
  
## 5-2. len 함수
- len 함수는 컬렉션 자료형의 크기를 계산하는 함수

<br>

---


<br>


# 입출력(:star:)

## 1. 표준 출력 함수(print)
- 파이썬은 화면에 출력하기 위해 표준 출력 함수인 print 함수 사용

### 1-1. 단순 출력 및 개행
- print(문자열) : 출력 후에 개행
- print(문자열, end='') : 출력 후에 개행을 하지 않음

### 1-2. 변수 출력
- print 함수로 변수를 출력하고자 할 때 매개변수에 출력하고자 하는 변수명만 넣어주면 됨

## 2. 표준 입력 함수(input)
- input 함수는 문자열 또는 숫자를 입력받을 수 있는 파이썬 표준 입력 함수
- 파이썬에서 정수형과 실수형과 같은 숫자를 입력받을 때는 문자열로 저장 후 eval 함수를 써서 숫자로 변환해주어야 함

- 문자열 입력 : 변수명 = input()
- 숫자 입력 : 변수명 = input() 후 변수명 = eval(변수명)


<br>

---

<br>



# 연산자(:star::star:)

## 1. 연산자(Opeartor) 개념
- 연산자는 프로그램 실행을 위해 연산을 표현하는 기호

## 2. 연산자 종류

### 2-1. Swap 연산자
- Swap 연산자는 두 변수의 값을 교환하는 연산자
- 콤마를 기준으로 두 값을 교환함

### 2-2. 산술 연산자
- 산술 연산자는 두 수의 수치 계산을 위한 연산자임
- 산술 연산자에는 사칙 연산(+, -, *, /, //,), 지수 연산(**), 나머지 연산(%)이 있음

<br>

---

<br>



# 함수(:star::star:)

## 1. 사용자 정이ㅡ 함수

### 1-1. 사용자 정의 함수(User-Defined Function) 개념
- 사용자 정의 함수는 사용자가 직접 새로운 함수를 정의하여 사용하는 방법
- 사용자 정의 함수에서 매개변수나 생성된 변수는 사용자 정의 함수가 종료되면 없어짐

### 1-2. 사용자 정의 함수 선언

```
def 함수명(변수명, ...):
    명령어
    return 반환값
```

### 1-3. 디폴트 매개변수
- 디폴트 매개변수는 기본값이 정의된 매개변수
- 함수를 호출할 때, 매개변수가 명시되어 있지 않으면 디폴트 매개변수 값이 전달됨

```
def 함수이름(매개변수=디폴트값):
    명령문
```



## 2. 람다 함수

### 2-1. 람다 함수(Lambda Function) 개념
- 람다 함수는 함수 이름 없이 동작하는 함수
- 매개변수에 값을 전달하는 표현식에서 연산 수행

### 2-2. 람다 함수 문법

#### 1. 일반 람다 함수

```
lambda 매개변수 : 표현식
```
- 일반 사용자 정의 함수는 def 키워드와 return 키워드를 사용하여 함수 구현


#### 2. 변수를 이용한 람다 함수
- 람다 함수를 변수에 할당하여 재사용할 수 있음

```
sum = lambda n, m : n + m
```

####  3. 사용자 정의 함수를 이용한 람다 함수
- 람다 함수는 사용자 정의 함수로 구현 가능

```
def f(n):
    return lambda a:a*n
```

#### 4. 내장 함수를 이용한 람다 함수
- 람다 함수는 파이썬 map 함수, filter 함수와 같이 사용할 수 있음

|함수|형태|설명|
|:---:|:---:|:---|
|<b>map</b>|<b>map(함수, 리스트)</b>|- 첫 번째 매개변수에는 함수, 두 번째 매개변수에는 리스트 전달<br>- 리스트 요소를 함수에 전달하여 반복을 수행하는 함수|
|<b>filter</b>|<b>filter(함수, 리스트)</b>|- 첫 번째 매개변수에는 함수, 두 번째 매개변수에는 리스트를 전달<br>- 리스트 요소를 함수에 전달하여 조건이 참인 값을 리턴하는 함수|

<br>

---

<br>


# 예외 처리(:star:)

## 1. 예외 처리

### 1-1. 예외 처리(Exception Handling) 개념
- 예외 처리는 작성한 코드가 실행하는 도중에 발생되는 에러를 처리하는 구문
- try, except, finally를 이용하여 예외 처리

```
try:
    명령문
except:
    예외 발생 시 동작할 명령문
    
try:
    명령문
except 발생예외명:
    예외 발생 시 동작할 명령문
finally:
    명령문
    
    
    
try:
    명령문
except 발생예외명1:
    예외 발생 시 동작할 명령문1
except 발생예외명2:
    예외 발생 시 동작할 명령문2
else:
    명령문
```

### 1-2 raise
- raise는 프로그램이 의도하지 않게 동작하는 것을 방지하기 위해 의도적으로 예외를 발생시키는 명령어
- raise는 try except 구문 안에서도 사용 가능

```
명령문
raise

명령문
raise 예외처리명

명령문
raise 예외처리명("메시지")
```

<br>

---

<br>


# 클래스(:star::star:)

## 1. 클래스(Class) 개념
- 클래스는 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메서드를 정의하는 틀임

## 2. 클래스 정의
- 클래스에서 변수는 변수 선언과 동일하고 메서드는 사용자 정의 함수와 문법이 동일함

```
class 클래스명:
    def 메서드명(self, 변수명 ...):
        명령어
        return 반환값
```
- 파이썬은 함수명에 입력받을 값(매개변수) 앞에 self 라는 키워드를 적어야 함

```
class 클래스명:
    def fn(self)  # 입력받는 값이 없을 경우 self만 사용
```


## 3. self
- self는 현재 객체를 가리키는 키워드임
- 클래스 내부의 변수와 함수를 가리킬 수 있음

```
self.변수명:
self.함수명(매개변수)
```


## 4. 생성자
- 생성자는 해당 클래스의 객체가 생성될 때 자동으로 호출되는 특수한 종류의 메서드임
- 생성자는 __init__이라는 메서드 명을 사용하고 첫 번째 매개변수로 self를 작성하며 반환 값이 없음

```
# 생성자 정의
class 클래스명:
    def __init__ (self, 매개변수):
        명령어
        
# 생성자 호출
클래스변수 = 클래스(매개변수)
```

## 5. 소멸자
- 소멸자는 객체의 수명이 끝났을 때 객체를 제거하기 위한 목적으로 사용되는 메서드
- 소멸자는 __del__ 이라는 메서드명을 사용하고 첫 번째 매개변수에 self 값을 작성하고 반환 값이 없음

```
# 소멸자 정이ㅡ
class 클래스명:
    def __del__(self):
        명령어

# 소멸자 호출
def 클래스변수
```

## 6. 파이썬은 private, public 등의 접근제어자 키워드가 존재하지 않고 작명법(Naming)을 접근제어 함

|종류|규칙|설명|
|:---:|:---|:---|
|<b>public</b>|- 밑줄이 없어야 함|- 외부의 모든 클래스에서 접근 가능|
|<b>protected</b>|- 한 개의 밑줄이 있어야 함|- 같은 패키지 내부에 있는 하위 클래스에서 접근 가능<br>- 자기 자신과 상속받은 하위 클래스 둘 다 접근 가능|
|<b>private</b>|두 개의 밑줄이 있어야 함|- 같은 클래스 내에서만 접근 가능|

```
class 클래스명:
    def __init__(self):
        self.public = "PUBLIC"
        self._protected = "PROTECTED"
        self.__private = "PRIVATE"
```

