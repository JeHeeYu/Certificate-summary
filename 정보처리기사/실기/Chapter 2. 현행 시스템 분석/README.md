# 현행 시스템 분석 과목 정리 내용


# 현행 시스템 파악(:star::star::star:)

## 1. 현행 시스템 파악 개념
- 현행 시스템 파악이란 <b>현행 시스템이 어떤 하위 시스템으로 구성되어 있고, 제공 기능 및 연계 정보는 무엇이며 어떤 기술 요소를 사용하는지를</b> 파악하는 활동
- 사용하고 있는 <b>소프트웨어 및 하드웨어는 무엇인지</b>, 네트워크의 구성은 어떻게 되어 있는지 파악하는 활동

## 2. 현행 시스템 파악 절차
현행 시스템 파악을 위해 3단계의 절차가 필요
1. <b>구성/기능/인터페이스 파악</b>
- 시스템 구성 현황 파악
- 시스템 기능 파악
- 시스템 인터페이스 현황 파악

2. <b>아키텍처 및 소프트웨어 구성 파악</b>
- 아키텍처 파악
- 소프트웨어 구성 파악

3. <b>하드웨어 및 네트워크 구성 파악</b>
- 시스템 하드웨어 현황
- 네트워크 구성 파악

---

## 3. 소프트웨어 아키텍처

### 3-1. 소프트웨어 아키텍처(Software Architecture) 개념
소프트웨어 아키텍처는 <b>여러 가지 소프트웨어 구성 요소와 그 구성 요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체</b>를 말함

### 3-2. 소프트웨어 아키텍처 프레임워크(Framework)

#### 1. 소프트웨어 아키텍처 프레임워크 개념
- 소프트웨어 아키텍처 프레임워크는 <b>소프트웨어 집약적인 시스템에서 아키텍처가 표현해야 하는 내용 및 이들 간의 관계</b>를 제공하는 아키텍처 기술 표준을 말함

#### 2. 소프트웨어 아키텍처 프레임워크 구성 요소
|구성 요소|설명|
|:---:|:---|
|<b>아키텍처 명세서</b><br>(Architectural<br>Description)|- 아키텍처리를 기록하기 위한 산출물들<br>이해관계자들의 시스템에 대한 관심을 관점에 맞추어 작성한 뷰로 표현<br>개별 뷰, 뷰 개괄 문서, 인터페이스 명세 등이 있음|
|<b>이해관계자</b><br>(Stakeholder)|- 시스템 개발에 관련된 모든 사람과 조직<br>- 고객, 최종 사용자, 개발자, 프로젝트 관리자, 유지보수자, 마케팅 담당자 등을 포함함|
|<b>관심사</b><br>(Concerns)|- 시스템에 대해 이해관계짜들의 서로 다른 의견과 목표<br>- 사용자 입장, 유지보수자 입장, 개발자 입장이 있음<br><br>- 사용자 입장 : 기본적인 기능, 신뢰성 보안, 사용성 등의 품질<br>- 유지보수자 입장 : 유지보수의 용이성<br>~ 개발자 입장 : 적은 비용과 인력으로 개발|
|<b>관점</b><br>(Viewpoint)|- 개별 뷰를 개발할 때 토대가 되는 패턴이나 양식<br>- 이해관계자들이 서로 다른 역할이나 책임으로 시스템이나 산출물들에 대해 보고 싶은 관점|
|<b>뷰</b><br>(View)|- 서로 관련 있는 관심사들의 집합이라는 관점에서 전체 시스템을 표현<br>- 시스템에 대한 아키텍처 설명에는 하나 이상의 뷰로 구성|
|<b>근거</b><br>(Rationale)|- 아키텍처 결정 근거<br>- 회의 결과, 보고 결과|
|<b>목표</b><br>(Mission)|- 환경 안에서 한 명 이상의 이해관계자들이 의도하는 시스템의 목적, 사용 운영 방법 등|
|<b>환경</b><br>(Environment)|- 시스템에 영향을 주는 요인으로 개발, 운영 등의 외부 요인 등으로 시스템에 영향을 주는 요인|
|<b>시스템</b><br>(System)|- 각 애플리케이션, 서브 시스템, 시스템의 집합, 제품군 등의 구현체|

### 3-3. 소프트웨어 아키텍처 4+1 뷰

#### 1. 소프트웨어 아키텍처 4+1뷰 개념
- 소프트웨어 아키텍처 4+1 뷰는 <b>고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는</b> 소프트웨어 접근 방법
- 4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, <b>이들 4개 구조가 서로 충돌되지 않는지, 시스템의 요구사항을 충족시키는지를</b> 증명하기 위해 체크 방법으로 <b>유스케이스</b> 사용

#### 2. 소프트웨어 아키텍처 4+1 뷰 구성요소
- 4+1에서 1은 유스케이스, 4는 논리 뷰, 구현 뷰, 프로세스 뷰, 배포 뷰임
 
<br>

![캡처](https://user-images.githubusercontent.com/87363461/230016012-a0f820cd-afbb-45fb-8011-583eee8f1b11.JPG)

<br>

#### 소프트웨어 아키텍처 4+1 뷰

|뷰|설명|
|:---:|:---|
|<b>유스케이스 뷰</b><br>(Usecase View)|- 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는 데 사용되는 뷰<br>- 사용자, 설계자, 개발자, 테스트 관점|
|<b>논리 뷰</b><br>(Logical View)|- 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰<br>- 설계자, 개발자 관점|
|<b>프로세스 뷰</b><br>(Process View)|- 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰<br>- 개발자, 시스템 통합자 관점|
|<b>규현 뷰</b><br>(Implementation View)|- 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰<br>- 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의|
|<b>배포 뷰</b><br>(Deployment View)|컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰|

### 3-4. 소프트웨어 아키텍처 패턴(Pattern)

#### 1. 소프트웨어 아키텍처 패턴 개념
- 소프트웨어 아키텍처 패턴은 <b>소프트웨어를 설계할 때 참조할 수 있는 전형 적인 해결 방식</b>을 말함
- 주어진 상황에서의 소프트웨어 아키텍처에서 <b>일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션</b>을 말함

#### 2. 소프트웨어 아키텍처 패턴 필요성
- 소프트웨어 개발 시 상황별 소프트웨어 아키텍처 패턴을 수립 적용하여 <b>고객과 의사소통을 통해 고객의 요구사항을 만족시키고, 소프트웨어 개발 생산성과 품질 확보</b>가 가능함
- 개발에 대한 시행착오를 줄여 <b>개발 시간을 단축하고</b> <b>높은 품질의 소프트웨어 생산</b>이 가능
- 이미 검증된 구조로 개발하기 때문에 소프트웨어 개발을 안정적으로 수행할 수 있음
- 시스템의 특성을 개발 전에 예측이 가능함

#### 3. 소프트웨어 아키텍처 패턴 유형
- 소프트웨어 아키텍처 패턴의 주요 유형으로 계층화 패턴, 클라이언트-서버 패턴, 파이프 필터 패턴, 브로커 패턴, 모델-뷰-컨트롤러 패턴 등이 있음

|유형|설명|개념도|
|:---:|:---|:---:|
|<b>계층화 패턴</b><br>(Layered<br>Pattern)|- 계층화 패턴은 시스템을 계층으로 구분하여 구성하는 패턴<br>- 각 하위 모듈들은 특정한 수준의 추상화를 제공하고, 각 계층은 다음 상위 계층에 서비스를 제공<br>- 계층화 패턴은 서로 마주 보는 두 개의 계층 사이에서만 상호 작용이 이루어짐|![image](https://user-images.githubusercontent.com/87363461/230023216-62f09853-383a-4042-aa04-1656f77a7f31.png)|
|<b>클라이언트-<br>서버 패턴</b><br>(Client-Server<br>Pattern)|- 클라이언트-서버 패턴은 하나의 서버와 다수의 클라이언트로 구성된 패턴<br>-사용자가 클라이언트를 통해서 서버에 서비스를 요청하면 서버는 클라이언트에게 서비스를 제공br>- 서버는 계속 클라이언트로부터 요청을 대기|![image](https://user-images.githubusercontent.com/87363461/230023613-e84cc522-cb43-4563-85f4-ee5095697591.png)|
|<b>파이프-필터<br>패턴</b><br>(Pipe-Filter<br>Pattern)|- 파이브-핉터 패턴은 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴<br>- 파이프-필터 패턴은 서브 시스템이 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복<br>- 필터 컴포넌트는 재사용성이 좋고, 추가가 쉽기 때문에 확장이 용이함|![image](https://user-images.githubusercontent.com/87363461/230023850-6c6752fa-d698-4376-ab9b-656da92c9ec9.png)|
|<b>브로커 패턴</b><br>(Broker Pattern)|- 브로커 패턴은 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호 작용이 가능한 패턴<br>- 브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할 수행<br>- 서버는 자신의 기능들(서비스 및 특성)을 브로커에게 넘겨주며(Publish), 클라이언트가 브로커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스 리다이렉션함|![image](https://user-images.githubusercontent.com/87363461/230024294-9153a705-199a-4295-b1f4-c173cd0d4fad.png)|
|<b>모델-뷰-<br>컨트롤러<br>패턴</b><br>(MVC, Model<br>View Controller<br>Pattern)|- MVC 패턴이라고도 하며 대화형 애플리케이션을 모델, 뷰, 컨트롤러 3개의 서브 시스템으로 구조화하는 패턴<br>모델 : 핵심 기능과 데이터 보관<br>뷰 : 사용자에게 정보 표시나 이상의 뷰가 정의될 수 있음<br>컨트롤러 : 사용자로부터 요청을 입력받아 처리<br>- MVC 패턴은 각 부분이 별도의 컴포넌트로 분리되어 있어 서로 영향을 받지 않고 개발 작업 수행 가능<br>MVC 패턴은 컴포넌트를 분리하며 코드의 효율적인 재사용성을 가능하게 하고, 여러 개의 뷰가 있어야 하는 대화형 애플리케이션 구축에 적합|![image](https://user-images.githubusercontent.com/87363461/230024796-9b63857e-b6a4-46ce-9f96-513b8d17ee29.png)|

### 3-5. 소프트웨어 아키텍처 비용 평가 모델

#### 1. 소프트웨어 아키텍처 비용 평가 모델 개념
- 소프트웨어 아키텍처 비용 평가 모델은 <b>아키텍처 접근법이 품질 속성에 미치는 영향을 판단하고 아키텍처 적합성을 평가하는 모델</b>을 말함

#### 2. 소프트웨어 아키텍처 비용 평가 모델 종류

![image](https://user-images.githubusercontent.com/87363461/230025007-e12620e9-5c24-46fd-8116-163ce35ef878.png)

|종류|설명|
|:---:|:---|
|<b>SAAM</b><br>(Software Architecture<br>Analysis Method)|변경 용이성과 경험이 없는 조직에서도 활용 가능한 비용 평가 모델|
|<b>ATAM</b><br>(Architecture Trade-off<br>Analysis Method)|<b>아키텍처 품질 속성</b>을 만족시키는지 판단 및 품질 속성들의 이해 상충관계까지 평가하는 모델|
|<b>CBAM</b><br>(Cost Benefit<br>Analysis Method)|ATAM 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델|
|<b>ADR</b><br>(Active Design Review)|소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델|
|<b>ARID</b><br>(Active Reviews for<br>Intermediate Designs)|전체 아키텍처가 아닌 특정 부분에 대한 품질요소에 집중하는 비용 평가 모델|

---

## 4. 디자인 패턴(Design Pattern)

### 4-1. 디자인 패턴 개념
- 디자인 패턴은 소프트웨어 공학의 <b>소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리</b>한 패턴
- 디자인 패턴을 참고하여 개발할 경우 <b>개발의 효율성과 유지보수성, 운용성이 높아지며, 프로그램의 최적화에 도움이 됨</b>

### 4-2. 디자인 패턴 구성요소
디자인 패턴에는 패턴의 이름, 문제 및 배경, 솔루션, 사례, 결과, 샘플 코드로 구성되어 있음

#### 디자인 패턴 구성요소
|구성요소|설명|
|:---:|:---|
|<b>패턴의 이름</b>|디자인 패턴을 부를 때 사용하는 이름과 디자인 패턴의 유형|
|<b>문제 및 배경</b>|디자인 패턴이 사용되는 분야 또는 배경, 해결하는 문제를 의미|
|<b>솔루션</b>|디자인 패턴을 이루는 요소들, 관계, 협동 과정|
|<b>사례</b>|디자인 패턴의 간단한 적용 사례|
|<b>결과</b>|디자인 패턴을 사용하면 얻게 되는 이점이나 영향|
|<b>샘플 코드</b>|디자인 패턴이 적용된 원시 코드|

### 4-3. 디자인 패턴 유형

#### 목적 유형

|유형|설명|
|:---:|:---|
|<b>생성</b>|- 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴|
|<b>구조</b>|- 더 큰 구조 형성을 목적으로 클래스나 객체의 조합을 다루는 패턴|
|<b>행위</b>|- 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴|


#### 범위 유형

|유형|설명|
|:---:|:---|
|<b>클래스</b>|- 클래스 간 관련성(상속 관계를 다루는 패턴)<br>- <b>컴파일 타임</b>에 정적으로 결정|
|<b>객체</b>|- 객체 간 관련성을 다루는 패턴<br>- <b>런타임</b>에 동적으로 결정|

### 4-4 디자인 패턴 종류

#### 생성 패턴 종류

|패턴|설명|
|:---:|:---|
|<b>Builder</b>|- <b>복잡한 인스턴스를 조립하여 만드는 구조</b>로, 복합 객체를 생성할 때 <b>객체를 생성하는 방법(과정)과 객체를 구현(표현)하는 방법을 분리함</b>으로써 동일한 생성 절차에서 <b>서로 다른 표현 결과를 만들 수 있는</b> 디자인 패턴<br>- 생성과 표기를 분리해서 복잡한 객체를 생성|
|<b>Prototype</b>|- <b>처음부터 일반적인 원형을 만들어 놓고</b>, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 <b>객체를 생성할 때 갖추어야 할 기본 형태가 있을 때</b> 사용되는 디자인 패턴<br>- <b>기존 객체를 복제함으로써</b> 객체를 생성|
|<b>Factory Method</b>|- <b>상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 만드는 방식</b>으로, 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고, 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 <b>함수들을 오버라이딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성</b>을 갖는 디자인 패턴<br>- <b>생성할 객체의 클래스를 국한하지 않고</b> 객체를 생성|
|<b>Abstract Factory</b>|- 구체적인 클래스에 의존하지 않고 <b>서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공</b>하고 패턴으로 이 패턴을 통해 <b>생성된 클래스에서 사용자에게 인터페이스(API)를 제공</b>하고, 구체적인 구현은 Con-create Product 클래스에서 이루어지는 특징을 갖는 디자인 패턴<br>- <b>동일한 주제의 다른 패토리를 묶음</b>|
|<b>Singleton</b>|<b>전역 변수를 사용하지 않고 객체를 하나만 생성</b>하도록 하며, 생성된 객체를 <b>어디에서든지 참조할 수 있도록</b> 하는 디자인 패턴<br>- <b>한 클래스에 한 객체만 존재</b>하도록 제한|


#### 구조 패턴 종류

|패턴|설명|
|:---:|:---|
|<b>Bridge</b>|- <b>기능의 클래스 계층과 구현의 클래스 계층을 연결</b>하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 <b>독립적으로 확장</b>할 수 있는 디자인 패턴<br>- 구현뿐만 아니라, <b>추상화된 부분까지 변경해야 하는 경우 활용</b>|
|<b>Decorator</b>|기존에 구현되어 있는 <b>클래스에 필요한 기능을 추가해 나가는 설계 패턴</b>으로, 기능 확장이 필요할 때 객체 간의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주어 <b>상속의 대안으로 사용하는</b> 디자인 패턴<br>- 객체의 결합을 통해 <b>기능을 동적으로 유연하게 확장</b>|
|<b>Facade</b>|- 복잡한 시스템에 대하여 <b>단순한 인터페이스를 제공</b>함으로써 사용자와 시스템 간 또는 여타 <b>시스템과의 결합도를 낮추어</b> 시스템 구조에 대한 파악을 쉽게 하는 패턴으로 오류에 대해서 단위별로 확인할 수 있게 하며, 사용자의 측면에서 단순한 인터페이스 제공을 통해 접근성을 높일 수 있는 디자인 패턴<br>- <b>통합된 인터페이스 제공</b>|
|<b>Facade</b>|- <b>복잡한 시스템에 대하여 단순한 인터페이스를 제공</b>함으로써 사용자와 시스템 간 또는 여타 시스템과의 결합도를 낮추어 <b>시스템 구조에 대한 파악을 쉽게 하는 패턴</b>으로 오류에 대해서 단위별로 확인할 수 있게 하여 사용자의 측면에서 단순한 인터페이스 제공을 통해 <b>접근성을 높일 수 있는</b> 디자인 패턴<br>- <b>통합된 인터페이스 제공</b>|
|<b>Flyweight</b>|- 다수의 객체가 생성될 경우 모두가 갖는 <b>본질적인 요소를 클래스 화</b>하여 공유함으로써 메모리를 절약하고, <b>'클래스 경량화'를 목적</b>으로 하는 디자인 패턴<br>- 여러 개의 <b>'가상 인스턴스'</b>를 제공하여 메모리 절감|
|<b>Proxy</b>|- <b>'실체 객체에 대한 대리 객체'</b>로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해서 미리 할당하지 않아도 상관없는 것들을 <b>실제 이용할 때 할당하게 하여</b> 메모리 용량을 아낄 수 있으며, 실체 객체를 드러나지 않게 하여 <b>정보은닉의 역할도 수행</b>하는 디자인 패턴<br>- <b>특정 객체로의 접근을 제어</b>하기 위한 용도로 사용|
|<b>Composite</b>|- <b>객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴</b>으로, 사용자가 단일 <b>객체와 복합 객체 모두 동일하게 다루도록 하는 패턴</b><br>- 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 <b>타 클래스의 인터페이스를 기존 인터페이스에 덧씌움</b>|
|<b>Adapter</b>|- 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴으로, 상속을 이용하는 <b>클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두 가지 형태</b>로 사용되는 디자인 패턴<br>- 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움|


#### 행위 패턴 종류

|패턴|설명|
|:---:|:---|
|<b>Mediator</b>|- 객체 지향 설계에서 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져서 객체 지향에서 가장 중요한 느슨한 결합의 특성을 해칠 수 있기 때문에 이를 해결하는 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 <b>중재자</b>를 두고, 중재자에게 모든 것을 요구하여 <b>통신의 빈도수를 줄여 객체 지향의 목표를 달성하게 해주는 디자인 패턴</b><br>- <b>상호 작용의 유연한 변경을 지원</b>|
|<b>Interpreter</b>|- 언어의 다양한 해석, 구체적으로 <b>구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성</b>하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴<br>- <b>문법 자체를 캡슐화</b>하여 사용|
|<b>Iterator</b>|- 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 <b>모든 항목에 반복자를 사용하여 접근</b>할 수 있는 디자인 패턴<br>- 내부구조를 노출하지 않고, <b>복잡 객체의 원소를 순차적으로 접근 가능하게 해주는</b> 행위 패턴|
|<b>Template<br>Method</b>|- 어떤 작업을 처리하는 일부분을 <b>서브 클래스로 캡슐화</b>해 전체 일을 수행하는 구조로 바꾸지 않으면서 <b>특정 단계에서 수행하는 내역을 바꾸는 패턴</b><br>- 일반적으로 상위 클래스에는 추상 메서드를 통해 기능의 골격을 제공하고, 하위 클래스의 메서드에는 세부 처리를 구체화하는 방식으로 사용하며 <b>코드 양을 줄이고 유지보수를 용이하게 만드는 특징</b>을 갖는 디자인 패턴<br>- 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행|
|<b>Observer</b>|- 한 <b>객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고</b> 자동으로 내용이 갱신되는 방법으로 <b>일대 다의 의존성을 가지며 상호 작용하는 객체 사이에서는 가능하면 느슨하게 결합</b>하는 디자인 패턴<br>- 객체의 상태 변화에 따라 다른 객체의 상태도 연동, 일대다 의존|
|<b>State</b>|- <b>객체 상태를 캡슐화하여 클래스화</b>함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 <b>원시 코드의 수정을 최소화할 수 있고, 유지보수의 편의성도 갖는</b> 디자인 패턴<br>- <b>객체 상태에 따라 행위 내용을 변경</b>|
|<b>Visitor</b>|- 각 클래스 데이터 구조로부터 <b>처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴</b>으로, 객체의 <b>구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용</b>하는 디자인 패턴<br>- 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위|
|<b>Command</b>|- <b>실행될 기능을 캡슐화함</b>으로써 주어진 여러 기능을 실행할 수 있는 <b>재사용성이 높은 클래스를 설계하는 패턴</b>으로 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 디자인 패턴<br>- <b>요구사항을 객체로 캡슐화</b>|
|<b>Strategy</b>|- 알고리즘 군을 정의하고 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, <b>필요할 때 서로 교환해서 사용할 수 있게 하는 패턴</b>으로, 행위를 클래스로 캡슐화해 동적으로 행위를 <b>자유롭게 바꿀 수 있게 해주는 </b>디자인 패턴<br>- 행위 객체를 클래스로 캡슐화해 <b>동적으로 행위를 자유롭게 변환</b>|
|<b>Memento</b>|- 클래스 설계 관점에서 <b>객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴</b>으로 <b>Undo 기능을 개발할 때 사용</b>하는 디자인 패턴<br>- <b>객체를 이전 상태로 복구시켜야 하는 경우</b> 작업취소(Undo) 요청 기능|
|<b>Chain of<br>Responsibility</b>|- 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 때 기능 처리의 연결 변경이 불가능한데, 이를 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴<br>- <b>한 요청을 2개 이상의 객체에서 관리</b>|

<br>

---

<br>


# 개발 기술 환경 정의(:star::star::star:)

## 1. 개발 기술 환경 현행 시스템 분석

### 1-1. 운영체제 현행 시스템 분석

#### 1. 운영체제(Operating System)의 개념
- 운영체제는 <b>컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해주고, 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스를 담당하는 프로그램</b>을 말함
- <b>사용자가 컴퓨터를 좀 더 쉽게 사용하기 위해 지원하는 소프트웨어</b>

#### 2. 운영체제 현행 시스템 분석
- 운영체제 현행 시스템 분석 시 품질 측면과 지원 측면 등을 고려

#### 운영체제 현행 시스템 분석 시 고려 사항

|관점|고려사항|설명|
|:---:|:---:|:---|
|품질 측면|신뢰도|- 장기간 시슽메 운영 시 운영체제의 장애 발생 가능성<br>- 운영체제의 버그로 인한 재기동 여부|
|품질 측면|성능|- 대규모 및 대량 파일 작업(배치 작업)처리<br>- 지원 가능한 메모리 크기(32비트, 64비트)|
|지원 측면|기술 지원|- 공급사들의 안정적인 기술 지원<br>- 오픈 소스 여부|
|지원 측면|주변 기기|- 설치 가능한 하드웨어<br>- 다수의 주변 기기 지원 여부|
|지원 측면|구축 비용|- 지원 가능한 하드웨어 비용<br>- 설치할 응용 프로그램의 라이선스 정책 및 비용<br>- 유지 및 관리 비용|

### 3. 운영체제 종류 및 특징
- 대표적으로 PC, 모바일 운영체제로 나뉨

#### 운영체제 종류 및 특징

- 리눅스 기반 시스템이 하드웨어 및 소프트웨어 소유 비용이 가장 적게 소요됨

|구분|종류|저작자|특징|
|:---:|:---:|:---:|:---|
|PC|<b>윈도우즈</b><br>(Windows)|Microsoft|- 중/소규모 서버, 일단 PC 등 유지, 관리 비용 장점|
|PC|<b>유닉스</b><br>(UNIX)|IBM, HP, SUN|- 대용량 처리, 안정성 높은 엔터프라이즈급 서버|
|PC|<b>리눅스</b><br>(Linux)|Linus Torvalds|- 중/대규모 서버 대상, 높은 보안성 제공|
|Mobile|<b>안드로이드</b><br>(Android)|Google|- 리눅스 운영체제 위에서 구동하며 휴대폰 전화를 비롯한 휴대용 장치를 위한 운영체제와 미들웨어, 사용자 인터페이스 그리고 표준 응용 프로그램 등을 포함하고 있는 소프트웨어 스택이자 리눅스 모바일 운영체제<br>- 개발자들이 자바, 코틀린 언어로 응용 프로그램을 작성할 수 있게 했고, 컴파일된 바이트 코드를 구동할 수 있는 런타임 라이브러리를 제공하는 운영체제|
|Mobile|<b>iOS</b>|Apple|- 스마트폰, 태블릿PC의 높은 보안성과 고성능 제공|

### 1-2. 네트워크 현행 시스템 분석

#### 1. 네트워크(Network)의 개념
- 네트워크는 <b>컴퓨터 장치들의 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술</b>
- 데이터 링크들은 광케이블과 같은 유선 매체 또는 와이파이와 같은 무선 매체를 통해 확립됨

#### 2. OSI 7계층
- OSI 7계층은 네<b>트워크 통신에서 생긴 여러 가지 충돌 문제를 완화하기 위해 국제 표준화 기구(ISO)에서 제시한 네트워크 기본 모델</b>

#### OSI 7계층 계층별 특징

|계층|설명|프로토콜|전송단위|
|:---:|:---|:---:|:---:|
|<b>응용 계층</b><br>(Application Layer)|- 사용자와 네트워크 간 응용서비스 연결, 데이터 생성|HTTP<br>FTP|데이터(Data)|
|<b>표현 계층</b><br>(Presentation Layer)|- 데이터 형식 설정과 부호교환, 암/복호화|JPEG<br>MPEG|데이터(Data)|
|<b>세션 계층</b><br>(Session Layer)|- 연결 접속 및 동기제어|SSH<br>TLS|데이터(Data)|
|<b>전송 계층</b><br>(Transport Layer)|- 신뢰성 있는 통신 보장<br>- 데이터 분할과 재조립, 흐름 제어, 오류 제어, 혼잡제어 등을 담당|TCP<br>UDP|세그먼트(Segment)|
|<b>네트워크 계층</b><br>(Network Layer)|- 단말기 간 데이터 전송을 위한 최적화된 경로 제공|IP<br>ICMP|패킷(Packet)|
|<b>데이터 링크 계층</b><br>(Data Link Layer)|- 인접 시스템 간 데이터 전송, 전송 오류 제어<br>- 동기화, 흐름 제어 등의 전송 기능 제공<br>- 오류 검출/재전송 등 기능 제공|이더넷<br>(Ethernet)|프레임(Frame)|
|<b>물리 계층</b><br>(Physical Layer)|- 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환|RS-232C|비트(Bit)|

#### 4. 네트워크 현행 시스템 분석
- 현행 시스템이 구성된 네트워크 구조를 네트워크 구성도를 통해 분석함
- 네트워크 구성도를 통해 서버 위치, 서버 간 연결 방식을 파악할 수 있음
- <b>백본망, 라우터, 스위치, 게이트웨이, 방화벽</b>등을 대상으로 분석함
- 네트워크 분석 시 물리적인 위치 관계 파악, 조직 내 보안 취약성 분석 및 대응이 가능함
- 네트워크 장애 발생 추적 및 대응 등의 다양한 용도로 활용 가능

### 1-3. DBMS(Database Management System) 현행 시스템 분석

#### 1. DBMS의 개념
- DBMS는 데이터베이스라는 데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램
- DBMS의 기능은 중복 제어, 접근 통제, 인터페이스 제공, 관계 표현 등을 제공함

#### 2. DBMS의 기능

|기능|설명|
|:---:|:---|
|<b>중복 제어</b>|동일한 데이터가 여러 위치에 중복으로 저장되는 현상 방지|
|<b>접근 통제</b>|권한에 따라 데이터에 대한 접근 제어|
|<b>인터페이스 제공</b>|사용자에게 SQL 및 CLI, GUI 등 다양한 인터페이스 제공|
|<b>관계 표현</b>|서로 다른 데이터 간의 다양한 관계를 표현할 수 있는 기능 제공|
|<b>샤딩/파티셔닝</b>|구조 최적화를 위해 작은 단위로 나누는 기능 제공|
|<b>무결성 제약 조건</b>|무결성에 관한 제약 조건을 정의/검사하는 기능 제공|
|<b>백업 및 회복</b>|데이터베이스 장애 발생 시 데이터의 보존 기능 제공|

#### 3. DBMS 현행 시스템 분석
- 데이터베이스의 가용성, 성능, 기술 지원, 호환성, 구축 비용을 분석함

#### DBMS 현행 시스템 분석 시 고려 사항

|관점|고려사항|설명|
|:---:|:---:|:---|
|<b>성능 측면</b>|<b>가용성</b>|- 장기간 시스템을 운영할 때 장애 발생 가능성<br>- 백업 및 복구 편의성<br>- DBMS 이중화 및 복제 지원 여부|
|<b>성능 측면</b>|<b>성능</b>|- 대규모 데이터 처리 성능<br>- 대량 거래 처리 성능<br>- 다양한 튜닝 옵션 지원 여부<br>- 비용 기반 최적화 지원 및 설정의 최소화 지원 여부|
|<b>성능 측면</b>|<b>상호 호환성</b>|- 설치 가능한 운영체제 종류<br>- 다양한 운영체제에서 지원되는 JDBC, ODBC|
|<b>지원 측면</b>|<b>기술 지원</b>|- 공급 업체들의 안정적인 기술 지원 여부<br>- 다수의 사용자 간의 정보 공유 여부<br>- 오픈 소스 여부|
|<b>지원 측면</b>|<b>구축 비용</b>|- 라이센스 정책 및 비용<br>- 유지 및 관리 비용|

### 1-4. 미들웨어의 현행 시스템 분석

#### 1.미들웨어(Middleware)의 개념
- 미들웨어는 <b>분산 컴퓨터 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어를 말함</b>
- 운영체제와 소프트웨어 애플리케이션 사이에 위치하고 있음
- 대표적인 미들웨어로 WAS가 있음

#### 2. 웹 애플리케이션 서버(Web Application Server)
- 웹 애플리케이션 서버는 서버계층에서 애플리케이션이 동작할 수 있도록 환경을 제공, 안정적인 트랜잭션 처리와 관리, 다른 이기종 시스템과의 애플리케이션 연동을 지원하는 서버임

#### 3. 미들웨어의 현행 시스템 분석
- 미들웨어의 가용성, 성능, 기술 지원, 구축 비용을 분석함

#### 미들웨어 현행 시스템 분석 시 고려 사항
- 가용성
  - 장기간 시스템을 운영할 때 장애 발생 가능성
  - 안정적인 트랜잭션 처리 능력
  - WAS의 버그 등을 개선하는 패치 설치를 위한 재기동 기능 지원 여부
  - WAS 이중화 지원 여부
- 성능
  - 대규모 데이터 처리 성능
  - 다양한 설정 옵션 지원 여부
  - 가비지 컬렉션의 다양한 옵션 기능 여부
- 기술 지원
  - 공급 벤더들의 안정적인 기술 지원 여부
  - 다수의 사용자들 간의 정보 공유 여부
  - 오픈 소스 여부
- 구축 비용
  - 라이선스 정책 및 비용
  - 유지 및 관리 비용
  - 총 소유 비용

### 1-5. 오픈 소스 사용 시 고려 사항
- 오픈 소스를 사용하는 경우 <b>라이선스의 종류, 사용자 수, 기술의 지속 가능성 등</b>을 고려해야 함
- 오픈 소스 소프트웨어의 전제 조건인 자유 배포, 소스 코드 공개, 파생작업 허용, 소스 코드 일관성 확보, 차별금지, 라이선스 배포, 포괄적 허용을 고려해야 함
