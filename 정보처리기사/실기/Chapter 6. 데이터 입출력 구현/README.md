# 데이터 입출력 구현 과목 정리 내용

# 데이터 모델(:star::star::star:)

## 1. 데이터 모델 개념

![image](https://user-images.githubusercontent.com/87363461/231764236-27a37535-6274-44c8-bc6b-6b67eeb41559.png)

- 데이터 모델은 <b>현실 세계의 정보를 인간과 컴퓨터가 이해할 수 있도록 추상화하여 표현한 모델</b>을 말함
- 데이터 모델에 표시해야 할 요소로 논리적 데이터 구조, 연산, 제약 조건이 있음

#### 데이터 모델 표시요소
|표시요소|설명|
|:---:|:---|
|<b>연산</b><br>(Operation)|- 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세<br>- 릴레이션을 조작하기 위한 연산을 나타냄<br>- 연산 : SELECT, PROJECT, JOIN, DIVISION|
|<b>구조</b><br>(Structure)|- 데이터베이스에 논리적으로 표현될 대상으로서의 개체 타입과 개체 타입 간의 관계<br>- 데이터 구조 및 정적 성질을 표현하는 요소|
|<b>제약 조건</b><br>(Constraint)|- 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건<br>- 데이터 무결성 유지를 위한 DB의 보편적 방법<br>- 릴레이션의 특정 칼럼에 설정하는 제약을 의미<br>- 제약 : 개체 무결성, 참조 무결성 등|

## 2. 데이터 모델 절차

|단계|모델|설명|
|:---:|:---:|:---|
|<b>요구조건<br>분석</b>|<b>-</b>|- 도출된 요구사항 간 상충을 해결하고 범위를 파악하여 외부 환경과의 상호작용 분석을 통해 데이터에 대한 요구 분석|
|<b>개념적<br>설계</b>|<b>개념적 데이터 모델</b>|- 사용자의 요구에 대한 트랜잭션을 모델링하는 단계<br>- 개념적 데이터 모델은 현실 세계에 대한 인식을 추상적, 개념적으로 표현하여 개념적 구조를 도출하는 데이터 모델<br>- 트랜잭션 모델링, View 통합방법 및 Attribute 합성 고려<br>- 개념적 데이터 모델은 DB 종류와 관계가 없음<br>- 주요 산출물은 개체관계 다이어그램이 있음<br><br> ![image](https://user-images.githubusercontent.com/87363461/231769751-4659f65e-a911-4f87-9399-3902b8258d9a.png)
|<b>논리적<br>설계</b>|<b>논리적 데이터 모델</b>|- 트랜잭션의 인터페이스를 설계하는 단계<br>- DBMS에 맞는 논리적 스키마를 설계하는 단계<br>- 논리적 데이터 모델은 업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현한 데이터 모델<br>- 논리적 설계 단계에서 정규화를 수행<br>- 논리적 데이터베이스 구조로 매핑(Mapping)<br>- 스키마의 평가 및 정제<br>- 관계형 데이터베이스에서는 테이블을 설계하는 단계<br> ![image](https://user-images.githubusercontent.com/87363461/231770444-eaf6b188-fd1c-4096-870c-56fc6978371e.png)|
|<b>물리적<br>설계</b>|<b>물리적 데이터 모델</b>|- 물리적 설계는 논리 데이터 모델을 특정 DBMS의 특성 및 성능을 고려하여 물리적인 스키마를 만드는 단계<br>- 물리적 데이터 모델은 논리 데이터 모델을 사용하고자 하는 각 DBMS의 특성을 고려하여 데이터베이스 저장 구조(물리 데이터 모델)로 변환하는 모델<br>- 테이블(Table), 인덱스(Index), 뷰(View), 파티션(Partition) 등 객체를 생성<br>- 응답시간, 저장 공간의 효율화, 트랜잭션 처리를 고려하여 설계<br>- 성능 측면에서 반 정규화를 수행<br>- 레코드 집중의 분석 및 설계<br>- 저장 레코드 양식 설계<br>- 접근 경로(Access Path) 설계<br> ![image](https://user-images.githubusercontent.com/87363461/231770924-fc29e4d3-3809-4d4c-a2c9-1fa348523044.png)|

<br>

---

<br>

# 논리 데이터 모델 검증(:star::star::star:)

## 1. 논리 데이터 모델링 개념
- 논리적 데이터 모델링은 <b>업무의 모습을 모델링 표기법으로 형상화하여 사람이 이해하기 쉽게 표현하는 프로세스</b>를 말함
- 개념 모델로부터 업무 영역의 업무 데이터 및 규칙을 구체적으로 표현한 모델

![image](https://user-images.githubusercontent.com/87363461/231910214-e30e58a8-22ee-4280-8691-1fa444c1f189.png)

## 2. 논리적 데이터 모델링 종류
|종류|설명|
|:---:|:---|
|<b>관계 데이터<br>모델</b>|- 논리적 구조가 2차원 테이블 형태로 구성된 모델<br>- 기본 키(PK)와 이를 참조하는 외래 키(FK)로 관계 표현<br>- 1:1, 1:N, N:M 관계를 자유롭게 표현<br><br> ![image](https://user-images.githubusercontent.com/87363461/231910528-2bb95f0b-6aa2-44a7-9e47-03c4da5b41b1.png)|
|<b>계층 데이터<br>모델</b>|- 논리적 구조가 트리 형태로 구성된 모델<br>- 상하관계 존재(부모 개체 - 자식 개체)<br>- 1:N 관계만 허용<br><br> ![image](https://user-images.githubusercontent.com/87363461/231910632-4ffac8b8-1c79-4ddd-9b57-e271f063cf57.png)|
|<b>네트워크<br>데이터 모델</b>|- 논리적 구조가 그래프 형태로 구성된 모델<br>- CODASYL, DBTG 모델이라고도 불림<br>- 상위와 하위 레코드 사이에 다대다(N:M) 관계를 만족하는 구조<br><br> ![image](https://user-images.githubusercontent.com/87363461/231910761-4c6bdd57-15af-4b93-8ffa-e5de698b2017.png)|

## 3. 관계 데이터 모델

### 3-1. 관계 데이터 모델(Relation Data Model)

#### 1. 관계 데이터 모델 개념
- 관계 데이터 모델은 <b>데이터를 행과 열로 구성된 2차원 테이블 형태로 구성</b>한 모델을 말함
- 수학자 E.F.Codd 박사가 제안한 모델

#### 2. 관계 데이터 모델의 구성
|구성요소|설명|
|:---:|:---|
|<b>릴레이션</b><br>(Relation)|행(Row)과 열(Column)로 구성된 테이블|
|<b>튜플</b><br>(Tuple)|- 릴레이션의 행(Row)에 해당되는 요소|
|<b>속성</b><br>(Attribute)|- 릴레이션의 열(Column)에 해당되는 요소|
|<b>카디널리티</b><br>(Cardinality)|튜플(Row)의 수|
|<b>차수</b><br>(Degree)|애트리뷰트(Column)의 수|
|<b>스키마</b><br>(Schema)|데이터베이스의 구조, 제약 조건 등의 정보를 담고 있는 기본적인 구조|
|<b>인스턴스</b><br>(Instance)|정의된 스키마에 따라 생성된 테이블에 실제 저장된 데이터의 집합|

![image](https://user-images.githubusercontent.com/87363461/231911615-d807fbc2-61e9-4bfd-8cdf-f7ecd699eeeb.png)

<br>

### 3-2. 관계 대수(Relation Algebra)

#### 1. 관계 대수 개념
- 관계 대수느 관계형 데이터베이스에서 <b>원하는 정보와 그 정보를 어떻게 유도하는가를 기술</b>하는 절차적 정형 언어임

#### 2. 관계 대수 연산자의 종류

#### 일반 집합 연산자
- <b>수학의 집합 개념을 릴레이션에 적용</b>한 연산자

|연산자|기호|표현|설명|
|:---:|:---:|:---:|:---|
|<b>합집합</b><br>(Union)|∪|R∪S|합병 가능한 두 릴레이션의 R과 S의 집합|
|<b>교집합</b><br>(Intersection)|∩|R∩S|릴레이션의 R과 S에 속하는 모든 튜플로 결과 릴레이션 구성|
|<b>차집합</b><br>(Difference)|-|R-S|R에 존재하고 S에 미 존재하는 튜플로 결과 릴레이션 구성|
|<b>카디션 프로덕트</b><br>(CARTESIAN Product)|X|RXS|R과 S에 속한 모든 튜플을 연결해 만들어진 새로운 튜플로 릴레이션 구성|

![image](https://user-images.githubusercontent.com/87363461/231911686-ca6b33f5-ca8c-4a8a-adf7-b4b2070a32e3.png)

<br>

#### 순수 관계 연산자
- <b>관계 데이터베이스에 적용할 수 있도록</b> 특별히 개발한 관계 연산자

|연산자|기호|표현|설명|
|:---:|:---:|:---:|:---|
|<b>셀렉트</b><br>(Select)|σ|σ 조건 (R)|릴레이션 R에서 조건을 만족하는 튜플 반환|
|<b>프로젝트</b><br>(Project)|π|π 속성리스트 (R)|릴레이션 R에서 주어진 속성들의 값으로만 구성된 튜플 반환|
|<b>조인</b><br>(Join)|⋈|R ⋈ S|공통 속성을 이용해 R과 S의 튜플들을 연결해 만들어진 튜플 반환|
|<b>디비전</b><br>(Division)|÷|R ÷ S|릴레이션 S의 모든 튜플과 관련 있는 R의 튜플 반환|

![image](https://user-images.githubusercontent.com/87363461/231912074-c8bae392-30d1-4bd6-9a61-b9f46c720dc0.png)

<br>

### 3-3. 관계 해석(Relational Calculus) 개념

#### 1. 관계 해석 개념
- 관계 해석은 <b>튜플 관계 해석과 도메인 관계 해석을 하는 비절차적 언어</b>를 말함

#### 2. 관계 해석 특징
- 프레디킷 해석(Predicate Calculus)에 기반한 언어이며 비절차적 언어(원하는 정보가 무엇이라는 것만 선언)임

### 3-4. 관계 대수와 관계 해석 비교
|구분|관계 대수|관계 해석|
|:---:|:---|:---|
|<b>특징</b>|절차적 언어(순서 명시)|비절차적 언어(계산 수식의 유연적 사용)|
|<b>목적</b>|어떻게 유도하는가? (How)|무엇을 얻을 것인가? (What)|
|<b>종류</b>|순수관계 연산자, 일반집합 연산자|튜플 관계 해석, |


## 4. 논리 데이터 모델링 속성
- 논리 데이터 모델링의 속성은 개체, 속성, 관계로 구분됨

|구조|설명|
|:---:|:---|
|<b>개체</b>(Entity)|관리할 대상이 되는 실체|
|<b>속성</b>(Attributes)|관리할 정보의 구체적 항목|
|<b>관계</b>(Relationship)|개체 간의 대응 관계|

### 4-1. 개체(Entity)
- 개체는 <b>사물 또는 사건으로 정의</b>되며 개체라고도 함
- 피터 챈 모델(Peter Chen Model)에서는 객체를 사각형(ㅁ)으로 표시함
- 까마귀발 모델(Crow's Foot Model)에서는 개체를 표 형식으로 표시함

### 4-2. 속성(Attribute)
- 속성은 <b>개체가 가지고 있는 요소 또는 성질</b>을 말함
- 피터 챈 모델(Peter Chen Model)에서는 속성을 타원형 (0)으로 표시함
- 까마귀발 모델(Crow's Foot Model)에서는 속성을 표 내부에 표시함
> - 속성명은 단수형으로 명명<br>- 개체명을 사용하지 않음<br>- 속성이 필수 사항(Not Null)인지, 필수 사항이 아닌지(Null) 고려하여 작성

![image](https://user-images.githubusercontent.com/87363461/231913399-2ad1628c-a900-4b05-b6f9-62f2ee288caa.png)

<br>

### 4-3. 관계(Relationship)
- 두 개체(Entity) 간의 관계 정의
- 피터 챈 모델(Peter Chen Model)에서는 관계는 마름모(◇)로 표시함
- 까마귀발 모델(Crow's Foot Model)에서는 속성을 다음 표와 같이 표시함

|관계 표시|의미|
|:---:|:---|
|![image](https://user-images.githubusercontent.com/87363461/231913542-ef3241a0-c040-4567-9f1b-b1aa7c3382bf.png)|1:1 관계를 표시|
|![image](https://user-images.githubusercontent.com/87363461/231913559-63934e5a-72fc-4139-8abc-1aedff23867e.png)|1:n 관계를 표시|
|![image](https://user-images.githubusercontent.com/87363461/231913571-98f2a248-c64d-4006-9d7a-2c7353175260.png)|n:m 관계를 표시|

## 5. 개체-관게(E-R) 모델

### 5-1. 개체-관계(E-R) 모델 개념
- E-R 모델은 <b>현실 세계에 존재하는 데이터와 그들 간의 관계를 사람이 이해할 수 있는 형태로 명확하게 표현하기 위해 가장 널리 사용되고 있는 모델</b>을 말함
- 논리 데이터 모델링에서는 모든 이해당사자와 의사소통의 보조 자료로 E-R 모델을 활용함
- 요구사항으로부터 얻어낸 정보들을 <b>개체, 속성, 관계로 기술한 모델</b>임

![image](https://user-images.githubusercontent.com/87363461/231915970-1432bd14-c4d3-460c-b566-09695ff1d3f4.png)

<br>

### 5-2. 개체-관계(E-R) 다이어그램 기호
|구성|기호|
|:---:|:---:|
|<b>개체 집합</b>|ㅁ (사각형)|
|<b>관계 집합</b>|◇ (마름모)|
|<b>속성</b>|⬭ (타원)|
|<b>다중 값 속성</b>|ㅇ 안에 ㅇ (이중 타원)|
|<b>개체 집합 - 관계 집합 연결</b>|ㅡ (실선)|
|<b>개체 집합 - 속성 연결</b>|ㅡ (실선)|
|<b>관계 집합 - 속성 연결</b>|--- (점선)|


## 6. 정규화(Normalization)

### 6-1. 정규화 개념
- 정규화는 관계형 데이터 모델에서 <b>데이터의 중복성을 제거하여 이상 현상을 방지하고, 데이터의 일관성과 정확성을 유지하기 위해 무손실 분해하는 과정</b>을 말함

### 6-2. 이상 현상(Anomaly)
- 이상 현상은 <b>데이터의 중복성으로 인해 릴레이션을 조작할 때 발생하는 비합리적 현상</b>을 말함
- 삽입, 삭제, 갱신 이상이 있음

#### 데이터베이스 이상 현상 종류
|이상 현상|설명|
|:---:|:---|
|<b>삽입 이상</b>|정보 저장 시 해당 정보의 불필요한 세부정보를 입력해야 하는 경우|
|<b>삭제 이상</b>|정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우|
|<b>갱신 이상</b>|중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우|

### 6-3. 정규화 단계

#### 데이터베이스 정규화 단계
|단계|조건|
|:---:|:---|
|<b>1정규형</b>(1NF)|원자값으로 구성|
|<b>2정규형</b>(2NF)|부분 함수 종속 제거(완전 함수적 종속 관계)|
|<b>3정규형</b>(3NF)|이행함수 종속 제거|
|<b>보이스-코드 정규형</b>(BCNF)|결정자 후보 키가 아닌 함수 종속 제거|
|<b>4정규형</b>(4NF)|다치(다중 값)종속 제거|
|<b>5정규형</b>(5NF)|조인 종속 제거|

### 6-4. 함수 종속(FD, Functional Dependency)

#### 1. 함수 종속 개념
- 릴레이션에서 <b>속성의 의미와 속성 간 상호 관계로부터 발생하는 제약조건</b>임

#### 2. 결정자(Determinant)/종속자(Dependent)
- X -> Y 관계일 때 X는 결정자, Y는 종속자임

#### 3. 함수 종속 종류
|종류|설명|
|:---:|:---|
|<b>부분 함수 종속</b><br>(Partial Functional<br>Dependency)|릴레이션에서 기본 키가 복합 키일 경우 기본 키를 구성하는 속성 중 일부에게 종속된 경우|
|<b>완전 함수 종속</b><br>(Full Functional<br>Dependency)|릴레이션에서 X -> Y 관계가 있을 때, Y는 X의 전체 속성에 대해 종속하고, 부분 집합 속성에 종속하지 않는 경우|
|<b>이행 함수 종속</b><br>(Transitive Functional<br>Dependency)|릴레이션에서 X -> Y, Y -> Z 종속 관계가 있을 때, X -> Z가 성립되는 경우|

### 6-5. 정규화 상세 단계

#### 1. 1차 정규화(1NF)

![image](https://user-images.githubusercontent.com/87363461/231918444-d85232f0-9e50-4369-b51f-92668c70a57c.png)

- 테이블 내의 속성값은 원자값을 가지고 있어야 함
- 이메일 주소가 속성에 2개 이상 가지고 있는 경우 원자값이 아니기 때문에 속성 1개만 가지도록 저장하면 1차 정규화를 만족함

<br>

#### 2. 2차 정규화(2NF)

![image](https://user-images.githubusercontent.com/87363461/231918537-68ebb0ba-d0f7-4170-9113-a3c0e7c98ded.png)

- <고객명, 서비스 이름>이 <서비스 이용 기간>에 영향을 주고, <서비스 이름>이 <서비스 가격>에 영향을 주는 관계를 부분함수 종속 관계라고 함
- <고객명, 서비스 이름, 서비스 가격, 서비스 이용 기간>을 한 테이블에 두는 것을 부분함수 종속성으로 인해 2차 정규화를 만족하지 못함
- 부분 관계인 <서비스 이름, 서비스 가격> 관계를 별도의 테이블로 두면 부분 함수 종속 관계가 제거되어 2차 정규화를 만족함

<br>

#### 3. 3차 정규화(3NF)

![image](https://user-images.githubusercontent.com/87363461/231919039-c9f998ad-830a-4093-a70b-fa7d564dde24.png)

- <책번호>가 <출판사>에 영향을 주고, <출판사>가 <홈페이지>에 영향을 주는 관계인 A -> B이고, B -> C이면서 A -> C 관계가 같이 있는 경우를 이행함수 종속 관계라고 함
- <책번호, 출판사, 홈페이지>를 한 테이블에 두는 것은 이행함수 종속성으로 인해 3차 정규화를 만족하지 못함
- <책번호>는 <홈페이지>에 직접 영향을 주는 관계가 아니기 때문에 (A -> C 관계), <책번호, 출판사> 테이블, <출판사, 홈페이지> 테이블로 분리하여 이행함수 관계를 제거하여 3차 정규화를 만족함

<br>

#### 4. 보이스-코드 정규화(BCNF)

![image](https://user-images.githubusercontent.com/87363461/231919320-978b43dc-8dab-4e5e-a3ab-1a22244c30e3.png)

- <학번, 과목명>이 <교수명>에 영향을 주고, <교수명>이 <과목명>에 영향을 주는 관계로서, <교수명>은 <과목명>에 영향을 주지만, 한 테이블에 같이 존재하고 <교수명>은 키가 아닌 상황이므로 결정자인 <교수명>이 후보 키가 아님
- <학번, 과목명, 교수명>을 한 테이블에 두는 것은 <교수명>이 결정자이지만, 후보 키가 아니기 때문에 보이스-코드 정규화를 만족하지 못함
- <교수명>은 <과목명>에 직접 영향을 주기 때문에 <교수명, 과목명> 테이블로 분리하여 교수명이 후보 키 역할을 하도록 하여 보이스-코드 정규화를 만족함

<br>


#### 5. 4차 정규화(4NF)

![image](https://user-images.githubusercontent.com/87363461/231919502-e2db0657-02af-45fe-82f7-a70c2d9d4c3b.png)

- <개발자>마다 <자격증> 값들이 여러 개 존재하고, 특정 <개발자>마다 <언어> 값들이 여러 개 존재하는 경우 다치 종속 관계라고 함
- <개발자>별로 여러 <자격증> 값을 가지고 있고, <개발자> 별로 여러 <언어>값을 가지고 있으므로 <개발자 자격증>, <개발자, 언어> 테이블로 분리하여 관리하던 다치 종속 관계를 제거하기 때문에 4차 정규화를 만족함


#### 6. 5차 정규화(5NF)

![image](https://user-images.githubusercontent.com/87363461/231919645-24ddc98e-6930-4c87-8cff-bca815e66b8d.png)

- 4차 정규화 테이블에 대해 조인 연산을 수행하면 4차 정규화 수행 전 데이터와 다르게 되는 문제인 조인 종속이 발생함

![image](https://user-images.githubusercontent.com/87363461/231919687-c43a244e-2d81-46e0-9e89-e7d153fdc9e0.png)

![image](https://user-images.githubusercontent.com/87363461/231919705-bed198fb-258a-4285-b94b-a4605cba479d.png)

- 조인 종속 관계를 제거하기 위해서는 모든 속성 관계인 <개발자, 자격증>, <개발자, 언어>뿐 아니라 <자격증, 언어> 관계에 대한 테이블을 만들어 줌으로써 조인했을 때 정확히 원래의 데이터로 복원할 수 있게 함


## 7. 반 정규화(De-Normalization) 개념

### 7-1. 반정규화 개념
- 반 정규화는 <b>정규화된 엔티티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법</b>을 말함
- 비정규화, 역정규화라고도 불림

### 7-2. 반정규화 특징
|장점|단점|
|:---|:---|
|- 반정규화된 데이터 구조는 성능 향상과 관리의 효율성이 증가함|- 데이터의 일관성 및 정합성 저하<br>- 유지를 위한 비용이 별도로 발생하여 성능에 나쁜 영향을 미칠 수 있음|
- 반 정규화를 위해서는 <b>데이터의 일관성과 무결성을 우선</b>으로 할지 <b>데이터베이스의 성능과 단순화에 우선순위를 둘 것</b>인지를 비교하여 조정하는 과정이 중요함

### 7-3. 반 정규화 기법

- <b>테이블</b>
  - <b>테이블 병합</b>
    - 1:1 관계, 1:M 관계를 통합하여 조인 횟수를 줄여 성능을 향상
    - 슈퍼타입/서브타입 테이블 통해 성능 향상
  - 테이블 분할
    - 테이블을 수직 또는 수평으로 분할하는 것을 파티셔닝이라고 함
    - <b>수평 분할</b> : 테이블 분할에 레코드를 기준으로 활용
    - <b>수직 분할</b> : 하나의 테이블에 가지는 컬럼의 개수가 증가하는 경우 활용<br>갱신 위주의 속성 분할, 자주 조회되는 속성 분할, 크기가 큰 속성 분할, 보안을 적용해야 하는 속성 분할
  - <b>중복 테이블 추가</b>
    - 대량의 데이터들에 대한 집계 함수(GROUP BY, SUM 등)를 사용하여 실시간 통계정보를 계산하는 경우에 효과적인 수행을 위해 별도의 통계 테이블을 두거나 중복 테이블을 추가
    - <b>집계 테이블 추가</b> : 집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거를 설정하여 사용하는 것으로, 트리거의 오버헤드에 유의 필요
    - <b>진행 테이블 추가</b> : 이력 관리 등의 목적으로 추가하는 테이블로, 적절한 데이터양의 유지와 활용도를 높이기 위해 기본키를 적절히 설정
    - <b>특정 부분만을 포함하는 테이블 추가</b> : 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블을 생성
- <b>컬럼</b>
  - <b>컬럼 중복화</b>
    - 조인 성능 향상을 위한 중복 허용
- <b>관계</b>
  - <b>중복관계 추가</b>
    - 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만, 이때 발생할 수 있는 성능 저하를 예방하기 위해 추가적 관계를 

<br>

---

<br>

# 물리 데이터 모델 설계(:star::star::star:)

## 1. 물리 데이터 모델링 개념
- 물리 데이터 모델링은 <b>논리모델을 적용하고자 하는 기술에 맞도록 상세화해가는 과정</b>을 말함

![image](https://user-images.githubusercontent.com/87363461/231941507-91c0b6cd-beb3-49c9-8ca1-9ad0c08fe771.png)

<br>

## 2. 물리 데이터 모델링 변환 절차
|순서|절차|변환 방법|
|:---:|:---:|:---|
|1|<b>개체를 테이블로<br>변환</b>|- 일반적으로 테이블과 개체 명칭을 동일하게 하는 것을 권고<br>- 개체는 한글명을 사용<br>- 테이블은 소스 코드의 가독성을 위해 영문명 사용|
|2|<b>속성을 컬럼으로<br>변환</b>|- 개발자와 사용자 간 의사소통을 위해 표준화된 약어를 사용하도록 권고<br>- SQL 예약어 사용은 피해야 함<br>- SQL 문장 가독성을 높이기 위해 컬럼 명칭은 되도록 짧은 것을 권고<br>- 컬럼명으로 복합단더 사용 시 미리 정의된 표준에 의해서 명명해야 함|
|3|<b>UID를 기본키로<br>변한</b>|- 개체의 UID에 해당하는 모든 속성에 대해 기본키로 선언<br>- Not Null, Unique 등의 제약 조건을 추가로 정의<br>- 관계에 의한 외래키가 기본키에 포함될 수 있음|
|4|<b>관계를 외래키로<br>변환</b>|- 외래키명은 기본키 이름을 그대로 사용하나 다른 의미를 가질 경우 변경 가능<br>- 순환 관계에서 자신의 기본키는 외래키로 정의|
|5|<b>컬럼 유형과<br>길이 정이</b>|- 적절한 유형을 정의하고 데이터의 최대 길이를 파악하여 길이를 설정<br>- 데이터 유형으로 CHAR, VARCHAR2, NUMBER, DATE, BLOB, CLOB 등이 있음<br><br>- CHAR : 최대 2000바이트의 고정길이 문자열 저장 가능<br>- VARCHAR2 : 최대 4000바이트의 가변 길이 문자열 저장 가능<br>- NUMBER : 38 자리수의 숫자 저장 가능<br>- DATE : 날짜 값을 저장<br>- BLOB, CLOB : 바이너리(Binary), 텍스트 데이터 최대 4GB까지 저장|
|6|<b>반 정규화<br>수행</b>|- 시스템 성능 향상과 개발 및 운영의 단순화를 위해 데이터 모델을 통합하는 반정규화 수행<br>- 데이터 유형으로 중복 테이블 추가, 테이블 조합, 분할, 제거, 컬럼 중복화가 있음<br><br>- 중복 테이블 추가 : 집게 테이블 추가 및 특정 부분만 포함하는 테이블 추가<br>- 테이블 조합 : 1:1, 1:N 테이블 조합, 슈퍼타입 / 서브타입 테이블 조합<br>- 테이블 분할 : 수직 분할 / 수평 분할<br>- 테이블 제거 : 테이블 재정의 및 접근하지 않는 테이블 제거<br>- 컬럼 중복화 : 조인 성능 향상을 위한 중복 허용|

<br>

---

<br>

# 물리 데이터 저장소 구성(:star:)
- 물리 데이터 저장소 구성을 위해 DBMS를 선정한 이후의 활동으로 구성됨

## 1. 데이터베이스 무결성(Database Intergrity)

### 1-1. 데이터베이스 무결성 개념
- 데이터 무결성은 <b>데이터베이스에 저장된 데이터 값과 그것이 표현되는 현실 세계의 실제 값이 일치하는 성질</b>임
- 데이터 무결성을 유지하는 것은 데이터베이스 관리 시스템(DBMS)의 중요한 기능이며, **주로 데이터에 적용되는 연산에 제한을 두어 데이터의 무결성을 유지**함
- 무결성은 **권한이 있는 사용자로부터 데이터베이스를 보호**함

### 1-2. 데이터베이스 무결성 종류

|종류|설명|주요 기법|
|:---:|:---|:---:|
|<b>개체 무결성</b><br>(Entity Intergirty)|- 한 엔티티에서 **같은 기본 키(PK)를 가질 수 없거나**, 기본 키(PK)의 **속성이 NULL을 허용할 수 없는** 제약 조건|- 기본 키(Primary Key)<br>- 유니크 인덱스(Unique Index)|
|<b>참조 무결성</b><br>(Referential Intergirty)|- **외래 키가 참조하는** 다른 개체의 기본 키에 해당하는 값이 **기본 키값이나 NULL이어야 하는** 제약 조건|- 외래 키(Foreign Key)|
|<b>속성 무결성</b><br>(Attribute Intergirty)|- **속성의 값은 기본값, NULL 여부, 도메인이 지정된 규칙을 준수**해야 하는 제약 조건|- 체크(CHECK)<br>- NULL / NOT NULL<br>- 기본값(DEFAULT)|
|<b>사용자 정의 무결성</b><br>(User-Defined<br>Intergirty)|- 사용자의 의미적 요구사항을 준수해야 하는 제약 조건|- 트리거(TRIGGER)<br>- 사용자 정의 데이터 타입|
|<b>키 무결성</b><br>(Key Intergirty)|- 한 릴레이션에 같은 키값을 가진 튜플들을 허용할 수 없는 제약 조건|- 유니크(Unique)|

## 2. 키(Key)

## 2-1. 키 개념
- 키는 데이터베이스에서 **조건을 만족하는 튜플을 찾거나 순서대로 정렬할 때 다른 튜플들과 구별할 수 있는 기준이 되는 속**성을 말함

## 2-2. 키 특성
- 키 특성에는 유일성과 최소성이 있음


|특성|설명|
|:---:|:---|
|유일성(Unique)|식별자에 의해 엔티티 타입 내에 모든 엔티티들이 유일하게 구분|
|최소성(Minimality)|최소한의 속성으로 식별자 구성|

## 2-3. 키 종류

|종류|설명|
|:---:|:---|
|<b>기본 키</b><br>(Primary Key)|- 테이블의 각 튜플들을 **고유하게 식별**하는 컬럼|
|<b>대체 키</b><br>(Alternate Key)|- 후보 키 중에서 **기본 키로 선택되지 않은** 키|
|<b>후보 키</b><br>(Candidate Key)|- 테이블에서 **각 튜플을 구별하는 데 기준이** 되는 컬럼<br>- 기본키와 대체 키를 합친 키|
|<b>슈퍼 키</b><br>(Super Key)|- 릴레이션을 구성하는 **모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못하는** 키|
|<b>외래 키</b><br>(Foreign Key)|- 테이블 간의 **참조 데이터 무결성을 위한 제약 조건**<br>- 한 릴레이션의 컬럼이 다른 릴레이션의 기본 키로 이용되는 키|


## 3. 인덱스(Index) 설계
- 인덱스 설계 시 적용 기준, 컬럼 선정 등을 고려하여 설계해야 함

### 3-1. 인덱스 개념
- 검색 연산의 최적화를 위해 **데이터베이스 내 열에 대한 정보를 구성한 데이터 구조**를 말함
- 인덱스를 통해 전체 데이터의 검색 없이 **필요한 정보에 대해 신속한 조회가 가능**함

### 3-2. 인덱스 적용 기준
- 인덱스 분포가 10 ~ 15% 이내인 경우 아래 수식을 참고함

```
- 분포도 = (1 / (컬럼 값의 종류)) * 100
- 분포도 = (컬럼 값의 평균 Row 수) / (테이블 총 Row 수) * 100
```

- 분포도가 범위 이상이더라도 부분처리를 목적으로 하는 경우 적용함
- 조회 및 출력 조건으로 사용되는 컬럼인 경우 적용
- 인덱스 자동생성 기본키와 Unique 키의 제약 조건을 사용할 경우 적용


### 3-3. 인덱스 컬럼 선정
- 분포도가 종흔 컬럼은 단독적으로 생성
- 자주 조합되어 사용되는 컬럼은 결합 인덱스로 생성
- 결합 인덱스는 구성되는 컬럼 순서 선정(사용 빈도, 유일성, 정렬 등)에 유의
- 가능한 한 수정이 빈번하지 않은 컬럼을 선정함


## 4. 파니셔닝(Partitioing) 개념

### 4-1. 파티셔닝 개념
- 파니셔닝은 **테이블 또는 인덱스 데이터를 파티션 단위로 나누어 저장하는 기법**을 말함

### 4-2. 파티션의 유형
- 파티션의 유형애는 레인저 파티셔닝, 해시 파티셔닝, 리스트 파티셔닝, 컴포지트 파티셔닝, 라운드 로빈 등이 있음

#### 1. 레인지 파티셔닝(Range Partitioning)
- **연속적인 숫자나 날짜를 기준**으로 하는 파티셔닝 기법을 말함
- 손쉬운 관리 기법을 제공하여 **관리 시간의 단축 가능**
- 예) 우편번호, 일별, 월별, 분기별 등의 데이터에 적합

![image](https://user-images.githubusercontent.com/87363461/231944078-73d4c923-a5b8-4414-aa0e-db1dcee9b00a.png)

<br>


#### 2. 해시 파티셔닝(Hash Partitioning)
- **파티션 키의 해시 함수 값에 의한** 파티셔닝 기법임
- **균등한 데이터 분할이** 가능하고 **질의 성능이 향상** 가능함
- 예) 파티션을 위한 범위가 없는 데이터에 적합

![image](https://user-images.githubusercontent.com/87363461/231944217-b60f78eb-c138-4735-8de0-77db34a13639.png)

<br>

#### 3. 리스트 파티셔닝(List Partitioning)
- 특정 파티션에 저장될 때 **데이터에 대한 명시적 제어가 가능**한 파티셔닝 기법을 말함
- **분포도가 비슷하고 데이터가 많은 SQL에서 컬럼의 조건이 많이 들어오는 경우** 유용함
- 예) [한국, 일본, 중국 -> 아시아][노르웨이, 스웨덴, 필란드 -> 북유럽]

![image](https://user-images.githubusercontent.com/87363461/231944439-1e7d781e-9443-475e-8df4-7ffc295fb033.png)

<br>

#### 4. 컴포지트 파티셔닝(Composite Partitioning)
- 레인지 퍼티셔닝, 해시 파티셔닝, 리스트 파티셔닝 중 **2개 이상의 파티셔닝을 결합**하는 파티셔닝 기법
- 큰 파티션에 대한 **I/O 요청을 여러 파티션으로 분산 가능**
- 예) 레인지 파티셔닝 할 수 있는 컬럼이나 파티션이 너무 커서 효과적으로 관리할 수 없을 때 유용


<br>

#### 5. 라운드 로빈(Round-Robini)
- 라운드로빈은 **라운드로빈으로 회전하면서 새로운 행을 파티션에 할당하는 기법**을 말함
- 파티션에 행의 고른 분포를 원할 때 사용

![image](https://user-images.githubusercontent.com/87363461/231944657-713f1648-2e7f-47fd-8f86-6d90c01a9da0.png)

<br>

### 파티션의 장점
|속성|설명|
|:---:|:---|
|<b>성능 향상</b>|- 데이터 액세스 범위를 줄여 성능 향상|
|<b>가용성 향상</b>|- 전체 데이터의 훼손 가능성이 감소 및 데이터 가용성 향상|
|<b>백업 가능</b>|- 분할 영역을 독립적으로 백업하고 복구 가능|
|<b>경합 감소</b>|- 디스크 스트라이핑으로 입출력 성능 향상<br>- 디스크 컨트롤러에 대한 경합 감소|

<br>

---

<br>

# 데이터베이스 종류(:star::star::star:)

## 1. 데이터베이스(Database)

### 1-1. 데이터베이스 개념
- 데이터베이스는 <b>다수의 인원, 시스템 또는 프로그램이 사용할 목적으로 통합하여 관리되는 데이터의 집합</b>을 말함
- 데이터에 대한 효과적인 관리를 위해 자료의 중복성 제거, 무결성 확보, 일관성 유지, 유용성 보장이 중요함
- 데이터베이스는 통합된 데이터, 저장된 데이터, 운영 데이터, 공용 데이터임

#### 데이터베이스 정의
|정의|설명|
|:---:|:---|
|<b>통합된 데이터</b><br>(Intergrated Data)|자료의 중복을 배제한 데이터의 모임|
|<b>저장된 데이터</b><br>(Stored Data)|저장 매체에 저장된 데이터|
|<b>운영 데이터</b><br>(Operational Data)|조직의 업무를 수행하는 데 필요한 데이터|
|<b>공용 데이터</b><br>(Shared Data)|여러 애플리케이션, 시스템들이 공동으로 사용하는 데이터|

### 1-2. 데이터베이스 특성
- 데이터베이스에 특성에는 <b>실시간 접근성, 계속적인 변화, 동시공용, 내용 참조</b>가 있음

|특성|설명|
|:---:|:---|
|<b>실시간 접근성</b><br>(Real-Time<br>Accessibility)|쿼리에 대하여 실시간 응답이 가능해야 함|
|<b>계속적인 변화</b><br>(Continuous<br>Evolution)|새로운 데이터의 삽입(Insert), 삭제(Delete), 갱신(Update)으로 항상 최신의 데이터를 유지함|
|<b>동시 공용</b><br>(Concurrent Sharing)|다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 함|
|<b>내용 참조</b><br>(Contnet Reference)|데이터베이스에 있는 데이터를 참조할 때 데이터의 레코드의 주소나 위치에 의해서가 아닌, 사용자가 요구하는 데이터 내용으로 데이터를 찾음|


### 1-3. 데이터베이스 종류

#### 1. 파일 시스템(File System) 개념
- 파일에 이름을 부여하고 저장이나 검색을 위하여 논리적으로 그것들을 어디에 위치시켜야 하는지 등을 정의한 뒤 관리하는 데이터베이스 전 단계의 데이터 관리 방식

#### 파일 시스템 종류

|종류|설명|
|:---:|:---|
|<b>ISAM</b>|- Indexed Sequential Access Method<br>- 자료 내용은 주 저장부, 자료의 색인은 자료가 기록된 위치와 함께 색인부에 기록되는 시스템|
|<b>VSAM</b>|- Virtual Storage Access Method<br>- 대형 운영체제에서 사용되는 파일 관리 시스템|

#### 2. 관계형 데이터베이스 관리 시스템(RDBMS, Relational Database Managerment System)
- 관계형 DBMS는 <b>관계형 모델을 기반</b>으로 하는 가장 보편화된 데이터베이스 관리 시스템
- 데이터를 저장하는 테이블의 일부를 다른 테이블과 상하 관계로 표시하며 상관관계를 정리함
- 변화하는 업무나 데이터 구조에 대한 유연성이 좋아 유지 관리가 용이함
- 종류로 Oracle, SQL Server, MySQL, Maria DB 등이 있음

![image](https://user-images.githubusercontent.com/87363461/231926284-9a761492-ef80-4619-8b96-64d45edb6d16.png)


<br>

#### 3. 계층형 데이터베이스 관리 시스템(HDBMS, Hierachical Database Management System)
- 계층형 DBMS는 <b>데이터를 상하 종속적인 관계로 계층화</b>하여 관리하는 데이터베이스임
- 데이터에 대한 접근 속도가 빠르지만, 종속적인 구조로 인하여 변화하는 데이터 구조에 유연하게 대응하기 어려움
- 종류로 IMS(Information Management System), System2000 등이 있음

![image](https://user-images.githubusercontent.com/87363461/231926442-295cdc49-d73f-4364-bd12-8b8e5267275b.png)


<br>

#### 4. 네트워크 데이터베이스 관리 시스템(NDBMS, Network Database Management System)
- 네트워크 DBMS는 데이터의 구조를 <b>네트워크상의 망상 형태로 표현</b>한 데이터 모델
- 트리 구조나 계층형 데이터베이스보다는 유연하지만 설계가 복잡한 단점이 있음
- 종류로 IDS(Intergrated Data Store), IDMS(Intergrated Database Management System) 등이 있음

![image](https://user-images.githubusercontent.com/87363461/231926671-b5a8e9df-2dd5-46e8-8b55-4e8ed79a4d59.png)


### 1-4. 데이터베이스 관리 툴
- 데이터베이스 관리 툴은 <b>DB 관리자(DBA)들이 데이터베이스를 펼니하고 쉽게 다룰 수 있도록 도와주는 도구</b>를 말함
- 오픈 소스 기반으로 무료로 사용할 수 있는 툴과 상용화로 비용을 지불해야 사용할 수 있는 툴이 존재함

#### 데이터베이스 관리 툴 기능
|기능|설명|
|:---:|:---|
|<b>데이터베이스 생성, 삭제</b>|CREATE와 DROP 명령을 통해 데이터베이스의 생성 및 삭제 가능|
|<b>SQL 명령어 작성 및 실행</b>|SELECT, INSERT, DELETE, UPDATE 명령을 통해 데이터를 조회, 입력, 삭제, 수정 가능|
|<b>상태 모니터링</b>|받은 데이터양, 보낸 데이터양, 동시 연결 수, 실패한 시도 등의 상태를 표시|
|<b>사용자 계정 관리</b>|최상위 레벨의 SYS 계정, SYS로부터 DBA권한을 받은 SYSTEM 계정, 일반 사용자 계정 등의 관리 가능|
|<b>데이터베이스 내보내기/가져오기</b>|데이터베이스 마법사를 통해 파일 형태로 데이터 내보내기/가져오기 가능|
|<b>환경 설정</b>|버퍼의 크기, 동시 접속 클라이언트 숫자, 스레드 숫자 등의 환경 변수 설정|


## 2. DBMS(DataBase Management System)

### 2-1. DBMS 개념
- DBMS는 <b>데이터 관리의 복잡성을 해결하는 동시에 데이터 추가, 변경, 검색, 삭제 및 백업, 복구, 보안 등의 기능을 지원</b>하는 소프트웨어
- 저장되는 정보는 텍스트, 이미지, 음악 파일, 지도 데이터 등 매우 다양하며 SNS의 발달과 빅데이터의 폭넓은 활용으로 인해 데이터의 종류와 양은 급격히 증가 중

### 2-2. DBMS 유형
|유형|설명|
|:---:|:---|
|<b>키-값(Key-Value)<br>DBMS</b>|- 키 기반 Get / Put / Delete 제공<br>- 메모리 기반에서 성능 우선 시스템 및 빅데이터 처리 가능 DBMS<br>- Unique 한 키에 하나의 값을 가지고 있는 형태<br><br>- 예) Redis, DynamoDB|
|<b>컬럼 기반 데이터 저장<br>DBMS</b><br>(Column Family<br>data Store DBMS)|- Key 안에 (Column, Value) 조합으로 된 여러 개의 필드를 갖는 DBMS<br>- 테이블 기반, 조인 미지원, 컬럼 기반으로 구글의 Bigtable 기반으로 구현<br><br>- 예) HBase, Cassandra|
|<b>문서 저장<br>DBMS</b><br>(Document Store<br>DBMS)|- 값(Value)의 데이터 타입이 문서(Document)라는 타입을 사용하는 DBMS<br>- 문서 타입은 XML, JSON과 같이 구조화된 데이터 타입으로, 복잡한 계층 구조 표현 가능<br><br>- 예) MongoDB, Couchbase|
|<b>그래프 DBMS</b>(Graph DBMS)|- 시맨틱 웹과 온톨로지 분야에서 활용되는 그래프를 데이터로 표현하는 DBMS<br>- 노드와 엣지로 특징되는 요소 특화<br>- 노드 간 관계를 구조화하여 저장<br><br>- 예) Neo4j, AllegroGraph|


### 2-3. DBMS 특징

|특징|설명|
|:---:|:---|
|<b>데이터 무결성</b>|부적절한 자료가 입력되어 동일한 내용에 대하여 서로 다른 데이터가 저장되는 것을 허용하지 않는 성질|
|<b>데이터 일관성</b>|삽입, 삭제, 갱신, 생성 후에도 저장된 데이터가 변함없이 일정|
|<b>데이터 일관성</b>|장애가 발생하였을 시 특정 상태로 복구되어야 하는 성질|
|<b>데이터 보안성</b>|불법적인 노출, 변경, 손실로부터 보호되어야 하는 성질|
|<b>데이터 효율성</b>|응답 시간, 저장 공간 활용 등이 최적화되어 사용자, 소프트웨어, 시스템 등의 요구 조건을 만족시켜야 하는 성질|

### 2-4. 상용 DBMS 및 오픈 소스 기반 DBMS

#### 1. 상용 DBMS
- 상용 데이터베이스 관리 시스템은 특정 회사에서 유료로 판매하는 시스템을 말함
- 유지보수와 지원이 원활함

#### 2. 오픈 소스 기반 DBMS
- 오픈 소스 기반 데이터베이스 시스템은 오픈 소스 정책을 준용하는 범위 내에서 사용이 자유로움

#### 오픈 소스 기반 데이터베이스 관리 시스템 사용 시 고려 사항
- 기업들의 원가 절감 노력과의 상관관계 파악
- 인공 지능, 클라우드, 빅데이터 등 새로운 기술의 증가에 따른 오픈 소스 데이터베이스 관리 시스템 대응 동향 분석
- 오픈 소스 진영에서 보안, 안전성에 대한 우려를 해결하고자 노력하는지 조사
- 정책적으로 오픈 소스 데이터베이스 관리 시스템 활성화를 추진하는 사례 정리

## 3. 데이터베이스 기술 트랜드

### 3-1. 빅데이터

#### 1. 빅데이터(Big Data) 개념
- 빅데이터는 시스템, 서비스, 조직(회사) 등에서 **주어진 비용, 시간 내에 처리 가능한 데이터 범위를 넘어서는 수십 페타바이트(PB) 크기의 비정형 데이터**를 말함

#### 빅데이터의 특성

|특성|설명|
|:---:|:---|
|<b>데이터의 양</b><br>(Volume)|- 페타바이트 수준의 대규모 데이터<br>- 빅데이터 분석 규모에 관련된 특성<br>- 디지털 정보량이 기하급수적으로 폭증하는 것을 의미|
|<b>데이터의 다양성</b><br>(Variety)|- 정형, 비정형, 반정형의 다양한 데이터<br>- 빅데이터 자원 유형에 관련된 특성<br>- 로그, 소셜, 위치 등 데이터 유형이 다양해지는 것을 의미|
|<b>데이터의 속도</b><br>(Velocity)|- 빠르게 증가하고 수집되며, 처리되는 데이터<br>- 빅데이터 수집, 분석, 활용 속도와 관련된 특성<br>- 가치 있는 정보 활용을 위해 실시간 분석이 중요해지는 것을 의미|

#### 2. 빅데이터 수집, 저장, 처리 기술

|구분|설명|
|:---:|:---|
|<b>비정형/반정형<br>데이터 수집</b>|내,외부 정제되지 않은 데이터를 확보, 이를 통해 필요한 정보를 추출하여 활용하기 위해 효과적으로 수집 및 전송하는 기술<br>- 예) 척와(Chukwa), 플럼(Flume), 스크라이브(Scribe)|
|<b>정형 데이터 수집</b>|- 내,외부 정제된 대용량 데이터의 수집 및 전송 기술<br>- 예) ETL, FTP, 스쿱(Sqoop), 하이호(Hiho)|
|<b>분산데이터 저장/처리</b>|- 대용량 파일의 효과적인 분산 저장 및 분산 처리 기술<br>- 예) HDFS, 맵 리듀스|
|<b>분산데이터 베이스</b>|- HDFS의 칼럼 기반 데이터베이스로 실시간 랜덤 조회 및 업데이트가 가능한 기술<br>- 예) HBase|

### 3. 빅데이터 분석, 실시간 처리 및 시각화를 위한 주요 기술

|구분|설명|
|:---:|:---|
|<b>빅데이터 분석</b>|- 빅데이터를 분석하기 위한 데이터의 가공과 분류, 클러스터링, 패턴 분석을 처리하는 기술<br>- 데이터 가공을 위한 대표적인 솔루션에는 피그(Pig), 하이브(Hive)가 있고, 데이터 마이닝을 위한 대표적인 솔루션에는 머하웃(Mahout)이 있음|
|<b>빅데이터 실시간 처리</b>|- 하둡 기반의 실시간 SQL 질의 처리와 요청된 작업을 최적화하기 위한 워크플로우 기술<br>- 실시간 SQL 질의를 위한 대표적인 솔루션은 임팔라(Impala)이고, 워크플로우 관리를 위한 대표적인 솔루션은 우지(Oozie)가 있음|
|<b>분산 코디네이션</b>|- 분산 환경에서 서버들 간에 상호조정이 필요한 다양한 서비스를 분산 및 동시처리 제공 기술<br>- 분산 코디네이션을 위한 대표적인 솔루션은 주키퍼(Zookeeper)가 있음|
|<b>분석 및 시각화</b>|- 빅데이터 분석 기술을 통해 분석된 데이터의 의미와 가치를 시각적으로 표현하기 위한 기술<br>- 분석 및 시각화를 위한 대표정긴 솔루션은 알(R)이 있음|

### 3-2. NoSQL(Not Only SQL)

#### 1. NoSQL의 개념
- NoSQL은 전통적인 RDBMS와 다른 DBMS를 지칭하기 위한 용어로, **데이터 저장에 고정된 테이블 스키마가 필요하지 않고 조인(Join) 연산을 사용할 수 없으며 수평적으로 확장이 가능한 DBMS**를 말함

#### 2. NoSQL 특성(BASE)

|특성|설명|
|:---:|:---|
|<b>Basically Available</b>|- 언제든지 데이터는 접근할 수 있어야 하는 속성<br>- 분사 시스템이기 때문에 항상 가용성 중시|
|<b>Soft-State</b>|- 노드의 상태는 내부에 포함된 정보에 의해 결정되는 것이 아니라 외부에서 전송된 정보를 통해 결정되는 속성<br>- 특정 시점에서는 데이터의 일관성이 보장되지 않음|
|<b>Eventually Consistency</b>|- 일정 시간이 지나면 데이터의 일관성이 유지되는 속성<br>- 일관성을 중시하고 지향|

#### 3. NoSQL 유형

|유형|설명|
|:---:|:---|
|<b>Key-Value Store</b>|- Unique한 Key에 하나의 Value를 가지고 있는 형태<br>- 키 기반 Get / Put / Delete 제공하는 빅데이터 처리 가능 DB<br>- 예) Redis, DynamoDB|
|<b>Coulmn Family<br>Data Store</b>|- Key 안에 (Column, Value) 조합으로 된 여러 개의 필드를 갖는 DB<br>- 테이블 기반, 조인 미지원, 컬럼 기반, 구글의 Bigtable 기반으로 구현<br>- 예) HBase, Cassandra|
|<b>Document Store</b>|- Value의 데이터 타입이 Document라는 타입을 사용하는 DB<br>- Document 타입은 XML, JSON, YAML과 같이 구조화된 데이터 타입으로 복잡한 계층 구조 표현 가능<br>- 예) MongoDB, Couchbase|
|<b>Graph Store</b>|- 시맨틱 웹과 온톨로지 분야에서 활용되는 그래프로 데이터를 표현하는 DB<br>- 예) Neo4j, AllegroGraph|

### 3-3. 데이터 마이닝(Data Mining)

#### 1. 데이터 마이닝 개념
- 대규모로 저장된 **데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 기술**을 말함
- 데이터 마이닝은 대규모 데이터에서 **의미 있는 패턴을 파악하거나 예측하여 의사결정에 활용하는 기법**임

![image](https://user-images.githubusercontent.com/87363461/231949920-aff690d0-2f8a-4713-8104-e2da6ab8ef00.png)

- 데이터 마이닝은 데이터의 숨겨진 정보를 찾아내어 이를 기반으로 서비스와 제품에 도입하는 과정임
- 통계분석은 가설이나 가정에 따른 분석, 검증을 하지만 데이터 마이닝은 수리 알고리즘을 활용하여 대규모 데이터에서 의미 있는 정보를 찾아냄

#### 2. 데이터 마이닝 절차

|단계|절차|설명|
|:---:|:---:|:---|
|1|<b>목적 설정</b>|- 데이터 마이닝을 통해 얻고자 하는 명확한 목적 설정<br>- 목적에 따라 사용할 모델과 필요 데이터 정의|
|2|<b>데이터 준비</b>|- 거래정보, 웹로그 데이터, 고객 정보, 데이터 사용량, 소셜 데이터 등 다양한 데이터 활용<br>- 사전에 운영 데이터 접근에 따른 부하 고려<br>- 필요시 작업 서버에 저장하여 운영에 지장이 없도록 데이터 준비<br>- 데이터 정제를 통해 데이터의 품질을 보장하고, 필요시 데이터 추가 등을 통해 충분한 양의 데이터 확보|
|3|<b>가공</b>|- 모델링 목적에 따라 목적 변수 정의<br>- 필요한 데이터를 데이터 마이닝 소프트웨어에 적용할 수 있는 형식으로 가공 처리|
|4|<b>마이닝 기법 적용</b>|- 1단계의 명확한 목적에 맞도록 데이터 마이닝 기법을 적용하여 정보 추출|
|5|<b>정보 검증</b>|- 데이터 마이닝으로 추출된 정보 검증<br>- 텍스트 데이터와 과거 데이터를 활용하여 최적의 모델 선정<br>- 데이터 마이닝 결과의 업무 적용 보고서 작성 및 활용|

#### 3. 데이터 마이닝 주요 기법

|주요 기법|설명|
|:---:|:---|
|<b>분류 규칙</b><br>(Classification)|- 과거 데이터로부터 특성을 찾아내어 분류모형을 만들어 이를 토대로 새로운 레도크의 결과 값을 예측하는 기법<br>- 마케팅, 고객 신용평가 모형에 활용<br>- 예) 우수 고객의 분류 모형 구축으로 마케팅 활용|
|<b>연관 규칙</b><br>(Association)|- 데이터 안에 존재하는 항목들 간 종속관계를 찾아내는 기법<br>- 제품이나 서비스의 교차판매, 매장 진열, 사기 적발 등 다양한 분야에서 활용<br>- 예) 넥타이 구매고객의 50% 이상이 셔츠를 구매한다는 정보 분석을 통해 매장의 상품 진열|
|<b>연속 규칙</b><br>(Sequence)|- 연관 규칙에 시간 관련 정보가 포함된 형태의 기법<br>- 개인별 트랜잭션 이력 데이터를 시계열적으로 분석하여 트랜잭션의 향후 발생 가능성 예측<br>- 예) A 품목을 구매한 회원이 B 품목을 구매할 확률은 75%|
|<b>데이터 군집화</b><br>(Clustering)|- 대상 레코들을 유사한 특성을 지닌 몇 개의 소그룹으로 분할하는 작업으로 작업의 특성이 분류규칙(Classification)과유사함<br>- 정보가 없는 상태에서 데이터를 분류하는 기법<br>- 분석대상과 결괏값이 없으며, 판촉활동이나 이벤트 대상을 선정하는 데 활용<br>- 예) 고객의 지역/연령/성별에 따른 차별화 홍보 전략|
